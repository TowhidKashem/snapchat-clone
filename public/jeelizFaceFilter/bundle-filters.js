/**
 * Jeeliz Face Filter - https://github.com/jeeliz/jeelizFaceFilter
 *
 * Copyright 2018 Jeeliz ( https://jeeliz.com )
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var JEEFACEFILTERAPI = (function () {
  window.JEEFACEFILTERAPIGEN = function () {
    function zb() {
      var a = null,
        c = null,
        d = null,
        e = 0;
      this.jd = function (f) {
        return a[f];
      };
      this.Jd = function (f) {
        var k = null;
        e = f.length;
        a = f.map(function (l, n) {
          l = Object.assign({}, l, { index: n, parent: this, Na: k, sd: n === e - 1 });
          return (k = n = 0 === n ? Lb.instance(l) : Mb.instance(l));
        });
        c = a[0];
        d = a[e - 1];
        a.forEach(function (l, n) {
          0 !== n && l.Ed();
        });
      };
      this.I = function (f, k) {
        var l = k;
        a.forEach(function (n) {
          l = n.I(l, f);
        });
        return l;
      };
      this.Rb = function () {
        return c.A();
      };
      this.Tb = function () {
        return d.kd();
      };
      this.Ld = function (f) {
        d.Tc(f);
      };
      this.Qb = function () {
        return d.Qb();
      };
      this.h = function () {
        a &&
          (a.forEach(function (f) {
            f.h();
          }),
          (d = c = a = null),
          (e = 0));
      };
    }
    var Ma, Na, Oa, Xa, Ya, Pa, Za, $a, ab, bb, jb, kb, lb, mb;
    function nb(a, c) {
      var d = c % 8;
      return (a[(c - d) / 8] >> (7 - d)) & 1;
    }
    function Nb(a) {
      var c = JSON.parse(a);
      a = c.ne;
      var d = c.nf,
        e = c.n;
      var f =
        'undefined' === typeof btoa
          ? Buffer.from(c.data, 'base64').toString('latin1')
          : atob(c.data);
      var k = f.length;
      c = new Uint8Array(k);
      for (var l = 0; l < k; ++l) c[l] = f.charCodeAt(l);
      f = new Float32Array(e);
      k = new Float32Array(d);
      l = a + d + 1;
      for (var n = 0; n < e; ++n) {
        for (
          var p = l * n,
            y = 0 === nb(c, p) ? 1 : -1,
            m = p + 1,
            r = 1,
            x = 0,
            z = m + a - 1;
          z >= m;
          --z
        )
          (x += r * nb(c, z)), (r *= 2);
        m = x;
        p = p + 1 + a;
        r = k.length;
        x = 0;
        for (z = p; z < p + r; ++z) (k[x] = nb(c, z, !0)), ++x;
        for (r = p = 0; r < d; ++r) p += k[r] * Math.pow(2, -r - 1);
        f[n] =
          0 === p && 0 === m ? 0 : y * (1 + p) * Math.pow(2, 1 + m - Math.pow(2, a - 1));
      }
      return f;
    }
    function ob() {
      return -1 !== [ba.play, ba.pause].indexOf(ea);
    }
    function Ob(a) {
      if (ea !== ba.pause) {
        var c = ea === ba.play ? H.Aa : I.Dc;
        cb = setTimeout(Ab.bind(null, a), c);
      }
    }
    function pb() {
      if (ea === ba.play) return !1;
      ea = ba.play;
      P.timestamp = Date.now();
      Qa && window.cancelAnimationFrame(Qa);
      Ab(0);
    }
    function Bb() {
      if (ea !== ba.play) return !1;
      cb && (clearTimeout(cb), (cb = null));
      Qa && (window.cancelAnimationFrame(Qa), (Qa = null));
      ea = ba.pause;
      return !0;
    }
    function Ca(a, c, d, e, f) {
      a = 4 * (3 * c + a) + d;
      return e + (U.buffer[a] / 255 + U.buffer[a + 12] / 65025) * (f - e);
    }
    function Cb() {
      ra.U();
      Q.reset();
      R.reset();
      t.ka();
      t.Kb();
      b.disable(b.DEPTH_TEST);
      b.disable(b.BLEND);
      Q.oa();
      t.xa();
    }
    function Ab() {
      if (ea !== ba.pause) {
        t.Kb();
        Q.reset();
        Q.oa();
        b.disable(b.DEPTH_TEST);
        ra.U();
        t.xa();
        if (!u.jb) {
          var a = u.element.currentTime - u.Oa;
          0 > a && (u.Oa = u.element.currentTime);
          1e3 * a < I.Yd ||
            (u.aa.refresh(), (u.Oa += a), t.set('s48'), u.ba.J(), u.aa.b(0), Q.g(!1, !1));
        }
        if (E.L.length > P.G) E.L.splice(0, E.L.length - P.G);
        else for (; E.L.length < P.G; ) E.L.push(0);
        if (1 !== E.i)
          if (ma.every(qb)) {
            for (var c = 0, d = (a = 0); d < ma.length; ++d)
              ma[d].detected > c && ((c = ma[d].detected), (a = 0));
            for (c = 0; c < P.G; ++c) E.L[c] = a;
          } else {
            a = E.bc;
            c = 0;
            for (d = !1; c < P.G; ++c) {
              if (qb(ma[a]))
                if (d) {
                  do ++a === E.i && (a = 0);
                  while (qb(ma[a]));
                } else d = !0;
              E.L[c] = a++;
              a >= E.i && (a = 0);
            }
            E.bc = a;
          }
        for (a = 0; a < P.G; ++a)
          (E.Z = E.L[a]),
            (E.ob = (0.5 + E.Z) / E.i),
            (E.Zb = E.L.lastIndexOf(E.Z) === a),
            t.set('s49'),
            H.ga && t.B('u37', ma[E.Z].rz),
            1 !== E.i && t.B('u36', E.ob),
            V.Ga.J(),
            u.ba.b(0),
            U.Qa.b(1),
            Q.g(!1, !1),
            V.Ga.b(0),
            za.I(!1, V.Ga);
        a = Date.now();
        P.ra = a - P.timestamp;
        P.timestamp = a;
        -1 !== X.nDetectsPerLoop
          ? (P.G = X.nDetectsPerLoop)
          : ((a = I.Ta),
            (P.fc = P.ec / P.ra),
            (P.hc = P.fc * a + P.hc * (1 - a)),
            (P.jc = 1e3 / P.ra),
            (P.ia = P.jc * I.Ta + P.ia * (1 - I.Ta)),
            P.ia > I.ea[1]
              ? ((a = I.za[1]),
                1 < E.i && (++a, (c = ma.filter(Pb).length), (a *= Math.max(1, c))),
                (P.G = Math.min(P.G + 1, a)),
                (P.ia = (I.ea[0] + I.ea[1]) / 2))
              : P.ia < I.ea[0] &&
                ((P.G = Math.max(P.G - 1, I.za[0])), (P.ia = (I.ea[0] + I.ea[1]) / 2)));
        ra.F();
        b.viewport(0, 0, 3, 2 * E.i);
        t.set('s47');
        U.Qa.b(0);
        Q.g(!1, !1);
        b.readPixels(0, 0, 3, 2 * E.i, b.RGBA, b.UNSIGNED_BYTE, U.buffer);
        for (a = 0; a < E.i; ++a)
          if (-1 !== E.L.indexOf(a)) {
            var e = a;
            c = Ua[e];
            var f = [e];
            d = ma[e];
            var k = rb[e],
              l = 2 * e;
            c.Da = Ca(1, l, 3, 0, 1);
            d.detected = pa.P(d.detected, c.Da, I.Ac);
            if (c.Da < I.mb) H.ga && (d.rz = 0);
            else {
              var n = U.ya;
              c.x = Ca(0, l, 1, -1, 1);
              c.y = Ca(0, l, 2, -1, 1);
              c.T = Ca(0, l, 3, 0, 1);
              c.rb = Ca(1, l, 0, -n[0], n[0]);
              c.sb = Ca(1, l, 1, -n[1], n[1]);
              c.va = Ca(1, l, 2, -n[2], n[2]);
              for (n = 0; n < U.R; ++n) c.Mb[n] = U.ta[n](Ca(2, l, n, 0, 1));
              f.Za = c.x - d.x;
              f.$a = c.y - d.y;
              f.Ya = c.T - d.s;
              f.Va = c.rb - d.rx;
              f.Wa = c.sb - d.ry;
              f.Xa = H.ga ? c.va : c.va - d.rz;
              f =
                (1 -
                  db.Ia(
                    sa.translationFactorRange[0],
                    sa.translationFactorRange[1],
                    Math.sqrt(f.Za * f.Za + f.$a * f.$a + f.Ya * f.Ya) / P.ra
                  )) *
                (1 -
                  db.Ia(
                    sa.rotationFactorRange[0],
                    sa.rotationFactorRange[1],
                    Math.sqrt(f.Va * f.Va + f.Wa * f.Wa + f.Xa * f.Xa) / P.ra
                  )) *
                db.Ia(sa.qualityFactorRange[0], sa.qualityFactorRange[1], c.Da);
              e = k[++sb[e] % k.length] = f;
              for (l = 0; l < k.length; ++l) e = Math.min(e, k[l]);
              e = Math.max(0.5, e);
              f = Math.min(e, f);
              k = pa.P(sa.alphaRange[1], sa.alphaRange[0], Math.pow(f, I.Cc));
              d.x = pa.P(d.x, c.x, k);
              d.y = pa.P(d.y, c.y, k);
              d.s = pa.P(d.s, c.T, k);
              d.rx = pa.P(d.rx, c.rb, k);
              d.ry = pa.P(d.ry, c.sb, k);
              d.rz = H.ga ? d.rz + k * c.va : pa.P(d.rz, c.va, k);
              k = Math.max(k, I.Bc);
              for (e = 0; e < U.R; ++e)
                d.expressions[e] = pa.P(d.expressions[e], c.Mb[e], k);
              ++c.La;
            }
          }
        ra.Wd();
        ra.reset();
        R.reset();
        b.enable(b.DEPTH_TEST);
        H.Ca && (1 === E.i ? H.Ca(ma[0]) : H.Ca(ma));
        b.disable(b.BLEND);
        ea === ba.play && (Qa = window.requestAnimationFrame(Ob));
      }
    }
    function Qb() {
      function a(d) {
        for (var e = [], f = 0; f < E.i; ++f) e.push(JSON.parse(JSON.stringify(d)));
        return e;
      }
      u.ba = R.instance({
        isPot: !1,
        isLinear: !0,
        isFloat: !1,
        width: V.M,
        height: V.O
      });
      V.Ga = R.instance({ isPot: !0, isFloat: !1, width: za.Rb() });
      var c = {
        width: 3,
        height: E.i,
        isFloat: !0,
        isPot: !1,
        array: (function (d) {
          for (var e = new Float32Array(d.length * E.i), f = 0, k; f < E.i; ++f)
            for (k = 0; k < d.length; ++k) e[f * d.length + k] = d[k];
          return e;
        })(
          new Float32Array([0, X.borderWidth, X.borderHeight, 0, 0, 0, 0, 0, 0, 0, 0, 0])
        )
      };
      U.Qa = Rb.instance(c);
      U.buffer = new Uint8Array(8 * c.width * E.i);
      Ua = a({
        Da: 0,
        x: 0,
        y: 0,
        T: 1,
        rb: 0,
        sb: 0,
        va: 0,
        Mb: new Float32Array(U.R),
        La: 0
      });
      ma = a({
        detected: 0,
        x: 0,
        y: 0,
        s: 1,
        rx: 0,
        ry: 0,
        rz: 0,
        expressions: new Float32Array(U.R)
      });
      a({ Za: 0, $a: 0, Ya: 0, Va: 0, Wa: 0, Xa: 0 });
    }
    function tb() {
      t.K('s49', [
        { type: '1i', name: 'u1', value: 0 },
        { type: '1i', name: 'u34', value: 1 },
        { type: '2f', name: 'u35', value: V.v },
        { type: '1f', name: 'u36', value: 0.5 },
        { type: '1f', name: 'u37', value: 0 }
      ]);
      t.K('s50', [
        { type: '1i', name: 'u38', value: 0 },
        { type: '1i', name: 'u34', value: 1 },
        { type: '1f', name: 'u41', value: I.Ud },
        { type: '1f', name: 'u42', value: I.xc },
        { type: '1f', name: 'u43', value: I.wc },
        { type: '3f', name: 'u40', value: [U.ca[0] * V.v[0], U.ca[1] * V.v[1], U.ca[2]] },
        { type: '1f', name: 'u36', value: 0.5 },
        { type: '1f', name: 'u44', value: 1 },
        { type: '1f', name: 'u37', value: 0 }
      ]);
      var a = [{ type: '1i', name: 'u38', value: 0 }];
      t.K('s51', a);
      t.K('s52', a);
      t.K('s47', [
        { type: '1i', name: 'u34', value: 0 },
        { type: '1f', name: 'u47', value: V.v[0] },
        { type: '2f', name: 'u46', value: [0, 0.5 / E.i] }
      ]);
    }
    function ub() {
      var a = za.Rb(),
        c = V.M / a;
      Pa = X.minScale * c;
      Za = X.maxScale * c;
      $a = (1 - 2 * X.borderWidth) / X.nStepsX;
      ab = (1 - 2 * X.borderHeight) / X.nStepsY;
      bb = (Za - Pa) / X.nStepsScale;
      jb = X.borderWidth;
      kb = X.borderHeight;
      lb = 1 - X.borderWidth;
      mb = 1 - X.borderHeight;
      V.v[0] = a / V.M;
      V.v[1] = a / V.O;
      Ma = X.borderWidth;
      Na = X.borderHeight;
      Oa = Pa;
      Xa = X.borderWidth;
      Ya = X.borderHeight;
      vb = Pa;
    }
    function Sb(a) {
      if (H.la) Db('string' === typeof H.la ? JSON.parse(H.la) : H.la, a);
      else {
        var c = H.xb;
        'JSON' !== c.toUpperCase().split('.').pop() && (c += I.save);
        Eb.get(c, function (d) {
          d = JSON.parse(d);
          Db(d, a);
        });
      }
    }
    function Db(a, c) {
      if (a.exportData) {
        var d = a.exportData;
        d.thetaXYZfactor && (U.ya = d.thetaXYZfactor);
        d.trackingDxysFactor && (U.ca = d.trackingDxysFactor);
        'undefined' !== typeof d.nExpressions && (U.R = d.nExpressions);
      }
      U.R || (U.R = I.ic);
      if (!U.ta) for (U.ta = [], d = 0; d < U.R; ++d) U.ta.push(I.cd);
      c(a);
    }
    function Tb() {
      if (
        Aa.o({
          Ua: H.V,
          width: V.M,
          height: V.O,
          debug: !1,
          kc: function () {
            Da('GLCONTEXT_LOST');
          },
          antialias: !0,
          premultipliedAlpha: !0
        })
      ) {
        if (Aa.pd()) return !0;
        Da('GL_INCOMPATIBLE');
        return !1;
      }
      Da('GL_INCOMPATIBLE');
      return !1;
    }
    function qb(a) {
      return a.detected <= I.mb;
    }
    function Pb(a) {
      return a.detected > I.mb;
    }
    function Fb(a, c, d, e) {
      return d > a
        ? Math.max(0, a + c / 2 - (d - e / 2))
        : Math.max(0, d + e / 2 - (a - c / 2));
    }
    function Ub() {
      return Ua.some(function (a, c) {
        if (c === E.Z) return !1;
        c = Ua[E.Z];
        if (c.La > a.La || 3 > a.La || Fb(c.x, c.T, a.x, a.T) < I.cc * c.T) return !1;
        var d = V.M / V.O;
        return Fb(c.y, c.T * d, a.y, a.T * d) > I.cc * c.T * d;
      });
    }
    function Vb() {
      var a = E.Z;
      U.Qa.Nd(1);
      1 !== E.i &&
        (b.viewport(0, 0, 3, E.i),
        t.set('s0'),
        t.qc('u1', 1),
        Q.g(!1, !1),
        t.qc('u1', 0));
      b.viewport(0, a, 1, 1);
      t.set('s50');
      H.ga && t.B('u37', ma[a].rz);
      1 !== E.i && t.B('u36', E.ob);
      if (1 < E.i) {
        var c = Ub() ? 0 : 1;
        t.B('u44', c);
      }
      t.Pd('u39', Xa, Ya, vb);
      Q.g(!1, !1);
      E.Zb &&
        (b.viewport(1, a, 1, 1),
        t.set('s51'),
        Q.g(!1, !1),
        b.viewport(2, a, 1, 1),
        t.set('s52'),
        Q.g(!1, !1));
      Oa += bb;
      Oa > Za &&
        ((Ma += $a), (Oa = Pa), Ma > lb && ((Ma = jb), (Na += ab), Na > mb && (Na = kb)));
      Xa = Ma + 0.5 * (Math.random() - 0.5) * $a;
      Ya = Na + 0.5 * (Math.random() - 0.5) * ab;
      vb = Oa + 0.5 * (Math.random() - 0.5) * bb;
    }
    function Gb() {
      u.aa && u.aa.remove();
      u.aa = R.instance({ D: u.element, isPot: !1, isFloat: !1, isFlipY: !0 });
    }
    function Ga() {
      t.K('s48', [
        { type: '1i', name: 'u1', value: 0 },
        { type: 'mat2', name: 'u33', value: u.m }
      ]);
    }
    function Ha() {
      u.C[0] = 0.5;
      u.C[1] = 0.5;
      var a = u.v[1] / u.v[0],
        c = Aa.N() / Aa.A();
      90 === Math.abs(ha.rotate) && (a = 1 / a);
      a > c ? (u.C[1] *= c / a) : (u.C[0] *= a / c);
      t.K('s50', [{ name: 'u45', type: '1f', value: c }]);
      u.m[0] = 0;
      u.m[1] = 0;
      u.m[2] = 0;
      u.m[3] = 0;
      switch (ha.rotate) {
        case 0:
          u.m[0] = u.C[0];
          u.m[3] = u.C[1];
          break;
        case 180:
          u.m[0] = -u.C[0];
          u.m[3] = -u.C[1];
          break;
        case 90:
          u.m[1] = u.C[0];
          u.m[2] = -u.C[1];
          break;
        case -90:
          (u.m[1] = -u.C[0]), (u.m[2] = u.C[1]);
      }
      ha.flipX && ((u.m[0] *= -1), (u.m[2] *= -1));
    }
    function wb() {
      var a = u.element.videoWidth,
        c = u.element.videoHeight,
        d = u.v[0] !== a || u.v[1] !== c;
      d && ((u.v[0] = a), (u.v[1] = c));
      return d;
    }
    function eb(a, c) {
      if (ea === ba.error) return !1;
      u.element = a;
      wb();
      c && c();
      return !0;
    }
    function Hb(a, c, d) {
      a && a();
      u.qa = {
        video: {
          facingMode: { ideal: ha.facingMode },
          width: { min: ha.minWidth, max: ha.maxWidth, ideal: ha.idealWidth },
          height: { min: ha.minHeight, max: ha.maxHeight, ideal: ha.idealHeight }
        },
        audio: !1
      };
      ha.deviceId && (u.qa.deviceId = ha.deviceId);
      S.get(
        u.element ? u.element : S.md(),
        function (e) {
          c && c(e);
          d(e);
        },
        function () {
          Da('WEBCAM_UNAVAILABLE');
        },
        u.qa
      );
    }
    function Da(a) {
      ea !== ba.error && ((ea = ba.error), H.pa && H.pa(a));
    }
    function Ra(a, c) {
      for (var d in a) 'undefined' !== typeof c[d] && (a[d] = c[d]);
      c === X &&
        X.nDetectsPerLoop &&
        ((P.G = X.nDetectsPerLoop), (P.ec = X.nDetectsPerLoop));
    }
    var pa = {
        Se: function (a) {
          return Math.ceil(Math.log2(a));
        },
        vd: function (a) {
          return Math.log2(a);
        },
        ef: function (a) {
          a = Math.log2(a);
          return a === Math.floor(a);
        },
        ge: function (a) {
          var c = [0, 0, 0, 0];
          a.forEach(function (d) {
            c[0] += d[0];
            c[1] += d[1];
            c[2] += d[2];
            c[3] += d[3];
          });
          return c;
        },
        he: function (a, c, d) {
          return Math.min(Math.max(a, c), d);
        },
        le: function (a) {
          return (a * Math.PI) / 180;
        },
        lf: function (a, c) {
          c = Math.pow(10, c);
          return Math.round(a * c) / c;
        },
        mf: function (a) {
          return Math.round(1e6 * a) / 1e6;
        },
        Te: function (a, c) {
          return ((100 * a) / c).toFixed(3);
        },
        P: function (a, c, d) {
          return a * (1 - d) + c * d;
        },
        Yc: function (a, c) {
          return pa.Pc(a - c);
        },
        Pc: function (a) {
          for (; a > Math.PI; ) a -= 2 * Math.PI;
          for (; a <= -Math.PI; ) a += 2 * Math.PI;
          return a;
        },
        oe: function (a, c) {
          return Math.abs(pa.Yc(a, c));
        },
        Zd: function (a, c) {
          return Math.atan2(Math.sin(a) + Math.sin(c), Math.cos(a) + Math.cos(c));
        }
      },
      Eb = {
        get: function (a, c, d) {
          var e = new XMLHttpRequest();
          e.open('GET', a, !0);
          e.withCredentials = !1;
          e.onreadystatechange = function () {
            4 === e.readyState &&
              (200 === e.status || 0 === e.status
                ? c(e.responseText)
                : 'undefined' !== typeof d && d(e.status));
          };
          e.send();
        },
        Oe: function (a, c) {
          Eb.get(a, function (d) {
            c(JSON.parse(d));
          });
        },
        jf: function (a, c, d) {
          var e = new XMLHttpRequest();
          e.open('POST', a, !0);
          e.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
          e.onreadystatechange = function () {
            4 !== e.readyState ||
              (200 !== e.status && 0 !== e.status) ||
              d(e.responseText);
          };
          e.send(c);
        },
        Fe: function (a, c) {
          var d = new XMLHttpRequest();
          d.open('POST', a, !0);
          d.responseType = 'arraybuffer';
          d.onload = function () {
            c(d.response);
          };
          d.send();
        }
      },
      db = {
        zf: function (a, c, d) {
          a = Math.min(Math.max((d - a) / (c - a), 0), 1);
          return a * a * (3 - 2 * a);
        },
        Ia: function (a, c, d) {
          return Math.min(Math.max((d - a) / (c - a), 0), 1);
        },
        ze: function (a, c, d, e) {
          return Math.pow(Math.min(Math.max((e - a) / (c - a), 0), 1), d);
        },
        Ef: function () {
          return 0;
        },
        hf: function () {
          return 1;
        },
        gf: function (a) {
          return a;
        },
        we: function (a) {
          return a * a;
        },
        Be: function (a) {
          return a * (2 - a);
        },
        te: function (a) {
          return 0.5 > a ? 2 * a * a : -1 + (4 - 2 * a) * a;
        },
        re: function (a) {
          return a * a * a;
        },
        Ae: function (a) {
          return --a * a * a + 1;
        },
        se: function (a) {
          return 0.5 > a ? 4 * a * a * a : (a - 1) * (2 * a - 2) * (2 * a - 2) + 1;
        },
        xe: function (a) {
          return a * a * a * a;
        },
        Ce: function (a) {
          return 1 - --a * a * a * a;
        },
        ue: function (a) {
          return 0.5 > a ? 8 * a * a * a * a : 1 - 8 * --a * a * a * a;
        },
        ye: function (a) {
          return a * a * a * a * a;
        },
        De: function (a) {
          return 1 + --a * a * a * a * a;
        },
        ve: function (a) {
          return 0.5 > a ? 16 * a * a * a * a * a : 1 + 16 * --a * a * a * a * a;
        }
      },
      Wb = {
        fd: function (a, c, d) {
          switch (a) {
            case 'relu':
              return d + '=max(vec4(0.,0.,0.,0.),' + c + ');';
            case 'elu':
              return (
                d +
                '=mix(exp(-abs(' +
                c +
                '))-vec4(1.,1.,1.,1.),' +
                c +
                ',step(0.,' +
                c +
                '));'
              );
            case 'elu01':
              return (
                d +
                '=mix(0.1*exp(-abs(' +
                c +
                '))-vec4(0.1,0.1,0.1,0.1),' +
                c +
                ',step(0.,' +
                c +
                '));'
              );
            case 'arctan':
              return d + '=atan(3.14159265359*texture2D(u0,vUV))/3.14159265359;';
            case 'copy':
              return '';
            default:
              return !1;
          }
        }
      },
      t = (function () {
        function a(g, w) {
          g = b.createShader(g);
          b.shaderSource(g, w);
          b.compileShader(g);
          return b.getShaderParameter(g, b.COMPILE_STATUS) ? g : !1;
        }
        function c(g, w) {
          g = a(b.VERTEX_SHADER, g);
          w = a(b.FRAGMENT_SHADER, w);
          f.push(g, w);
          var A = b.createProgram();
          b.attachShader(A, g);
          b.attachShader(A, w);
          b.linkProgram(A);
          return A;
        }
        function d(g) {
          void 0 === g.da &&
            (g.da =
              'precision lowp float;attribute vec2 a0;varying vec2 vv0;void main(){gl_Position=vec4(a0,0.,1.),vv0=a0*.5+vec2(.5,.5);}');
          void 0 === g.Ba && (g.Ba = ['a0']);
          void 0 === g.ma && (g.ma = [2]);
          if (void 0 === g.precision || 'highp' === g.precision) g.precision = y;
          g.id = n++;
          void 0 !== g.Id &&
            g.Id.forEach(function (A, Y) {
              g.a = g.a.replace(A, g.Pa[Y]);
            });
          g.wb = 0;
          g.ma.forEach(function (A) {
            g.wb += 4 * A;
          });
          g.ua = c(g.da, 'precision ' + g.precision + ' float;\n' + g.a);
          g.j = {};
          g.c.forEach(function (A) {
            g.j[A] = b.getUniformLocation(g.ua, A);
          });
          g.attributes = {};
          g.na = [];
          g.Ba.forEach(function (A) {
            var Y = b.getAttribLocation(g.ua, A);
            g.attributes[A] = Y;
            g.na.push(Y);
          });
          if (g.f) {
            b.useProgram(g.ua);
            l = g;
            k = g.id;
            for (var w in g.f) b.uniform1i(g.j[w], g.f[w]);
          }
          g.hb = !0;
        }
        function e(g) {
          Ia.Od(G);
          k !== g.id &&
            (G.ka(),
            (k = g.id),
            (l = g),
            b.useProgram(g.ua),
            g.na.forEach(function (w) {
              0 !== w && b.enableVertexAttribArray(w);
            }));
        }
        var f = [],
          k = -1,
          l = null,
          n = 0,
          p = !1,
          y = 'highp',
          m = ['u1'],
          r = ['u0'],
          x = { u1: 0 },
          z = { u0: 0 },
          T = { u1: 0, u2: 1 },
          M = { u3: 0 },
          F = {
            s0: {
              a:
                'uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}',
              c: m,
              f: x
            },
            s1: {
              a:
                'uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}',
              c: m,
              f: x,
              precision: 'lowp'
            },
            s2: {
              a:
                'uniform sampler2D u1,u2;varying vec2 vv0;void main(){vec4 a=texture2D(u2,vv0),b=texture2D(u1,vv0);gl_FragColor=a*b;}',
              c: ['u1', 'u2'],
              f: T
            },
            s3: {
              a:
                'uniform sampler2D u1;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=a.r*f;}',
              c: m,
              f: x
            },
            s4: {
              a:
                'uniform sampler2D u1,u2;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u2,vv0),b=texture2D(u1,vv0);gl_FragColor=a.a*b.r*f;}',
              c: ['u1', 'mask'],
              f: T
            },
            s5: {
              a:
                'uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vec2(1.-vv0.x,vv0.y));}',
              c: m,
              f: x
            },
            s6: {
              a:
                'uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vec2(vv0.x,1.-vv0.y));}',
              c: m,
              f: x
            },
            s7: {
              a:
                'uniform sampler2D u0;uniform float u4;varying vec2 vv0;void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=a*u4;}',
              c: ['u0', 'u4'],
              f: z
            },
            s8: {
              a:
                'uniform sampler2D u0;uniform float u4;varying vec2 vv0;const vec4 g=vec4(.25,.25,.25,.25),e=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0);float b=dot(a*u4,g);gl_FragColor=b*e;}',
              c: ['u0', 'u4'],
              f: z
            },
            s9: {
              a:
                'uniform sampler2D u1;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.);void main(){float a=.25*dot(e,texture2D(u1,vv0));gl_FragColor=a*e;}',
              c: m,
              f: x
            },
            s10: {
              a:
                'uniform sampler2D u1,u5;uniform float u6;const vec4 f=vec4(1.,1.,1.,1.);varying vec2 vv0;void main(){vec4 a=texture2D(u1,vv0),b=texture2D(u5,vv0);gl_FragColor=mix(b,a,u6*f);}',
              c: ['u1', 'u5', 'u6'],
              f: { u1: 0, u5: 1 }
            },
            s11: {
              a:
                'uniform sampler2D u1;uniform vec2 u7;varying vec2 vv0;void main(){gl_FragColor=.25*(texture2D(u1,vv0+u7)+texture2D(u1,vv0+u7*vec2(1.,-1.))+texture2D(u1,vv0+u7*vec2(-1.,-1.))+texture2D(u1,vv0+u7*vec2(-1.,1.)));}',
              c: ['u1', 'u7'],
              f: x
            },
            s12: {
              a:
                'uniform sampler2D u1;uniform vec4 u8;varying vec2 vv0;float g(float a,float b){a=floor(a)+.5;return floor(a/exp2(b));}float h(float a,float b){return floor(a*exp2(b)+.5);}float i(float a,float b){return mod(a,h(1.,b));}float e(float c,float a,float b){a=floor(a+.5),b=floor(b+.5);return i(g(c,a),b-a);}vec4 k(float a){if(a==0.)return vec4(0.,0.,0.,0.);float l=128.*step(a,0.);a=abs(a);float c=floor(log2(a)),m=c+127.,b=(a/exp2(c)-1.)*8388608.,d=m/2.,n=fract(d)*2.,o=floor(d),p=e(b,0.,8.),q=e(b,8.,16.),r=n*128.+e(b,16.,23.),j=l+o;return vec4(p,q,r,j)/255.;}void main(){float a=dot(texture2D(u1,vv0),u8);gl_FragColor=k(a);}',
              c: ['u1', 'u8'],
              f: x
            },
            s13: {
              a:
                'uniform sampler2D u0;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=e/(e+exp(-a));gl_FragColor=b;}',
              c: r,
              f: z
            },
            s14: {
              a:
                'uniform sampler2D u0;varying vec2 vv0;const vec4 e=vec4(0.,0.,0.,0.);void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=max(e,a);}',
              c: r,
              f: z
            },
            s15: {
              a:
                'uniform sampler2D u0;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0);gl_FragColor=mix(exp(-abs(a))-e,a,step(0.,a));}',
              c: r,
              f: z
            },
            s16: {
              a:
                'uniform sampler2D u0;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=exp(-abs(a))-e;gl_FragColor=mix(.1*b,a,step(0.,a));}',
              c: r,
              f: z
            },
            s17: {
              a:
                'uniform sampler2D u0,u6,u9;varying vec2 vv0;const vec4 f=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),c=texture2D(u6,vv0),d=texture2D(u9,vv0),b=a/d;gl_FragColor=c*mix(exp(-abs(b))-f,b,step(0.,a));}',
              c: ['u0', 'u6', 'u9'],
              f: { u0: 0, u6: 1, u9: 2 }
            },
            s18: {
              a:
                'uniform sampler2D u0;const float e=3.141593;varying vec2 vv0;void main(){gl_FragColor=atan(e*texture2D(u0,vv0))/e;}',
              c: r,
              f: z
            },
            s19: {
              a:
                'uniform sampler2D u0;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.);void main(){vec4 a=texture2D(u0,vv0),b=log(e+a);gl_FragColor=b;}',
              c: r,
              f: z
            },
            s20: {
              a:
                'uniform sampler2D u0,u10;uniform float u11;const vec2 f=vec2(.5,.5);const float g=1e-5;const vec4 h=vec4(1.,1.,1.,1.),i=vec4(0.,0.,0.,0.);varying vec2 vv0;void main(){vec4 a=texture2D(u10,f);float b=u11*u11;vec4 c=max(b*a,g*h);gl_FragColor=texture2D(u0,vv0)/c;}',
              c: ['u0', 'u12', 'u11'],
              f: { u0: 0, u12: 1 }
            },
            s21: {
              a:
                'uniform sampler2D u1;uniform vec2 u13;varying vec2 vv0;void main(){float a=u13.x*u13.y;vec2 b=floor(vv0*a)/a,c=fract(vv0*a),d=floor(b*u13.y),g=floor(u13.x*fract(b*u13.y)),f=(g*u13.y+d)/a;gl_FragColor=texture2D(u1,f+c/a);}',
              c: ['u1', 'u13'],
              f: x
            },
            s22: {
              a:
                'uniform sampler2D u14,u15,u16;varying vec2 vv0;void main(){vec4 a=texture2D(u16,vv0);vec2 b=a.rg,c=a.ba;vec4 d=texture2D(u14,b),e=texture2D(u15,c);gl_FragColor=d*e;}',
              c: ['u14', 'u15', 'u16'],
              f: { u15: 0, u14: 1, u16: 2 }
            },
            s23: {
              a:
                'uniform float u17;uniform sampler2D u14,u15;varying vec2 vv0;void main(){vec2 a=fract(vv0*u17);vec4 b=texture2D(u14,vv0),c=texture2D(u15,a);gl_FragColor=b*c;}',
              c: ['u15', 'u14', 'u17'],
              f: { u15: 0, u14: 1 }
            },
            s24: {
              a:
                'uniform float u17;uniform sampler2D u14,u15,u18,u19,u20,u21;varying vec2 vv0;const vec4 e=vec4(1.,1.,1.,1.),g=vec4(1e-3,1e-3,1e-3,1e-3);void main(){vec2 i=vv0*u17,m=floor(i),c=i-m;vec4 n=texture2D(u14,vv0),d=texture2D(u15,c),a=texture2D(u21,vv0);a=a*255.;vec4 o=texture2D(u18,c),p=texture2D(u19,c),q=texture2D(u20,c),j=step(-g,-a),b=e-j,k=b*step(-e-g,-a);b*=e-k;vec4 h=b*step(-2.*e-g,-a);b*=e-h;vec4 l=b;d=j*d+k*o+h*p+l*q,gl_FragColor=n*d;}',
              c: 'u14 u15 u17 u21 u18 u19 u20'.split(' '),
              f: { u15: 0, u14: 1, u21: 3, u18: 4, u19: 5, u20: 6 }
            },
            s25: {
              a:
                'uniform sampler2D u14,u15,u22;uniform float u17,u23,u24,u25;varying vec2 vv0;const vec2 j=vec2(1.,1.);void main(){vec2 a=floor(u23*vv0),g=u23*vv0-a;float b=u17/u23;vec2 c=floor(g*b),d=g*b-c,h=(a+d)/u23;float l=u23*u25/u17;vec2 m=l*c,i=(m+d*u24)/u25,e=step(i,j);vec4 n=texture2D(u14,h),o=texture2D(u15,i),p=n*o*e.x*e.y,k=texture2D(u22,h);gl_FragColor=p*u24*u24+k;}',
              c: 'u14 u15 u17 u23 u24 u25 u22'.split(' '),
              f: { u15: 0, u14: 1, u22: 2 }
            },
            s26: {
              a:
                'uniform sampler2D u14,u15;varying vec2 vv0;void main(){vec4 a=texture2D(u14,vv0),b=texture2D(u15,vv0);gl_FragColor=a*b;}',
              c: ['u14', 'u15'],
              f: { u15: 0, u14: 1 }
            },
            s27: {
              a:
                'uniform sampler2D u1,u22;uniform float u26;varying vec2 vv0;void main(){gl_FragColor=texture2D(u22,vv0)+u26*texture2D(u1,vv0);}',
              c: ['u1', 'u22', 'u26'],
              f: { u1: 0, u22: 1 }
            },
            s28: {
              a:
                'varying vec2 vv0;uniform sampler2D u1;const vec4 g=vec4(1.,1.,1.,1.),e=vec4(.299,.587,.114,0.);void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=dot(a,e)*g;}',
              c: m,
              f: x,
              precision: 'lowp'
            },
            s29: {
              a:
                'varying vec2 vv0;uniform sampler2D u1;uniform float u27;const vec3 e=vec3(.299,.587,.114);void main(){vec3 a=texture2D(u1,vv0).rgb,b=texture2D(u1,vv0+vec2(0.,u27)).rgb,c=texture2D(u1,vv0+vec2(u27,u27)).rgb,d=texture2D(u1,vv0+vec2(u27,0.)).rgb;gl_FragColor=vec4(dot(a,e),dot(b,e),dot(c,e),dot(d,e));}',
              c: ['u1', 'u27'],
              f: x,
              precision: 'lowp'
            },
            s30: {
              a:
                'varying vec2 vv0;uniform sampler2D u1;uniform float u27;const vec3 f=vec3(.299,.587,.114);void main(){vec3 a=texture2D(u1,vv0).rgb,b=texture2D(u1,vv0+vec2(0.,u27)).rgb,c=texture2D(u1,vv0+vec2(u27,u27)).rgb,d=texture2D(u1,vv0+vec2(u27,0.)).rgb;gl_FragColor=vec4(a.r,b.g,c.b,dot(d,f));}',
              c: ['u1', 'u27'],
              f: x,
              precision: 'lowp'
            },
            s31: {
              a:
                'varying vec2 vv0;uniform sampler2D u1,u2;uniform float u28;const vec4 g=vec4(1.,1.,1.,1.);void main(){vec4 a=vec4(0.);a-=texture2D(u1,vec2(vv0.x-u28,vv0.y-u28))*1.,a-=texture2D(u1,vec2(vv0.x-u28,vv0.y))*2.,a-=texture2D(u1,vec2(vv0.x-u28,vv0.y+u28))*1.,a+=texture2D(u1,vec2(vv0.x+u28,vv0.y-u28))*1.,a+=texture2D(u1,vec2(vv0.x+u28,vv0.y))*2.,a+=texture2D(u1,vec2(vv0.x+u28,vv0.y+u28))*1.;vec4 b=vec4(0.);b-=texture2D(u1,vec2(vv0.x-u28,vv0.y-u28))*1.,b-=texture2D(u1,vec2(vv0.x,vv0.y-u28))*2.,b-=texture2D(u1,vec2(vv0.x+u28,vv0.y-u28))*1.,b+=texture2D(u1,vec2(vv0.x-u28,vv0.y+u28))*1.,b+=texture2D(u1,vec2(vv0.x,vv0.y+u28))*2.,b+=texture2D(u1,vec2(vv0.x+u28,vv0.y+u28))*1.;vec3 c=sqrt(a.rgb*a.rgb+b.rgb*b.rgb);vec4 e=vec4(c,texture2D(u1,vv0).a),f=texture2D(u2,vv0);gl_FragColor=f.a*e.r*g;}',
              c: ['u1', 'u2', 'u28'],
              f: T
            },
            s32: {
              a:
                'varying vec2 vv0;uniform sampler2D u1,u2;uniform float u28;const vec4 j=vec4(1.,1.,1.,1.);const vec2 k=vec2(1.,1.);void main(){float i=0.;vec2 l=k*u28,a,b;float c,d,g=0.;for(float f=-4.;f<=4.;f+=1.)for(float e=-4.;e<=4.;e+=1.)a=vec2(f,e),c=length(a)/2.,d=exp(-c*c),b=vv0+l*a,i+=d*texture2D(u1,b).r,g+=d;vec4 m=texture2D(u2,vv0);gl_FragColor=m.a*(texture2D(u1,b).r-i/g)*j;}',
              c: ['u1', 'u2', 'u28'],
              f: T
            },
            s33: {
              a:
                'uniform sampler2D u3;uniform vec2 u7;varying vec2 vv0;vec4 e(vec4 a,vec4 b){vec4 c=step(a,b);return mix(a,b,c);}const vec2 h=vec2(.5,.5),i=vec2(1.,0.),j=vec2(0.,1.);void main(){vec2 a=vv0-u7*h;vec4 b=texture2D(u3,a),c=texture2D(u3,a+u7*i),d=texture2D(u3,a+u7*j),k=texture2D(u3,a+u7),l=e(b,c),g=e(d,k);gl_FragColor=e(l,g);}',
              c: ['u3', 'u7'],
              f: M
            },
            s34: {
              a:
                'uniform sampler2D u3;uniform vec2 u7;varying vec2 vv0;const vec2 j=vec2(1.,0.),k=vec2(0.,1.),l=vec2(2.,0.),m=vec2(0.,2.);vec4 e(vec4 a,vec4 b){vec4 c=step(a,b);return mix(a,b,c);}vec4 f(vec2 a){vec4 b=texture2D(u3,a),c=texture2D(u3,a+u7*j),d=texture2D(u3,a+u7*k),g=texture2D(u3,a+u7),i=e(b,c),h=e(d,g);return e(i,h);}void main(){vec2 a=vv0+u7*vec2(-.55,-1.05);vec4 b=f(a),c=f(a+u7*l),d=f(a+u7*2.),g=f(a+u7*m),i=e(b,c),h=e(d,g);gl_FragColor=e(i,h);}',
              c: ['u3', 'u7'],
              f: M
            },
            s35: {
              a:
                'uniform sampler2D u1;varying vec2 vv0;void main(){vec4 a=texture2D(u1,vv0);gl_FragColor=a*a;}',
              c: ['u1'],
              f: x,
              precision: 'lowp'
            },
            s36: {
              a:
                'uniform sampler2D u1;uniform vec2 u7;varying vec2 vv0;const float d=15444.;void main(){vec4 a=1001./d*texture2D(u1,vv0-3.*u7)+2002./d*texture2D(u1,vv0-2.*u7)+3003./d*texture2D(u1,vv0-u7)+3432./d*texture2D(u1,vv0)+3003./d*texture2D(u1,vv0+u7)+2002./d*texture2D(u1,vv0+2.*u7)+1001./d*texture2D(u1,vv0+3.*u7);gl_FragColor=a;}',
              c: ['u7', 'u1'],
              f: x,
              precision: 'lowp'
            },
            s37: {
              a:
                'uniform sampler2D u1,u29,u30;varying vec2 vv0;const vec4 g=vec4(1.,1.,1.,1.);const float h=.1;void main(){vec4 a=texture2D(u29,vv0),b=texture2D(u30,vv0),c=texture2D(u1,vv0),d=max(g*h,b-a*a),f=sqrt(d);gl_FragColor=(c-a)/f;}',
              c: ['u1', 'u29', 'u30'],
              f: { u1: 0, u29: 1, u30: 2 }
            }
          },
          D = {
            s38: {
              a:
                'uniform float u17,u31;uniform sampler2D u14,u15,u22;varying vec2 vv0;const vec2 ZERO2=vec2(0.,0.),ONE2=vec2(1.,1.),HALF2=vec2(.5,.5),EPS2=vec2(1e-5,1e-5);void main(){vec4 sum=texture2D(u22,vv0);float toSparsity=1.1111;vec2 uvFrom,uvWeight,xyPatch=ZERO2,eps2=EPS2/u17,xyTo=floor(vv0*u17+eps2);float weightSize=toSparsity*u17;vec2 halfFromSparsity=ONE2*(toSparsity-1.)/2.;for(float patch_x=0.;patch_x<1.1111;patch_x+=1.){xyPatch.x=patch_x;for(float patch_y=0.;patch_y<1.1111;patch_y+=1.)xyPatch.y=patch_y,uvFrom=(xyTo+HALF2+u31*(xyPatch-halfFromSparsity))/u17,uvFrom+=step(uvFrom,-eps2),uvFrom-=step(ONE2-eps2,uvFrom),uvWeight=(xyTo*toSparsity+xyPatch+HALF2)/weightSize,sum+=texture2D(u14,uvWeight)*texture2D(u15,uvFrom);}gl_FragColor=sum,gl_FragColor*=2.2222;}',
              c: ['u17', 'u14', 'u15', 'u22', 'u31'],
              Pa: ['1.1111', 'gl_FragColor\\*=2.2222;']
            },
            s39: {
              a:
                'uniform float u17,u31,u25;uniform sampler2D u14,u15,u22;varying vec2 vv0;const vec2 ZERO2=vec2(0.,0.),ONE2=vec2(1.,1.),HALF2=vec2(.5,.5),EPS2=vec2(1e-4,1e-4);void main(){vec4 sum=texture2D(u22,vv0);float fromSparsity=1.1111,shrinkFactor=3.3333;vec2 uvFrom,uvWeight,xyFrom,xyPatchTo,xyPatch=ZERO2,xyShrink=ZERO2,eps2=EPS2/u25,xyTo=floor(vv0*u17+eps2);float weightSize=fromSparsity*u25;vec2 halfFromSparsity=ONE2*(fromSparsity-1.)/2.;float toSparsity=weightSize/u17;vec2 xyFrom0=xyTo*shrinkFactor;for(float patch_x=0.;patch_x<1.1111;patch_x+=1.){xyPatch.x=patch_x;for(float patch_y=0.;patch_y<1.1111;patch_y+=1.){xyPatch.y=patch_y;for(float shrink_x=0.;shrink_x<3.3333;shrink_x+=1.){xyShrink.x=shrink_x;for(float shrink_y=0.;shrink_y<3.3333;shrink_y+=1.)xyShrink.y=shrink_y,xyFrom=xyFrom0+xyShrink+shrinkFactor*u31*(xyPatch-halfFromSparsity),uvFrom=(xyFrom+HALF2)/u25,uvFrom+=step(uvFrom,-eps2),uvFrom-=step(ONE2-eps2,uvFrom),xyPatchTo=xyPatch*shrinkFactor+xyShrink,uvWeight=(xyTo*toSparsity+xyPatchTo+HALF2)/weightSize,sum+=texture2D(u14,uvWeight)*texture2D(u15,uvFrom);}}}gl_FragColor=sum,gl_FragColor*=2.2222;}',
              c: 'u17 u25 u14 u15 u22 u31'.split(' '),
              Pa: ['1.1111', 'gl_FragColor\\*=2.2222;', '3.3333']
            }
          },
          G = {
            kb: function () {
              return p;
            },
            o: function () {
              if (!p) {
                y = 'highp';
                for (var g in F) d(F[g], g);
                t.set('s0');
                b.enableVertexAttribArray(0);
                g = Va.o();
                p = !0;
                return g;
              }
            },
            zc: function (g) {
              g.forEach(function (w) {
                G.zb(w);
              });
            },
            zb: function (g) {
              F[g.id] = g;
              d(g, g.id);
            },
            Vb: function (g, w, A) {
              w || (w = g);
              F[w] = Object.create(D[g]);
              F[w].rd = !0;
              D[g].Pa &&
                D[g].Pa.forEach(function (Y, na) {
                  F[w].a = F[w].a.replace(new RegExp(Y, 'g'), A[na]);
                });
              d(F[w], w);
            },
            set: function (g) {
              e(F[g]);
            },
            bd: function (g) {
              return 'undefined' === typeof F[g] ? !1 : F[g].hb;
            },
            ka: function () {
              -1 !== k &&
                ((k = -1),
                l.na.forEach(function (g) {
                  0 !== g && b.disableVertexAttribArray(g);
                }));
            },
            ub: function () {
              var g = 0;
              l.na.forEach(function (w, A) {
                A = l.ma[A];
                b.vertexAttribPointer(w, A, b.FLOAT, !1, l.wb, g);
                g += 4 * A;
              });
            },
            Kb: function () {
              b.enableVertexAttribArray(0);
            },
            xa: function () {
              b.vertexAttribPointer(l.na[0], 2, b.FLOAT, !1, 8, 0);
            },
            qc: function (g, w) {
              b.uniform1i(l.j[g], w);
            },
            B: function (g, w) {
              b.uniform1f(l.j[g], w);
            },
            wa: function (g, w, A) {
              b.uniform2f(l.j[g], w, A);
            },
            tf: function (g, w) {
              b.uniform2fv(l.j[g], w);
            },
            uf: function (g, w) {
              b.uniform3fv(l.j[g], w);
            },
            Pd: function (g, w, A, Y) {
              b.uniform3f(l.j[g], w, A, Y);
            },
            vf: function (g, w, A, Y, na) {
              b.uniform4f(l.j[g], w, A, Y, na);
            },
            tb: function (g, w) {
              b.uniform4fv(l.j[g], w);
            },
            wf: function (g, w) {
              b.uniformMatrix2fv(l.j[g], !1, w);
            },
            xf: function (g, w) {
              b.uniformMatrix3fv(l.j[g], !1, w);
            },
            yf: function (g, w) {
              b.uniformMatrix4fv(l.j[g], !1, w);
            },
            K: function (g, w) {
              G.set(g);
              w.forEach(function (A) {
                switch (A.type) {
                  case '4f':
                    b.uniform4fv(l.j[A.name], A.value);
                    break;
                  case '3f':
                    b.uniform3fv(l.j[A.name], A.value);
                    break;
                  case '2f':
                    b.uniform2fv(l.j[A.name], A.value);
                    break;
                  case '1f':
                    b.uniform1f(l.j[A.name], A.value);
                    break;
                  case '1i':
                    b.uniform1i(l.j[A.name], A.value);
                    break;
                  case 'mat2':
                    b.uniformMatrix2fv(l.j[A.name], !1, A.value);
                    break;
                  case 'mat3':
                    b.uniformMatrix3fv(l.j[A.name], !1, A.value);
                    break;
                  case 'mat4':
                    b.uniformMatrix4fv(l.j[A.name], !1, A.value);
                }
              });
            },
            Re: function () {
              return 'lowp';
            },
            h: function () {
              b.disableVertexAttribArray(0);
              G.ka();
              for (var g in F) {
                var w = F[g];
                w.hb && ((w.hb = !1), b.deleteProgram(w.ua));
                w.rd && delete F[g];
              }
              f.forEach(function (A) {
                b.deleteShader(A);
              });
              f.splice(0);
              n = 0;
              p = !1;
            }
          };
        return G;
      })(),
      b = null,
      Aa = (function () {
        function a(m) {
          console.log('ERROR in ContextFeedForward: ', m);
          return !1;
        }
        function c() {
          if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) return !0;
          if (/(Mac)/i.test(navigator.platform)) {
            var m;
            (m = navigator.userAgent)
              ? ((m = m.match(/Mac OS X (\d+)_(\d+)/) || m.match(/Mac OS X (\d+).(\d+)/)),
                (m = !m || 3 > m.length ? !1 : [parseInt(m[1], 10), parseInt(m[2], 10)]))
              : (m = !1);
            if (m && 10 === m[0] && 15 === m[1]) return !0;
          }
          return !1;
        }
        var d = null,
          e = null,
          f = null,
          k = null,
          l = !0,
          n = null,
          p = null,
          y = {
            A: function () {
              return d.width;
            },
            N: function () {
              return d.height;
            },
            Ie: function () {
              return d;
            },
            He: function () {
              return b;
            },
            u: function () {
              return l;
            },
            flush: function () {
              b.flush();
            },
            hd: function () {
              n || (n = new Uint8Array(d.width * d.height * 4));
              b.readPixels(0, 0, d.width, d.height, b.RGBA, b.UNSIGNED_BYTE, n);
              return n;
            },
            Ke: function () {
              return d.toDataURL('image/jpeg');
            },
            Le: function () {
              ra.F();
              e || ((e = document.createElement('canvas')), (f = e.getContext('2d')));
              e.width = d.width;
              e.height = d.height;
              for (
                var m = y.hd(),
                  r = f.createImageData(e.width, e.height),
                  x = e.width,
                  z = e.height,
                  T = r.data,
                  M = 0;
                M < z;
                ++M
              )
                for (var F = z - M - 1, D = 0; D < x; ++D) {
                  var G = 4 * (M * x + D),
                    g = 4 * (F * x + D);
                  T[G] = m[g];
                  T[G + 1] = m[g + 1];
                  T[G + 2] = m[g + 2];
                  T[G + 3] = m[g + 3];
                }
              f.putImageData(r, 0, 0);
              return e.toDataURL('image/png');
            },
            Je: function (m) {
              !e &&
                m &&
                ((e = document.createElement('canvas')), (f = e.getContext('2d')));
              var r = m ? e : document.createElement('canvas');
              r.width = d.width;
              r.height = d.height;
              (m ? f : r.getContext('2d')).drawImage(d, 0, 0);
              return r;
            },
            o: function (m) {
              m.Uc && !m.Ua ? (d = document.getElementById(m.Uc)) : m.Ua && (d = m.Ua);
              d || (d = document.createElement('canvas'));
              d.width = m && void 0 !== m.width ? m.width : 512;
              d.height = m && void 0 !== m.height ? m.height : 512;
              'undefined' === typeof m && (m = {});
              void 0 === m.premultipliedAlpha && (m.premultipliedAlpha = !1);
              void 0 === m.Yb && (m.Yb = !0);
              void 0 === m.antialias && (m.antialias = !1);
              if (!b) {
                var r = {
                  antialias: m.antialias,
                  alpha: !0,
                  preserveDrawingBuffer: !0,
                  premultipliedAlpha: m.premultipliedAlpha,
                  stencil: !1,
                  depth: m.Yb
                };
                c() || (b = d.getContext('webgl2', r));
                b
                  ? (l = !0)
                  : ((b = d.getContext('webgl', r)) ||
                      (b = d.getContext('experimental-webgl', r)),
                    (l = !1));
              }
              if (!b) return a('WebGL is not enabled');
              (k = b.getExtension('WEBGL_lose_context')) &&
                m.kc &&
                ((p = m.kc), d.addEventListener('webglcontextlost', p, !1));
              if (!Z.o()) return a('Not enough capabilities');
              if (!Z.Jc() && l)
                return a('Your configuration cannot process color buffer float');
              b.clearColor(0, 0, 0, 0);
              b.disable(b.DEPTH_TEST);
              b.disable(b.BLEND);
              b.disable(b.DITHER);
              b.disable(b.STENCIL_TEST);
              b.disable(b.SCISSOR_TEST);
              b.GENERATE_MIPMAP_HINT && b.hint(b.GENERATE_MIPMAP_HINT, b.FASTEST);
              b.disable(b.SAMPLE_ALPHA_TO_COVERAGE);
              b.disable(b.SAMPLE_COVERAGE);
              return !0;
            },
            pd: function () {
              if (!t.o()) return !1;
              b.depthFunc(b.LEQUAL);
              b.clearDepth(1);
              return !0;
            },
            h: function () {
              b && Z.h();
              k && p && (d.removeEventListener('webglcontextlost', p, !1), (p = null));
              n = f = e = d = null;
            }
          };
        return y;
      })(),
      Ia = (function () {
        var a = 'undefined' === typeof t ? null : t;
        return {
          Od: function (c) {
            a !== c && (a && a.ka(), (a = c));
          },
          kb: function () {
            return a.kb();
          },
          xa: function () {
            a.xa();
          },
          ub: function () {
            a.ub();
          },
          ka: function () {
            a.ka();
          },
          set: function (c) {
            a.set(c);
          },
          h: function () {
            a.h && a.h();
          }
        };
      })(),
      ka = (function () {
        var a = null,
          c = null,
          d = 0,
          e = -2,
          f = -2,
          k = !1,
          l = [],
          n = {
            reset: function () {
              f = e = -2;
            },
            o: function () {
              k ||
                ((a = b.createBuffer()),
                b.bindBuffer(b.ARRAY_BUFFER, a),
                b.bufferData(
                  b.ARRAY_BUFFER,
                  new Float32Array([-1, -1, 3, -1, -1, 3]),
                  b.STATIC_DRAW
                ),
                (c = b.createBuffer()),
                b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, c),
                b.bufferData(
                  b.ELEMENT_ARRAY_BUFFER,
                  new Uint16Array([0, 1, 2]),
                  b.STATIC_DRAW
                ),
                n.oa(),
                (k = !0));
            },
            instance: function (p) {
              var y = d++,
                m = p.$ ? p.$.length : 0,
                r = 'undefined' === typeof p.mode ? b.STATIC_DRAW : p.mode,
                x = b.createBuffer();
              b.bindBuffer(b.ARRAY_BUFFER, x);
              b.bufferData(
                b.ARRAY_BUFFER,
                p.vc instanceof Float32Array ? p.vc : new Float32Array(p.vc),
                r
              );
              e = y;
              var z = null,
                T = null,
                M = null;
              if (p.$) {
                z = b.createBuffer();
                b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, z);
                var F = null;
                65536 > p.$.length
                  ? ((F = Uint16Array), (T = b.UNSIGNED_SHORT), (M = 2))
                  : ((F = Uint32Array), (T = b.UNSIGNED_INT), (M = 4));
                b.bufferData(
                  b.ELEMENT_ARRAY_BUFFER,
                  p.$ instanceof F ? p.$ : new F(p.$),
                  r
                );
                f = y;
              }
              var D = {
                Ic: function (G) {
                  e !== y && (b.bindBuffer(b.ARRAY_BUFFER, x), (e = y));
                  G && Ia.ub();
                },
                Fc: function () {
                  f !== y && (b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, z), (f = y));
                },
                bind: function (G) {
                  D.Ic(G);
                  D.Fc();
                },
                pe: function () {
                  b.drawElements(b.TRIANGLES, m, T, 0);
                },
                qe: function (G, g) {
                  b.drawElements(b.TRIANGLES, G, T, g * M);
                },
                remove: function () {
                  b.deleteBuffer(x);
                  p.$ && b.deleteBuffer(z);
                  D = null;
                }
              };
              l.push(D);
              return D;
            },
            oa: function () {
              -1 !== e && (b.bindBuffer(b.ARRAY_BUFFER, a), (e = -1));
              -1 !== f && (b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, c), (f = -1));
            },
            g: function (p, y) {
              p && ka.oa();
              y && Ia.xa();
              b.drawElements(b.TRIANGLES, 3, b.UNSIGNED_SHORT, 0);
            },
            Pb: function () {
              b.deleteBuffer(a);
              b.deleteBuffer(c);
            },
            h: function () {
              n.Pb();
              l.forEach(function (p) {
                p.remove();
              });
              b.bindBuffer(b.ARRAY_BUFFER, null);
              b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, null);
              n.reset();
              k = !1;
              l.splice(0);
              d = 0;
            }
          };
        return n;
      })(),
      aa = (function () {
        var a = null,
          c = null,
          d = null,
          e = !1,
          f = [],
          k = { w: -2, Nb: 1 },
          l = {
            o: function () {
              if (!e) {
                a = b.createFramebuffer();
                var n = Z.u();
                c = n && b.DRAW_FRAMEBUFFER ? b.DRAW_FRAMEBUFFER : b.FRAMEBUFFER;
                d = n && b.READ_FRAMEBUFFER ? b.READ_FRAMEBUFFER : b.FRAMEBUFFER;
                e = !0;
              }
            },
            Ne: function () {
              return c;
            },
            cb: function () {
              return d;
            },
            ha: function () {
              return b.FRAMEBUFFER;
            },
            Ue: function () {
              return k;
            },
            Ge: function () {
              return a;
            },
            instance: function (n) {
              void 0 === n.Xb && (n.Xb = !1);
              var p = n.aa ? n.aa : null,
                y = n.width,
                m = void 0 !== n.height ? n.height : n.width,
                r = a,
                x = null,
                z = !1,
                T = !1,
                M = 0;
              p && ((y = y ? y : p.A()), (m = m ? m : p.N()));
              var F = {
                pc: function () {
                  z || ((r = b.createFramebuffer()), (z = !0), (M = k.Nb++));
                },
                yc: function () {
                  F.pc();
                  F.l();
                  x = b.createRenderbuffer();
                  b.bindRenderbuffer(b.RENDERBUFFER, x);
                  b.renderbufferStorage(b.RENDERBUFFER, b.DEPTH_COMPONENT16, y, m);
                  b.framebufferRenderbuffer(c, b.DEPTH_ATTACHMENT, b.RENDERBUFFER, x);
                  b.clearDepth(1);
                },
                bind: function (D, G) {
                  M !== k.w && (b.bindFramebuffer(c, r), (k.w = M));
                  p && p.l();
                  G && b.viewport(0, 0, y, m);
                  D && b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
                },
                be: function () {
                  M !== k.w && (b.bindFramebuffer(c, r), (k.w = M));
                },
                clear: function () {
                  b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
                },
                ie: function () {
                  b.clear(b.COLOR_BUFFER_BIT);
                },
                je: function () {
                  b.clear(b.DEPTH_BUFFER_BIT);
                },
                Qd: function () {
                  b.viewport(0, 0, y, m);
                },
                l: function () {
                  M !== k.w && (b.bindFramebuffer(c, r), (k.w = M));
                },
                rtt: function (D) {
                  p = D;
                  k.w !== M && (b.bindFramebuffer(b.FRAMEBUFFER, r), (k.w = M));
                  D.l();
                },
                F: function () {
                  b.bindFramebuffer(c, null);
                  k.w = -1;
                },
                resize: function (D, G) {
                  y = D;
                  m = G;
                  x &&
                    (b.bindRenderbuffer(b.RENDERBUFFER, x),
                    b.renderbufferStorage(b.RENDERBUFFER, b.DEPTH_COMPONENT16, y, m));
                },
                remove: function () {
                  r === a ||
                    T ||
                    (b.bindFramebuffer(c, r),
                    b.framebufferTexture2D(c, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, null, 0),
                    x &&
                      b.framebufferRenderbuffer(
                        c,
                        b.DEPTH_ATTACHMENT,
                        b.RENDERBUFFER,
                        null
                      ),
                    b.bindFramebuffer(c, null),
                    b.deleteFramebuffer(r),
                    x && b.deleteRenderbuffer(x));
                  T = !0;
                }
              };
              n.Xb && F.yc();
              f.push(F);
              return F;
            },
            F: function () {
              b.bindFramebuffer(c, null);
              k.w = -1;
            },
            Wd: function () {
              b.bindFramebuffer(c, null);
              b.clear(b.COLOR_BUFFER_BIT | b.DEPTH_BUFFER_BIT);
              b.viewport(0, 0, Z.A(), Z.N());
              k.w = -1;
            },
            reset: function () {
              k.w = -2;
            },
            U: function () {
              0 !== k.w && (b.bindFramebuffer(c, a), (k.w = 0));
            },
            clear: function () {
              b.viewport(0, 0, Z.A(), Z.N());
              b.clear(b.COLOR_BUFFER_BIT);
            },
            h: function () {
              l.F();
              f.forEach(function (n) {
                n.remove();
              });
              b.deleteFramebuffer(a);
              l.reset();
              e = !1;
              f.splice(0);
              k.w = -2;
              k.Nb = 1;
            }
          };
        return l;
      })(),
      Fa = (function () {
        function a(q) {
          b.bindTexture(b.TEXTURE_2D, q);
        }
        function c(q) {
          la[0] = q;
          q = ca[0];
          var C = (q >> 16) & 32768,
            h = (q >> 12) & 2047,
            N = (q >> 23) & 255;
          return 103 > N
            ? C
            : 142 < N
            ? C | 31744 | ((255 == N ? 0 : 1) && q & 8388607)
            : 113 > N
            ? ((h |= 2048), C | ((h >> (114 - N)) + ((h >> (113 - N)) & 1)))
            : (C = (C | ((N - 112) << 10) | (h >> 1)) + (h & 1));
        }
        function d(q) {
          var C = new Uint16Array(q.length);
          q.forEach(function (h, N) {
            C[N] = c(h);
          });
          return C;
        }
        function e() {
          if (null !== oa.fb) return oa.fb;
          var q = k(d([1, 1, 1, 1]));
          return null === q ? !0 : (oa.fb = q);
        }
        function f() {
          if (null !== oa.gb) return oa.gb;
          var q = k(new Uint8Array([255, 255, 255, 255]));
          return null === q ? !0 : (oa.gb = q);
        }
        function k(q) {
          if (!Ia.kb() || !M) return null;
          var C = null;
          try {
            var h = b.getError();
            C = B.instance({ isFloat: !1, H: !0, array: q, width: 1 });
            h = b.getError();
            if (h !== b.NO_ERROR) return !1;
          } catch (N) {
            return !1;
          }
          aa.F();
          b.viewport(0, 0, 1, 1);
          b.clearColor(0, 0, 0, 0);
          b.clear(b.COLOR_BUFFER_BIT);
          Ia.set('s0');
          C.Bb(0);
          ka.g(!1, !0);
          q = new Uint8Array(4);
          b.readPixels(0, 0, 1, 1, b.RGBA, b.UNSIGNED_BYTE, q);
          q = 0.9 < q[0];
          C.remove();
          aa.U();
          return q;
        }
        var l = 0,
          n = null,
          p = 0,
          y = null,
          m = null,
          r = null,
          x = null,
          z = null,
          T = null,
          M = !1,
          F = [],
          D = {
            isFloat: !1,
            isPot: !0,
            isLinear: !1,
            isMipmap: !1,
            isAnisotropicFiltering: !1,
            isMirrorX: !1,
            isMirrorY: !1,
            isSrgb: !1,
            isKeepArray: !1,
            isFlipY: null,
            width: 0,
            height: 0,
            url: null,
            array: null,
            data: null,
            D: null,
            qd: !1,
            H: !1,
            Y: null,
            Ka: 4,
            lb: 0
          },
          G = !1,
          g = null,
          w = null,
          A = [
            [1, 0, 0, 0],
            [0, 1, 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1]
          ],
          Y = !1,
          na = !1,
          la = new Float32Array(1),
          ca = new Int32Array(la.buffer),
          oa = { fb: null, gb: null },
          B = {
            o: function () {
              if (!M) {
                z = [b.RGB, !1, b.RGB, b.RGBA];
                T = [b.RGB, !1, b.RGB, b.RGBA];
                n = [
                  b.TEXTURE0,
                  b.TEXTURE1,
                  b.TEXTURE2,
                  b.TEXTURE3,
                  b.TEXTURE4,
                  b.TEXTURE5,
                  b.TEXTURE6,
                  b.TEXTURE7
                ];
                Y = 'undefined' !== typeof JEContext;
                na = 'undefined' !== typeof Z;
                Y && JEContext.ff() && n.push(b.TEXTURE8, b.TEXTURE9);
                y = [-1, -1, -1, -1, -1, -1, -1, -1];
                x = [b.UNSIGNED_BYTE, b.FLOAT, b.FLOAT];
                if (!m) {
                  for (var q = new Float32Array(16384), C = 0; 16384 > C; ++C)
                    q[C] = 2 * Math.random() - 1;
                  m = {
                    random: B.instance({ isFloat: !0, isPot: !0, array: q, width: 64 }),
                    uc: B.instance({
                      isFloat: !1,
                      isPot: !0,
                      width: 1,
                      array: new Uint8Array([0, 0, 0, 0])
                    })
                  };
                }
                M = !0;
              }
            },
            od: function () {
              B.Xd();
            },
            Ye: function () {
              return m.uc;
            },
            Xd: function () {
              x[1] = Z.Fa();
            },
            Kd: function () {
              T = z = [b.RGBA, b.RGBA, b.RGBA, b.RGBA];
            },
            kf: function (q, C) {
              t.set('s1');
              aa.F();
              var h = q.A(),
                N = q.N();
              b.viewport(0, 0, h, N);
              q.b(0);
              ka.g(!1, !1);
              b.readPixels(0, 0, h, N, b.RGBA, b.UNSIGNED_BYTE, C);
            },
            dd: function (q, C, h) {
              b.activeTexture(b.TEXTURE0);
              l = 0;
              var N = b.createTexture();
              a(N);
              var qa = Z.u() && b.RGBA32F ? b.RGBA32F : b.FLOAT;
              C = C instanceof Float32Array ? C : new Float32Array(C);
              var ua = pa.vd(C.length);
              ua !== Math.floor(ua) &&
                (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE),
                b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE));
              b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);
              b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);
              b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, h);
              b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, q.A(), q.N(), 0, b.RGBA, qa, C);
              a(null);
              b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !1);
              aa.U();
              t.set('s0');
              q.J();
              b.clearColor(0, 0, 0, 0);
              b.clear(b.COLOR_BUFFER_BIT);
              a(N);
              ka.g(!0, !1);
              b.deleteTexture(N);
            },
            instance: function (q) {
              function C() {
                a(ta);
                va && b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, va);
                h.isPot
                  ? (b.texParameteri(
                      b.TEXTURE_2D,
                      b.TEXTURE_WRAP_S,
                      h.isMirrorX ? b.MIRRORED_REPEAT : b.REPEAT
                    ),
                    b.texParameteri(
                      b.TEXTURE_2D,
                      b.TEXTURE_WRAP_T,
                      h.isMirrorY ? b.MIRRORED_REPEAT : b.REPEAT
                    ))
                  : (b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.CLAMP_TO_EDGE),
                    b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.CLAMP_TO_EDGE));
                h.isAnisotropicFiltering &&
                  'undefined' !== typeof JESETTINGS &&
                  b.texParameterf(
                    b.TEXTURE_2D,
                    JEContext.Me().TEXTURE_MAX_ANISOTROPY_EXT,
                    JESETTINGS.$d
                  );
                b.texParameteri(
                  b.TEXTURE_2D,
                  b.TEXTURE_MAG_FILTER,
                  h.isLinear ? b.LINEAR : b.NEAREST
                );
                h.isLinear
                  ? b.texParameteri(
                      b.TEXTURE_2D,
                      b.TEXTURE_MIN_FILTER,
                      h.isMipmap && !Ja ? b.NEAREST_MIPMAP_LINEAR : b.LINEAR
                    )
                  : b.texParameteri(
                      b.TEXTURE_2D,
                      b.TEXTURE_MIN_FILTER,
                      h.isMipmap && !Ja ? b.NEAREST_MIPMAP_NEAREST : b.NEAREST
                    );
                fa = z[h.Ka - 1];
                ia = T[h.Ka - 1];
                ja = x[qa];
                if (Z.u()) {
                  var v = b.RGBA32F;
                  fa === b.RGBA && ja === b.FLOAT && v && (ia = v);
                  fa === b.RGB && ja === b.FLOAT && v && ((ia = v), (fa = b.RGBA));
                }
                if ((h.H && !h.isFloat) || (h.isFloat && h.isMipmap && Va.ud()))
                  (v = b.RGBA16F) && (ia = v), (ja = Z.Fa());
                h.lb && (fb = h.lb);
                h.isSrgb && 4 === h.Ka && (fa = JEContext.We());
                if (h.D) b.texImage2D(b.TEXTURE_2D, 0, ia, fa, ja, h.D);
                else if (h.url) b.texImage2D(b.TEXTURE_2D, 0, ia, fa, ja, Ea);
                else if (wa) {
                  try {
                    b.getError(),
                      b.texImage2D(b.TEXTURE_2D, 0, ia, J, K, 0, fa, ja, wa),
                      b.getError() !== b.NO_ERROR &&
                        (b.texImage2D(b.TEXTURE_2D, 0, ia, J, K, 0, fa, ja, null),
                        b.getError() !== b.NO_ERROR &&
                          b.texImage2D(
                            b.TEXTURE_2D,
                            0,
                            b.RGBA,
                            J,
                            K,
                            0,
                            b.RGBA,
                            b.UNSIGNED_BYTE,
                            null
                          ));
                  } catch (gc) {
                    b.texImage2D(b.TEXTURE_2D, 0, ia, J, K, 0, fa, ja, null);
                  }
                  h.isKeepArray || (wa = null);
                } else b.texImage2D(b.TEXTURE_2D, 0, ia, J, K, 0, fa, ja, null);
                if (h.isMipmap)
                  if (!Ja && W) W.bb(), (gb = !0);
                  else if (Ja) {
                    v = Math.log(Math.min(J, K)) / Math.log(2);
                    Sa = Array(1 + v);
                    Sa[0] = ta;
                    for (var L = 1; L <= v; ++L) {
                      var da = Math.pow(2, L),
                        O = J / da;
                      da = K / da;
                      var Ka = b.createTexture();
                      a(Ka);
                      b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);
                      b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);
                      b.texImage2D(b.TEXTURE_2D, 0, ia, O, da, 0, fa, ja, null);
                      a(null);
                      Sa[L] = Ka;
                    }
                    gb = !0;
                  }
                a(null);
                y[l] = -1;
                va && b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !1);
                hb = !0;
                h.Y && W && (h.Y(W), (h.Y = null));
              }
              var h = Object.assign({}, D, q),
                N = p++;
              null === h.isFlipY && (h.isFlipY = h.url || h.array ? !0 : !1);
              h.data &&
                ((h.array =
                  'string' === typeof h.data
                    ? Nb(h.data)
                    : h.isFloat
                    ? new Float32Array(h.data)
                    : new Uint8Array(h.data)),
                (h.isFlipY = !1));
              var qa = 0,
                ua = h.D ? !0 : !1,
                xa = null,
                Ta = null,
                Ib = !1,
                xb = null;
              h.H = h.H || h.isFloat;
              h.H && (qa = 1);
              h.qd || Z.u() || !h.isFloat || !na || Z.Db() || (h.isFloat = !1);
              h.isFloat && (qa = 2);
              h.isAnisotropicFiltering &&
                Y &&
                !JEContext.$e() &&
                (h.isAnisotropicFiltering = !1);
              var ta = b.createTexture(),
                Ea = null,
                wa = !1,
                J = 0,
                K = 0,
                hb = !1,
                ib = !1,
                ya = null,
                Ba = null,
                yb = null,
                Wa = null,
                ia = null,
                fa = null,
                ja = null,
                va = h.isFlipY,
                Ja = h.H && h.isMipmap && 'undefined' !== typeof Va && !Va.Lc() ? !0 : !1,
                Sa = null,
                fb = -1,
                gb = !1,
                La = { $b: !1, Cb: null, Ob: null };
              h.width && ((J = h.width), (K = h.height ? h.height : J));
              var W = {
                get: function () {
                  return ta;
                },
                A: function () {
                  return J;
                },
                N: function () {
                  return K;
                },
                Ze: function () {
                  return h.url;
                },
                af: function () {
                  return h.isFloat;
                },
                cf: function () {
                  return h.H;
                },
                df: function () {
                  return h.isLinear;
                },
                bb: function () {
                  b.generateMipmap(b.TEXTURE_2D);
                },
                Hc: function (v, L) {
                  Ja ? (v || (v = W.Sb()), W.Sa(L), a(Sa[v]), (y[L] = -1)) : W.b(L);
                },
                Sb: function () {
                  -1 === fb && (fb = Math.log(J) / Math.log(2));
                  return fb;
                },
                ed: function (v) {
                  if (Ja) {
                    v || (v = W.Sb());
                    t.set('s11');
                    W.Sa(0);
                    for (var L = J, da = K, O = 1; O <= v; ++O)
                      (L /= 2),
                        (da /= 2),
                        t.wa('u7', 0.25 / L, 0.25 / da),
                        b.viewport(0, 0, L, da),
                        a(Sa[O - 1]),
                        b.framebufferTexture2D(
                          aa.ha(),
                          b.COLOR_ATTACHMENT0,
                          b.TEXTURE_2D,
                          Sa[O],
                          0
                        ),
                        ka.g(!1, 1 === O);
                    y[0] = -1;
                  } else W.bb();
                },
                Sa: function (v) {
                  v !== l && (b.activeTexture(n[v]), (l = v));
                },
                b: function (v) {
                  if (!hb) return !1;
                  W.Sa(v);
                  if (y[v] === N) return !1;
                  a(ta);
                  y[v] = N;
                  return !0;
                },
                Bb: function (v) {
                  b.activeTexture(n[v]);
                  l = v;
                  a(ta);
                  y[v] = N;
                },
                l: function () {
                  r = W;
                  b.framebufferTexture2D(
                    aa.ha(),
                    b.COLOR_ATTACHMENT0,
                    b.TEXTURE_2D,
                    ta,
                    0
                  );
                },
                J: function () {
                  r = W;
                  b.viewport(0, 0, J, K);
                  b.framebufferTexture2D(
                    aa.ha(),
                    b.COLOR_ATTACHMENT0,
                    b.TEXTURE_2D,
                    ta,
                    0
                  );
                },
                vb: B.vb,
                resize: function (v, L) {
                  J = v;
                  K = L;
                  C();
                },
                clone: function (v) {
                  v = B.instance({
                    width: J,
                    height: K,
                    H: h.H,
                    isFloat: h.isFloat,
                    isLinear: h.isLinear,
                    isMirrorY: h.isMirrorY,
                    isFlipY: v ? !va : va,
                    isPot: h.isPot
                  });
                  Ia.set('s0');
                  aa.U();
                  v.l();
                  b.viewport(0, 0, J, K);
                  W.b(0);
                  ka.g(!0, !0);
                  return v;
                },
                Qd: function () {
                  b.viewport(0, 0, J, K);
                },
                remove: function () {
                  b.deleteTexture(ta);
                  F.splice(F.indexOf(W), 1);
                  W = null;
                },
                refresh: function () {
                  W.Bb(0);
                  va && b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !0);
                  ua
                    ? b.texImage2D(b.TEXTURE_2D, 0, ia, fa, b.UNSIGNED_BYTE, h.D)
                    : b.texImage2D(b.TEXTURE_2D, 0, ia, J, K, 0, fa, ja, wa);
                  va && b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !1);
                },
                Hb: function () {
                  var v = J * K * 4;
                  Ba = [
                    new Uint8Array(v),
                    new Uint8Array(v),
                    new Uint8Array(v),
                    new Uint8Array(v)
                  ];
                  ya = [
                    new Float32Array(Ba[0].buffer),
                    new Float32Array(Ba[1].buffer),
                    new Float32Array(Ba[2].buffer),
                    new Float32Array(Ba[3].buffer)
                  ];
                  yb = new Uint8Array(4 * v);
                  Wa = new Float32Array(yb.buffer);
                  ib = !0;
                },
                oc: function () {
                  ib || W.Hb();
                  b.readPixels(0, 0, J, 4 * K, b.RGBA, b.UNSIGNED_BYTE, yb);
                  for (var v = J * K, L = 2 * v, da = 3 * v, O = 0; O < v; ++O)
                    (ya[0][O] = Wa[O]),
                      (ya[1][O] = Wa[O + v]),
                      (ya[2][O] = Wa[O + L]),
                      (ya[3][O] = Wa[O + da]);
                  return ya;
                },
                Gd: function () {
                  La.$b ||
                    ((La.Cb = new Uint8Array(J * K * 4)),
                    (La.Ob = new Float32Array(La.buffer)),
                    (La.$b = !0));
                  b.readPixels(0, 0, J, K, b.RGBA, b.UNSIGNED_BYTE, La.Cb);
                  return La.Ob;
                },
                Ib: function (v) {
                  aa.F();
                  t.set('s12');
                  W.b(0);
                  if (v)
                    b.viewport(0, 0, J, K),
                      t.tb('u8', 0.25, 0.25, 0.25, 0.25),
                      ka.g(!1, !0);
                  else
                    for (v = 0; 4 > v; ++v)
                      b.viewport(0, K * v, J, K), t.tb('u8', A[v]), ka.g(!1, 0 === v);
                },
                Bf: function (v) {
                  var L = ja === x[0] && !f();
                  a(ta);
                  va && b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !0);
                  L
                    ? (Ib ||
                        ((xa = document.createElement('canvas')),
                        (xa.width = J),
                        (xa.height = K),
                        (Ta = xa.getContext('2d')),
                        (xb = Ta.createImageData(J, K)),
                        (Ib = !0)),
                      xb.data.set(v),
                      Ta.putImageData(xb, 0, 0),
                      b.texImage2D(b.TEXTURE_2D, 0, ia, fa, ja, xa))
                    : b.texImage2D(b.TEXTURE_2D, 0, ia, J, K, 0, fa, ja, v);
                  y[l] = N;
                  va && b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !1);
                },
                Cf: function (v, L) {
                  a(ta);
                  L && b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !0);
                  b.texImage2D(b.TEXTURE_2D, 0, ia, fa, ja, v);
                  y[l] = N;
                  L && b.pixelStorei(b.UNPACK_FLIP_Y_WEBGL, !1);
                },
                rf: function (v, L) {
                  var da = J * K,
                    O = 4 * da;
                  v = h.H ? (v ? 'RGBE' : 'JSON') : 'RGBA';
                  L && (v = L);
                  L = Z.u() && !1;
                  var Ka = null;
                  switch (v) {
                    case 'RGBE':
                      Ka = 's40';
                      break;
                    case 'JSON':
                      Ka = L ? 's0' : 's12';
                      break;
                    case 'RGBA':
                    case 'RGBAARRAY':
                      Ka = 's6';
                  }
                  ib ||
                    ('RGBA' === v || 'RGBE' === v || 'RGBAARRAY' === v
                      ? ((Ba = new Uint8Array(O)), (ib = !0))
                      : 'JSON' !== v || L || W.Hb());
                  aa.F();
                  t.set(Ka);
                  W.b(0);
                  O = null;
                  if ('RGBA' === v || 'RGBE' === v || 'RGBAARRAY' === v) {
                    b.viewport(0, 0, J, K);
                    ka.g(!0, !0);
                    b.readPixels(0, 0, J, K, b.RGBA, b.UNSIGNED_BYTE, Ba);
                    if ('RGBAARRAY' === v) return { data: Ba };
                    G ||
                      ((g = document.createElement('canvas')),
                      (w = g.getContext('2d')),
                      (G = !0));
                    g.width = J;
                    g.height = K;
                    da = w.createImageData(J, K);
                    da.data.set(Ba);
                    w.putImageData(da, 0, 0);
                    O = g.toDataURL('image/png');
                  } else if ('JSON' === v)
                    if (L)
                      (O = new Float32Array(da)),
                        b.viewport(0, 0, J, K),
                        ka.g(!0, !0),
                        b.readPixels(0, 0, J, K, b.RGBA, b.FLOAT, O);
                    else {
                      for (O = 0; 4 > O; ++O)
                        b.viewport(0, K * O, J, K), t.tb('u8', A[O]), ka.g(!O, !O);
                      W.oc();
                      O = Array(da);
                      for (L = 0; L < da; ++L)
                        (O[4 * L] = ya[0][L]),
                          (O[4 * L + 1] = ya[1][L]),
                          (O[4 * L + 2] = ya[2][L]),
                          (O[4 * L + 3] = ya[3][L]);
                    }
                  return {
                    format: v,
                    data: O,
                    width: J,
                    height: K,
                    isMirrorY: h.isMirrorY,
                    isFlipY: 'RGBA' === v ? h.isFlipY : !h.isFlipY
                  };
                }
              };
              h.isMipmap && !Ja && hb && !gb && (W.bb(), (gb = !0));
              if (h.url)
                a(ta),
                  b.texImage2D(
                    b.TEXTURE_2D,
                    0,
                    b.RGBA,
                    1,
                    1,
                    0,
                    b.RGBA,
                    b.UNSIGNED_BYTE,
                    null
                  ),
                  (Ea = new Image()),
                  (Ea.me = 'Anonymous'),
                  (Ea.crossOrigin = 'Anonymous'),
                  (Ea.src = h.url),
                  (Ea.onload = function () {
                    J = Ea.width;
                    K = Ea.height;
                    C();
                  });
              else if (h.D) {
                var Jb = function () {
                  J = void 0 !== h.D.videoWidth ? h.D.videoWidth : h.D.width;
                  K = void 0 !== h.D.videoHeight ? h.D.videoHeight : h.D.height;
                  J ? C() : setTimeout(Jb, 1);
                };
                Jb();
              } else
                h.array
                  ? (h.H && !h.isFloat
                      ? h.array instanceof Uint16Array
                        ? ((wa = h.array), C())
                        : e()
                        ? ((wa = d(h.array)), C())
                        : (C(), B.dd(W, h.array, va))
                      : ((wa = h.isFloat
                          ? h.array instanceof Float32Array
                            ? h.array
                            : new Float32Array(h.array)
                          : h.array instanceof Uint8Array
                          ? h.array
                          : new Uint8Array(h.array)),
                        C()),
                    h.isKeepArray ||
                      (wa && wa !== h.array && (wa = null), delete h.array))
                  : C();
              W.Ve = W.A;
              h.Y && hb && (h.Y(W), (h.Y = null));
              F.push(W);
              return W;
            },
            F: function (q) {
              q !== l && (b.activeTexture(n[q]), (l = q));
              y[q] = -1;
              a(null);
            },
            de: function (q) {
              m.random.b(q);
            },
            vb: function () {
              r = null;
              b.framebufferTexture2D(aa.ha(), b.COLOR_ATTACHMENT0, b.TEXTURE_2D, null, 0);
            },
            reset: function () {
              for (var q = 0; q < n.length; ++q) y[q] = -1;
              l = -1;
            },
            pf: function () {
              l = -1;
            },
            Vd: function () {
              for (var q = 0; q < n.length; ++q) B.F(q);
            },
            Pb: function () {
              m && (m.random.remove(), m.uc.remove());
            },
            Af: function (q, C) {
              if ('RGBA' === q.format || 'RGBE' === q.format) {
                var h = new Image();
                h.src = q.data;
                h.onload = function () {
                  B.instance({
                    isMirrorY: q.isMirrorY,
                    isFlipY: q.isFlipY,
                    isFloat: !1,
                    D: h,
                    Y: function (N) {
                      if ('RGBA' === q.format) C(N);
                      else {
                        var qa = q.width,
                          ua = q.height,
                          xa = B.instance({
                            isMirrorY: q.isMirrorY,
                            isFloat: !0,
                            width: qa,
                            height: ua,
                            isFlipY: q.isFlipY
                          });
                        aa.U();
                        b.viewport(0, 0, qa, ua);
                        t.set('s41');
                        xa.l();
                        N.b(0);
                        ka.g(!0, !0);
                        B.F(0);
                        C(xa);
                        b.flush();
                        setTimeout(N.remove, 50);
                      }
                    }
                  });
                };
              } else
                'JSON' === q.format
                  ? C(
                      B.instance({
                        isFloat: !0,
                        isFlipY: q.isFlipY,
                        width: q.width,
                        height: q.height,
                        array: new Float32Array(q.data)
                      })
                    )
                  : C(!1);
            },
            h: function () {
              r && (ra.U(), B.vb(), ra.F());
              B.Vd();
              F.slice(0).forEach(function (q) {
                q.remove();
              });
              F.splice(0);
              M = !1;
              p = 0;
              Va.h();
            }
          };
        return B;
      })(),
      Rb = (function () {
        return {
          instance: function (a) {
            var c = [Fa.instance(a), Fa.instance(a)],
              d = [c[1], c[0]],
              e = d,
              f = {
                Nd: function (k) {
                  e[1].l();
                  e[0].b(k);
                  f.rc();
                },
                sf: function (k) {
                  e[1].J();
                  e[0].b(k);
                  f.rc();
                },
                rc: function () {
                  e = e === c ? d : c;
                },
                refresh: function () {
                  e[0].refresh();
                  e[1].refresh();
                },
                b: function (k) {
                  e[0].b(k);
                },
                ce: function (k) {
                  e[1].b(k);
                },
                Pe: function () {
                  return e[0];
                },
                remove: function () {
                  e[0].remove();
                  e[1].remove();
                  e = null;
                }
              };
            return f;
          }
        };
      })(),
      Z = (function () {
        function a() {
          c = 'undefined' === typeof Aa ? JEContext : Aa;
          d = !0;
        }
        var c = null,
          d = !1,
          e = !1,
          f = null,
          k = null,
          l = !1,
          n = null,
          p = !1,
          y = null,
          m = !1,
          r = null,
          x = !1,
          z = !0,
          T = !0,
          M = !0,
          F = null,
          D = 'undefined' === typeof window ? {} : window,
          G = {
            o: function () {
              if (d) return !0;
              a();
              G.Lb();
              G.ab();
              G.$c();
              G.ad();
              aa.o();
              Fa.o();
              if (!G.Vc()) return !1;
              ka.o();
              Fa.od();
              return !0;
            },
            A: function () {
              d || a();
              return c.A();
            },
            N: function () {
              d || a();
              return c.N();
            },
            u: function () {
              d || a();
              return c.u();
            },
            $c: function () {
              x = (r =
                b.getExtension('EXT_color_buffer_float') ||
                b.getExtension('WEBGL_color_buffer_float') ||
                b.getExtension('OES_color_buffer_float'))
                ? !0
                : !1;
              D.GL_EXT_COLORBUFFERFLOAT = r;
            },
            ad: function () {
              b.getExtension('EXT_color_buffer_half_float') ||
                b.getExtension('WEBGL_color_buffer_half_float') ||
                b.getExtension('OES_color_buffer_half_float');
            },
            Lb: function () {
              if (!e) {
                this.u() ||
                  ((f =
                    b.getExtension('OES_texture_float') ||
                    b.getExtension('MOZ_OES_texture_float') ||
                    b.getExtension('WEBKIT_OES_texture_float')),
                  (l = (D.GL_EXT_FLOAT = f) ? !0 : !1));
                if (l || this.u())
                  (k =
                    b.getExtension('OES_texture_float_linear') ||
                    b.getExtension('MOZ_OES_texture_float_linear') ||
                    b.getExtension('WEBKIT_OES_texture_float_linear')),
                    (D.GL_EXT_FLOATLINEAR = k);
                e = !0;
              }
            },
            ab: function () {
              if (!m) {
                if (!this.u()) {
                  if (
                    (n =
                      b.getExtension('OES_texture_half_float') ||
                      b.getExtension('MOZ_OES_texture_half_float') ||
                      b.getExtension('WEBKIT_OES_texture_half_float'))
                  )
                    (F = n.HALF_FLOAT_OES), (p = !0);
                  !F && b.HALF_FLOAT && (F = b.HALF_FLOAT);
                  !F && b.FLOAT && (F = b.FLOAT);
                  D.GL_EXT_HALFFLOAT = n;
                }
                if (p || this.u())
                  (y =
                    b.getExtension('OES_texture_half_float_linear') ||
                    b.getExtension('MOZ_OES_texture_half_float_linear') ||
                    b.getExtension('WEBKIT_OES_texture_half_float_linear')),
                    (D.GL_EXT_HALFFLOATLINEAR = y);
                m = !0;
              }
            },
            Fa: function () {
              if (G.u()) return b.HALF_FLOAT;
              G.ab();
              return p ? F : b.FLOAT;
            },
            Db: function () {
              return z;
            },
            Kc: function () {
              return T;
            },
            ee: function () {
              return M;
            },
            Jc: function () {
              return x;
            },
            Xc: function () {
              T = z = !0;
              var g = b.createFramebuffer();
              b.bindFramebuffer(b.FRAMEBUFFER, g);
              var w = b.createTexture();
              b.bindTexture(b.TEXTURE_2D, w);
              b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);
              b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.NEAREST);
              b.texImage2D(
                b.TEXTURE_2D,
                0,
                G.u() && b.RGBA32F ? b.RGBA32F : b.RGBA,
                1,
                1,
                0,
                b.RGBA,
                b.FLOAT,
                null
              );
              b.framebufferTexture2D(aa.ha(), b.COLOR_ATTACHMENT0, b.TEXTURE_2D, w, 0);
              var A = b.checkFramebufferStatus(aa.cb());
              A !== b.FRAMEBUFFER_COMPLETE && (z = !1);
              b.texImage2D(
                b.TEXTURE_2D,
                0,
                G.u() && b.RGBA16F ? b.RGBA16F : b.RGBA,
                1,
                1,
                0,
                b.RGBA,
                G.Fa(),
                null
              );
              b.framebufferTexture2D(aa.ha(), b.COLOR_ATTACHMENT0, b.TEXTURE_2D, w, 0);
              A = b.checkFramebufferStatus(aa.cb());
              A !== b.FRAMEBUFFER_COMPLETE && (T = !1);
              b.bindTexture(b.TEXTURE_2D, null);
              b.bindFramebuffer(b.FRAMEBUFFER, null);
              b.deleteTexture(w);
              b.deleteFramebuffer(g);
            },
            Wc: function () {
              var g = aa.instance({ width: 1 });
              g.pc();
              var w = Fa.instance({ width: 1, isFloat: !0, Ka: 3 });
              g.l();
              w.l();
              b.flush();
              b.checkFramebufferStatus(aa.cb()) !== b.FRAMEBUFFER_COMPLETE
                ? (Fa.Kd(), (M = !1))
                : (M = !0);
              g.remove();
              w.remove();
            },
            Vc: function () {
              G.Xc();
              if (!z && !T) return !1;
              G.Wc();
              return !0;
            },
            h: function () {
              Fa.h();
              Ia.h();
              aa.h();
              ka.h();
              d = !1;
            }
          };
        return G;
      })(),
      Q = ka,
      ra = aa,
      R = Fa,
      Va = (function () {
        function a(z, T, M, F) {
          b.texParameteri(
            b.TEXTURE_2D,
            b.TEXTURE_MIN_FILTER,
            F ? b.NEAREST_MIPMAP_NEAREST : b.LINEAR
          );
          var D = null;
          try {
            if (
              ((D = b.getError()),
              D !== b.NO_ERROR && console.log('GLERR in test_mipmapping():', D),
              b.texImage2D(b.TEXTURE_2D, 0, z, 2, 2, 0, b.RGBA, T, M),
              (D = b.getError()),
              D !== b.NO_ERROR)
            )
              return !1;
          } catch (G) {
            return !1;
          }
          F && b.generateMipmap(b.TEXTURE_2D);
          Q.oa();
          Q.g(!1, !0);
          b.readPixels(0, 0, 1, 1, b.RGBA, b.UNSIGNED_BYTE, l);
          D = b.getError();
          D === b.INVALID_OPERATION &&
            'undefined' !== typeof b.PIXEL_PACK_BUFFER &&
            (b.bindBuffer(b.PIXEL_PACK_BUFFER, null),
            b.readPixels(0, 0, 1, 1, b.RGBA, b.UNSIGNED_BYTE, l),
            (D = b.getError()));
          return D !== b.NO_ERROR ? !1 : 0 !== l[0];
        }
        function c(z) {
          return Z.Db() && a(m, b.FLOAT, new Float32Array(p), z) ? ((k = f.yb), !0) : !1;
        }
        function d(z) {
          return Z.Kc()
            ? a(r, Z.Fa(), new Uint16Array(p), z) || a(r, b.FLOAT, new Float32Array(p), z)
              ? ((k = f.Ra), !0)
              : !1
            : !1;
        }
        var e = !1,
          f = { yb: 3, Ra: 2, RGBA8: 0 },
          k = f.RGBA8,
          l = new Uint8Array(4),
          n = [0.8, 1, 0.8, 1],
          p = n.concat(n, n, n),
          y = !0,
          m = null,
          r = null,
          x = {
            o: function () {
              Z.Lb();
              Z.ab();
              r = m = b.RGBA;
              if (Aa.u()) {
                var z = b.RGBA32F;
                z && (m = z);
                (z = b.RGBA16F) && (r = z);
              }
              Q.o();
              ra.reset();
              ra.F();
              b.viewport(0, 0, 1, 1);
              t.set('s0');
              e = !0;
              z = b.createTexture();
              b.activeTexture(b.TEXTURE0);
              b.bindTexture(b.TEXTURE_2D, z);
              b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_S, b.REPEAT);
              b.texParameteri(b.TEXTURE_2D, b.TEXTURE_WRAP_T, b.REPEAT);
              b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.NEAREST);
              if (d(!0) || c(!0)) return !0;
              y = !1;
              if (d(!1) || c(!1)) return !0;
              if (Aa.u()) {
                r = m = b.RGBA;
                if (d(!0) || c(!0)) return !0;
                y = !1;
                if (d(!1) || c(!1)) return !0;
              }
              return !1;
            },
            Lc: function () {
              return y;
            },
            Qe: function () {
              return k;
            },
            bf: function () {
              e || x.o();
              return k === f.yb;
            },
            ud: function () {
              e || x.o();
              return k === f.Ra;
            },
            h: function () {
              e = !1;
              k = f.RGBA8;
              y = !0;
            }
          };
        return x;
      })(),
      Xb = (function () {
        return {
          instance: function (a) {
            var c = R.instance(a.alpha),
              d = R.instance(a.beta);
            return {
              Zc: function () {
                c.b(1);
                d.b(2);
              }
            };
          }
        };
      })(),
      Lb = (function () {
        return {
          instance: function (a) {
            var c = null,
              d = !1,
              e = !1,
              f = null,
              k = !1,
              l = !1,
              n = null,
              p = 'undefined' === typeof a.preprocessing ? !1 : a.preprocessing,
              y =
                'undefined' === typeof a.preprocessingSize ? a.size : a.preprocessingSize;
            a.mask &&
              ((d = !0),
              I && void 0 !== I.Ec && (a.mask = I.Ec + a.mask),
              (c = R.instance({ isFloat: !1, url: a.mask })));
            var m = !1;
            a.customInputShader &&
              ((m = 's42'),
              t.zb({
                name: '_',
                id: m,
                a: a.customInputShader,
                c: ['uSource'],
                precision: 'lowp'
              }),
              t.K(m, [{ type: '1i', name: '_', value: 0 }]));
            switch (p) {
              case 'sobel':
                n = 's31';
                k = !0;
                break;
              case 'meanNormalization':
                n = 's32';
                k = !0;
                break;
              case 'grayScale':
                n = 's28';
                k = !1;
                break;
              case 'grayScaleTilt':
                n = 's29';
                l = !0;
                k = !1;
                break;
              case 'rgbGrayTilt':
                n = 's30';
                l = !0;
                k = !1;
                break;
              case 'copy':
                n = m ? m : 's0';
                break;
              case 'inputLightRegulation':
                n = m ? m : 's28';
                f = Yb.instance({ Wb: y, mc: a.size, dc: a.nBlurPass, td: !1 });
                e = !0;
                break;
              case 'direct':
              case 'none':
                n = !1;
                break;
              default:
                n = 's3';
            }
            l && t.K(n, [{ name: 'u27', type: '1f', value: a.tilt }]);
            d && (n += 'Mask');
            var r = R.instance({ isFloat: !1, isPot: !1, width: a.size }),
              x = {
                A: function () {
                  return y;
                },
                eb: function () {
                  return x.A();
                },
                kd: function () {
                  return e ? f.Tb() : r;
                },
                I: function () {
                  ra.U();
                  n &&
                    (t.set(n),
                    k && t.B('u28', 1 / a.size),
                    r.J(),
                    d && c.b(1),
                    Q.g(!1, !1),
                    r.b(0),
                    e && f.Dd(r));
                },
                h: function () {
                  r.remove();
                  d && c.remove();
                }
              };
            return x;
          }
        };
      })(),
      Mb = (function () {
        return {
          instance: function (a) {
            'undefined' === typeof a.disableNormalize && (a.disableNormalize = !1);
            var c = {
                input: null,
                fa: null,
                ib: null,
                S: null,
                Ma: null,
                pb: null,
                qb: null
              },
              d = null,
              e = [],
              f = [],
              k = !1,
              l = null,
              n = !0,
              p = -1,
              y = a.isReorganize ? a.isReorganize : !1,
              m = a.kernelsNumber ? !0 : !1,
              r = a.dynPelu ? Xb.instance(a.dynPelu) : !1,
              x = r ? !0 : !1,
              z = { isEnabled: !1 };
            a.sd
              ? ((a.sparsity =
                  'undefined' !== typeof a.sparsity ? a.sparsity : a.Na.eb()),
                (n = !1))
              : 'full' === a.connectivityUp && (a.sparsity = a.Na.eb());
            var T = {
                elu: 's15',
                elu01: 's16',
                relu: 's14',
                arctan: 's18',
                sigmoid: 's13',
                copy: 's0',
                softplus: 's19',
                dynPelu: 's17'
              }[a.activation],
              M = a.sparsity * a.sparsity,
              F = !1,
              D = a.size,
              G = '';
            if (a.maxPooling) {
              switch (a.maxPooling.size) {
                case 2:
                  G = 's33';
                  break;
                case 4:
                  G = 's34';
              }
              F = !0;
              D /= a.maxPooling.size;
              c.pb = R.instance({ isFloat: !0, isPot: !1, width: D });
            }
            var g = void 0 !== a.Bd && a.Bd ? !0 : !1,
              w = null,
              A = null,
              Y = null;
            if (g) {
              w = 's43' + a.index.toString();
              t.Vb('s43', w, [((a.normalization.n - 1) / 2).toFixed(1)]);
              t.K(w, [
                { type: '1i', name: 'u1', value: 0 },
                { type: '2f', name: 'u7', value: [1 / a.size, 1 / a.size] },
                { type: '1f', name: 'u6', value: a.normalization.alpha },
                { type: '1f', name: 'u9', value: a.normalization.beta },
                { type: '1f', name: 'u32', value: a.normalization.k }
              ]);
              var na = { isFloat: !0, isPot: !0, width: a.size };
              A = R.instance(na);
              Y = R.instance(na);
            }
            var la = -1,
              ca = null;
            n && (c.S = R.instance({ isFloat: !0, isPot: !1, width: a.size }));
            c.fa = R.instance(a.bias);
            var oa = {
              A: function () {
                return a.size;
              },
              eb: function () {
                return D;
              },
              Qb: function () {
                return a.classesCount;
              },
              Gc: function (B) {
                d.b(B);
              },
              Ed: function () {
                a.remap &&
                  a.remap.isEnabled &&
                  (z = {
                    isEnabled: !0,
                    xd: R.instance({
                      isFloat: !1,
                      isFlipY: !1,
                      array: new Uint8Array(a.remap.maskTexture.data),
                      width: a.remap.maskTexture.width,
                      isPot: !1
                    }),
                    layers: a.remap.layers.map(function (B) {
                      return a.parent.jd(B);
                    }),
                    depth: a.remap.depth
                  });
              },
              Md: function () {
                switch (a.connectivityUp) {
                  case 'direct':
                    ca = Zb.instance(a.connectivity);
                    break;
                  case 'square':
                    ca = $b.instance(a.connectivity);
                    break;
                  case 'squareFast':
                    ca = ac.instance(a.connectivity, a.activation);
                    break;
                  case 'full':
                    ca = bc.instance(a.connectivity);
                    break;
                  case 'conv':
                    (p = a.kernelsNumber),
                      (ca = cc.instance(a.connectivity)),
                      y &&
                        (c.Ma = R.instance({
                          width: D,
                          isFloat: !0,
                          isFlipY: !1,
                          isPot: !1
                        }));
                }
                if (ca.ja) {
                  var B = a.size * a.sparsity;
                  la = Math.log(B / a.size) / Math.log(2);
                  c.input = R.instance({
                    isMipmap: !0,
                    isFloat: !0,
                    isPot: !0,
                    width: B,
                    lb: la
                  });
                  c.ib = R.instance({ isFloat: !0, isPot: !0, width: a.size });
                }
              },
              I: function (B) {
                d = B;
                ca.ja
                  ? (c.input.J(),
                    m && c.fa.b(2),
                    ca.I(z),
                    c.input.b(0),
                    c.input.ed(la),
                    c.ib.J(),
                    m ? t.set('s0') : (t.set('s27'), t.B('u26', M), c.fa.b(1)),
                    c.input.Hc(la, 0),
                    Q.g(!1, !1),
                    t.set(T),
                    g ? A.l() : c.S.l(),
                    c.ib.b(0),
                    x && r.Zc(),
                    Q.g(!1, !1))
                  : (c.S.J(), c.fa.b(1), ca.I());
                g &&
                  (t.set(w),
                  Y.l(),
                  A.b(0),
                  Q.g(!1, !1),
                  t.set('s44'),
                  t.B('u6', 1),
                  c.S.l(),
                  Y.b(1),
                  Q.g(!1, !1));
                if (n)
                  return (
                    F
                      ? (c.pb.J(),
                        c.S.b(0),
                        t.set(G),
                        t.wa('u7', 1 / a.size, 1 / a.size),
                        Q.g(!1, !1),
                        (B = c.pb))
                      : (B = c.S),
                    B.b(0),
                    y &&
                      (c.Ma.l(),
                      t.set('s21'),
                      t.wa('u13', p, D / p),
                      Q.g(!1, !1),
                      (B = c.Ma),
                      c.Ma.b(0)),
                    B
                  );
                B = c.S;
                a.disableNormalize ||
                  (t.set('gpuRawAvg' === k ? 's8' : 's7'),
                  t.B('u4', 1 / a.size),
                  c.qb.J(),
                  c.S.b(0),
                  Q.g(!1, !1),
                  (B = c.qb));
                switch (k) {
                  case 'cpuRGBA2Float':
                    B.Ib(!1);
                    B = oa.Fd(B);
                    l(B);
                    break;
                  case 'cpuMeanFloat':
                    B.Ib(!0);
                    B = B.Gd();
                    l(B);
                    break;
                  case 'gpuRawAvg':
                  case 'gpuRaw':
                    B.b(0);
                  case 'none':
                    l(B);
                }
                return !1;
              },
              Tc: function (B) {
                B && 'undefined' !== typeof B.lc && ((k = B.lc), (l = B.Cd));
                c.S = R.instance({ isFloat: !0, isPot: !0, isMipmap: !1, width: a.size });
                B =
                  'undefined' !== typeof a.classesCount && a.classesCount
                    ? a.classesCount
                    : a.size * a.size;
                for (var q = 0, C = 0, h = 0; q < B; ++q)
                  e.push(C + (a.size - 1 - h) * a.size),
                    f.push([-1, -1, -1, -1]),
                    ++C,
                    C === a.size && ((C = 0), ++h);
                a.disableNormalize ||
                  (c.qb = R.instance({ isFloat: !0, isPot: !0, width: a.size }));
              },
              Fd: function (B) {
                var q = B.oc();
                e.forEach(function (C, h) {
                  f[h][0] = q[0][C];
                  f[h][1] = q[1][C];
                  f[h][2] = q[2][C];
                  f[h][3] = q[3][C];
                });
                return f;
              },
              h: function () {
                for (var B in c) {
                  var q = c[B];
                  q && q.remove();
                }
                ca && (ca.h(), (ca = null));
              }
            };
            a.Na && oa.Md(a.Na);
            return oa;
          }
        };
      })();
    zb.Jb = function (a) {
      a.forEach(function (c) {
        c.Rc && R.Jb(c.Rc.Df);
        c.fa && R.Jb(c.fa);
      });
    };
    var Zb = (function () {
        return {
          instance: function (a) {
            var c = R.instance(a.weights);
            delete a.weights.data;
            return {
              ja: !0,
              Ea: function () {
                return 1;
              },
              h: function () {
                c.remove();
              },
              nd: function () {
                return c;
              },
              I: function () {
                t.set('s26');
                c.b(1);
                Q.g(!1, !1);
              }
            };
          }
        };
      })(),
      bc = (function () {
        return {
          instance: function (a) {
            var c = a.fromLayerSize,
              d = R.instance(a.weights);
            delete a.weights.data;
            return {
              ja: !0,
              Ea: function () {
                return c;
              },
              h: function () {
                d.remove();
              },
              I: function (e) {
                if (e.isEnabled) {
                  t.set('s24');
                  e.xd.b(3);
                  var f,
                    k = Math.min(e.layers.length, e.depth);
                  for (f = 0; f < k; ++f) e.layers[f].Gc(4 + f);
                } else t.set('s23');
                t.B('u17', a.toLayerSize);
                d.b(1);
                Q.g(!1, !1);
              }
            };
          }
        };
      })(),
      $b = (function () {
        return {
          instance: function (a) {
            for (
              var c = a.fromLayerSize,
                d = a.toLayerSize,
                e = a.toSparsity,
                f = e * d,
                k = f / c,
                l = c / d,
                n = 0,
                p = 0,
                y = 0,
                m = Array(e * d * e * d * 4),
                r = Array(e * d * e * d * 4),
                x = Array(c * c),
                z = 0;
              z < x.length;
              ++z
            )
              x[z] = 0;
            z = Math.floor(e / 2);
            for (var T = 0.5 / d, M = 0.5 / c, F = 0.5 / f, D = 0; D < d; ++D)
              for (var G = Math.round(D * l), g = 0; g < d; ++g) {
                var w = Math.round(g * l),
                  A = D / d,
                  Y = g / d;
                A += T;
                Y += T;
                for (var na = 0; na < e; ++na) {
                  var la = G + na - z;
                  0 > la && (la += c);
                  la >= c && (la -= c);
                  for (var ca = 0; ca < e; ++ca) {
                    var oa = n / f,
                      B = p / f,
                      q = w + ca - z;
                    0 > q && (q += c);
                    q >= c && (q -= c);
                    var C = la / c,
                      h = q / c;
                    B = 1 - B - 1 / f;
                    C += M;
                    h += M;
                    oa += F;
                    B += F;
                    var N = D * e + na,
                      qa = g * e + ca;
                    qa = d * e - qa - 1;
                    N = qa * d * e + N;
                    m[4 * N] = oa;
                    m[4 * N + 1] = B;
                    m[4 * N + 2] = C;
                    m[4 * N + 3] = h;
                    h = x[q * c + la]++;
                    N = h % k;
                    C = la * k + N;
                    q = q * k + (h - N) / k;
                    q = c * k - 1 - q;
                    q = q * c * k + C;
                    r[4 * q] = oa;
                    r[4 * q + 1] = B;
                    r[4 * q + 2] = A;
                    r[4 * q + 3] = Y;
                    ++n >= f && ((n = 0), ++p);
                    ++y;
                  }
                }
              }
            x = null;
            var ua = R.instance(a.weights);
            delete a.weights.data;
            var xa = R.instance({
              width: f,
              isFloat: !0,
              array: new Float32Array(r),
              isPot: !0
            });
            r = null;
            var Ta = R.instance({
              width: f,
              isFloat: !0,
              array: new Float32Array(m),
              isPot: !0
            });
            m = null;
            return {
              ja: !0,
              Ea: function () {
                return k;
              },
              h: function () {
                xa.remove();
                Ta.remove();
                ua.remove();
              },
              I: function () {
                t.set('s22');
                ua.b(1);
                Ta.b(2);
                Q.g(!1, !1);
              }
            };
          }
        };
      })(),
      cc = (function () {
        return {
          instance: function (a) {
            var c = a.kernelsNumber,
              d = a.toSparsity,
              e = (d * a.toLayerSize) / a.fromLayerSize,
              f = R.instance(a.weights);
            delete a.weights.data;
            return {
              ja: !0,
              Ea: function () {
                return e;
              },
              Xe: function () {
                return d;
              },
              nd: function () {
                return f;
              },
              h: function () {
                f.remove();
              },
              I: function () {
                t.set('s25');
                t.B('u23', c);
                t.B('u24', d);
                t.B('u17', a.toLayerSize);
                t.B('u25', a.fromLayerSize);
                f.b(1);
                Q.g(!1, !1);
              }
            };
          }
        };
      })(),
      ac = (function () {
        return {
          instance: function (a, c) {
            var d = a.fromLayerSize,
              e = a.toLayerSize,
              f = a.toSparsity,
              k = a.stride ? a.stride : 1,
              l = (f * e) / d,
              n = e < d,
              p = d / e,
              y = R.instance(a.weights);
            delete a.weights.data;
            var m =
              's45' +
              [d.toString(), e.toString(), f.toString(), k.toString(), c].join('_');
            t.bd(m) ||
              ((a = Wb.fd(c, 'gl_FragColor', 'gl_FragColor')),
              (e = [
                { type: '1f', name: 'u17', value: e },
                { type: '1f', name: 'u31', value: k }
              ]),
              n && e.push({ type: '1f', name: 'u25', value: d }),
              (d = [(n ? l : f).toFixed(1), a]),
              n && d.push(p.toFixed(1)),
              t.Vb(n ? 's39' : 's38', m, d),
              t.K(
                m,
                e.concat([
                  { type: '1i', name: 'u15', value: 0 },
                  { type: '1i', name: 'u22', value: 1 },
                  { type: '1i', name: 'u14', value: 3 }
                ])
              ));
            return {
              ja: !1,
              Ea: function () {
                return l;
              },
              h: function () {
                y.remove();
              },
              I: function () {
                t.set(m);
                y.b(3);
                Q.g(!1, !1);
              }
            };
          }
        };
      })(),
      Yb = (function () {
        return {
          instance: function (a) {
            var c = a.dc ? a.dc : 3,
              d = a.Wb ? a.Wb : 64,
              e = a.mc ? a.mc : 64,
              f = a.td ? !0 : !1;
            a = { isFloat: !1, width: d, isPot: !1, isFlipY: !1 };
            var k = R.instance(a),
              l = R.instance(a),
              n = R.instance(a),
              p = R.instance(a),
              y = R.instance({ isFloat: !0, width: e, isPot: !1, isFlipY: !1 }),
              m = 1 / d;
            return {
              Dd: function (r) {
                t.set('s35');
                p.l();
                Q.g(f, !1);
                t.set('s36');
                for (var x = 0; x < c; ++x)
                  k.l(),
                    t.wa('u7', m, 0),
                    Q.g(f, !1),
                    n.l(),
                    p.b(0),
                    Q.g(f, !1),
                    l.l(),
                    k.b(0),
                    t.wa('u7', 0, m),
                    Q.g(f, !1),
                    p.l(),
                    n.b(0),
                    Q.g(f, !1),
                    x !== c - 1 && l.b(0);
                t.set('s37');
                y.l();
                r.b(0);
                l.b(1);
                p.b(2);
                Q.g(f, !1);
                y.b(0);
              },
              Tb: function () {
                return y;
              }
            };
          }
        };
      })(),
      S = {
        md: function () {
          return S.Gb() ? document.createElement('video') : !1;
        },
        sa: function (a, c) {
          a[c] = !0;
          a.setAttribute(c, 'true');
        },
        Oc: function () {
          var a = !1,
            c = navigator.userAgent || navigator.vendor || window.opera;
          if (
            /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
              c
            ) ||
            /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
              c.substr(0, 4)
            )
          )
            a = !0;
          return a;
        },
        Eb: function () {
          return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        },
        gd: function () {
          var a = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
          return 2 < a.length
            ? [parseInt(a[1], 10), parseInt(a[2], 10), parseInt(a[3] || 0, 10)]
            : [0, 0, 0];
        },
        ac: function () {
          try {
            return window.matchMedia('(orientation: portrait)').matches ? !0 : !1;
          } catch (a) {
            return window.innerHeight > window.innerWidth;
          }
        },
        Nc: function () {
          return S.Fb() || S.Eb();
        },
        Fb: function () {
          var a = navigator.userAgent.toLowerCase();
          return -1 !== a.indexOf('safari') && -1 === a.indexOf('chrome') ? !0 : !1;
        },
        Ee: function () {
          return S.Oc()
            ? S.ac()
              ? (window.innerHeight / window.innerWidth) * 45
              : 45
            : 45;
        },
        Gb: function () {
          return navigator.mediaDevices && navigator.mediaDevices.getUserMedia ? !0 : !1;
        },
        pause: function (a) {
          a.pause();
        },
        qf: function (a) {
          a.play();
        },
        release: function (a) {
          a.pause();
          a.videoStream && a.videoStream.stop();
          a.videoStream = null;
        },
        Qc: function (a) {
          if (!a) return a;
          var c = !1;
          if (a.video) {
            var d = function (e) {
              var f = {};
              'undefined' !== typeof e.min && (f.min = e.min);
              'undefined' !== typeof e.max && (f.max = e.max);
              'undefined' !== typeof e.ideal && (f.ideal = e.ideal);
              return f;
            };
            c = {};
            'undefined' !== typeof a.video.width && (c.width = d(a.video.width));
            'undefined' !== typeof a.video.height && (c.height = d(a.video.height));
            'undefined' !== typeof a.video.facingMode &&
              (c.facingMode = a.video.facingMode);
          }
          c = { audio: a.audio, video: c };
          'undefined' !== typeof a.deviceId && (c.deviceId = a.deviceId);
          return c;
        },
        sc: function (a) {
          var c = a.video.width;
          a.video.width = a.video.height;
          a.video.height = c;
          return a;
        },
        Sc: function (a) {
          function c(r) {
            return [
              480,
              576,
              640,
              648,
              720,
              768,
              800,
              960,
              1080,
              1152,
              1280,
              1366,
              1920
            ].sort(function (x, z) {
              return Math.abs(x - r) - Math.abs(z - r);
            });
          }
          function d(r) {
            var x = S.Qc(a);
            e.push(r(x));
          }
          var e = [];
          if (!a || !a.video) return e;
          if (a.video.width && a.video.height) {
            if (a.video.width.ideal && a.video.height.ideal) {
              var f = c(a.video.width.ideal).slice(0, 3),
                k = c(a.video.height.ideal).slice(0, 3),
                l = {},
                n = 0;
              for (l.X = void 0; n < f.length; l = { X: l.X }, ++n) {
                l.X = f[n];
                var p = {},
                  y = 0;
                for (p.W = void 0; y < k.length; p = { W: p.W }, ++y)
                  if (
                    ((p.W = k[y]),
                    l.X !== a.video.width.ideal || p.W !== a.video.height.ideal)
                  ) {
                    var m = Math.max(l.X, p.W) / Math.min(l.X, p.W);
                    m < 4 / 3 - 0.1 ||
                      m > 16 / 9 + 0.1 ||
                      d(
                        (function (r, x) {
                          return function (z) {
                            z.video.width.ideal = r.X;
                            z.video.height.ideal = x.W;
                            return z;
                          };
                        })(l, p)
                      );
                  }
              }
            }
            d(function (r) {
              return S.sc(r);
            });
          }
          a.video.width &&
            a.video.height &&
            (a.video.width.ideal &&
              a.video.height.ideal &&
              d(function (r) {
                delete r.video.width.ideal;
                delete r.video.height.ideal;
                return r;
              }),
            d(function (r) {
              delete r.video.width;
              delete r.video.height;
              return r;
            }));
          a.video.facingMode &&
            (d(function (r) {
              delete r.video.facingMode;
              return r;
            }),
            a.video.width &&
              a.video.height &&
              d(function (r) {
                S.sc(r);
                delete r.video.facingMode;
                return r;
              }));
          e.push({ audio: a.audio, video: !0 });
          return e;
        },
        Td: function (a) {
          if (S.ac()) {
            if (!a || !a.video) return !1;
            var c = a.video.width,
              d = a.video.height;
            if (!c || !d) return !1;
            if (c.ideal && d.ideal && c.ideal > d.ideal)
              return (a.video.height = c), (a.video.width = d), !0;
          }
          return !1;
        },
        Ja: function (a) {
          a.volume = 0;
          S.sa(a, 'muted');
          if (S.Fb()) {
            if (1 === a.volume) {
              var c = function () {
                a.volume = 0;
                window.removeEventListener('mousemove', c, !1);
                window.removeEventListener('touchstart', c, !1);
              };
              window.addEventListener('mousemove', c, !1);
              window.addEventListener('touchstart', c, !1);
            }
            setTimeout(function () {
              a.volume = 0;
              S.sa(a, 'muted');
            }, 5);
          }
        },
        tc: function (a, c, d) {
          return new Promise(function (e, f) {
            if (a.srcObject && a.srcObject.getVideoTracks) {
              var k = a.srcObject.getVideoTracks();
              1 !== k.length
                ? f('INVALID_TRACKNUMBER')
                : ((k = k[0]), c ? S.get(a, e, f, d) : (k.stop(), e()));
            } else f('BAD_IMPLEMENTATION');
          });
        },
        Ub: function (a, c, d, e) {
          function f(l) {
            k || ((k = !0), d(l));
          }
          var k = !1;
          return navigator.mediaDevices
            .getUserMedia(e)
            .then(function (l) {
              function n() {
                setTimeout(function () {
                  if (a.currentTime) {
                    var p = a.videoWidth,
                      y = a.videoHeight;
                    if (0 === p || 0 === y) f('VIDEO_NULLSIZE');
                    else {
                      p && (a.style.width = p.toString() + 'px');
                      y && (a.style.height = y.toString() + 'px');
                      p = { Mc: null, Rd: null, yd: null };
                      try {
                        var m = l.getVideoTracks()[0];
                        m &&
                          ((p.yd = m),
                          (p.Mc = m.getCapabilities()),
                          (p.Rd = m.getSettings()));
                      } catch (r) {}
                      S.Nc()
                        ? a.parentNode && null !== a.parentNode
                          ? (k || c(a, l, p),
                            setTimeout(function () {
                              a.play();
                            }, 100))
                          : (document.body.appendChild(a),
                            S.Ja(a),
                            k || c(a, l, p),
                            setTimeout(function () {
                              a.style.transform = 'scale(0.0001,0.0001)';
                              a.style.position = 'fixed';
                              a.style.bottom = '0px';
                              a.style.right = '0px';
                              S.Ja(a);
                              setTimeout(function () {
                                a.play();
                              }, 100);
                            }, 80))
                        : k || c(a, l, p);
                    }
                  } else f('VIDEO_NOTSTARTED');
                }, 700);
              }
              'undefined' !== typeof a.srcObject
                ? (a.srcObject = l)
                : ((a.src = window.URL.createObjectURL(l)), (a.videoStream = l));
              S.Ja(a);
              a.addEventListener(
                'loadeddata',
                function () {
                  var p = a.play();
                  S.Ja(a);
                  'undefined' === typeof p
                    ? n()
                    : p
                        .then(function () {
                          n();
                        })
                        .catch(function () {
                          f('VIDEO_PLAYPROMISEREJECTED');
                        });
                },
                !1
              );
            })
            .catch(function (l) {
              f(l);
            });
        },
        get: function (a, c, d, e) {
          if (!a) return d && d('VIDEO_NOTPROVIDED'), !1;
          if (!S.Gb()) return d && d('MEDIASTREAMAPI_NOTFOUND'), !1;
          if (e && e.video) {
            if (S.Eb()) {
              var f = S.gd();
              (12 > f[0] || (12 === f[0] && 2 > f[1])) && S.Td(e);
            }
            e.video.width &&
              e.video.width.ideal &&
              (a.style.width = e.video.width.ideal + 'px');
            e.video.height &&
              e.video.height.ideal &&
              (a.style.height = e.video.height.ideal + 'px');
          }
          S.sa(a, 'autoplay');
          S.sa(a, 'playsinline');
          e && e.audio ? (a.volume = 0) : S.sa(a, 'muted');
          S.Ub(
            a,
            c,
            function () {
              function k(n) {
                if (0 === n.length) d('INVALID_FALLBACKCONSTRAINTS');
                else {
                  var p = n.shift();
                  S.Ub(
                    a,
                    c,
                    function () {
                      k(n);
                    },
                    p
                  );
                }
              }
              var l = S.Sc(e);
              k(l);
            },
            e
          );
        },
        ld: function (a) {
          if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices)
            return a(!1, 'NOTSUPPORTED'), !1;
          navigator.mediaDevices
            .enumerateDevices()
            .then(function (c) {
              (c = c.filter(function (d) {
                return (
                  d.kind &&
                  -1 !== d.kind.toLowerCase().indexOf('video') &&
                  d.label &&
                  d.deviceId
                );
              })) &&
              c.length &&
              0 < c.length
                ? a(c, !1)
                : a(!1, 'NODEVICESFOUND');
            })
            .catch(function () {
              a(!1, 'PROMISEREJECTED');
            });
        },
        fe: function (a, c, d) {
          var e = {};
          e[c] = d;
          c = [];
          c.push(e);
          a.applyConstraints({ advanced: c }).catch(function () {});
        }
      },
      I = {
        save: 'NNC.json',
        Ab: 0,
        Dc: 25,
        Ta: 0.2,
        ea: [45, 55],
        ae: 1 / 3.5,
        za: [2, 7],
        Hd: {
          minScale: 0.15,
          maxScale: 0.6,
          borderWidth: 0.2,
          borderHeight: 0.2,
          nStepsX: 6,
          nStepsY: 5,
          nStepsScale: 3,
          nDetectsPerLoop: -1
        },
        Ud: 50,
        cc: 0.5,
        mb: 0.4,
        zd: 8,
        xc: 0.8,
        wc: 1,
        Sd: {
          translationFactorRange: [0.0015, 0.005],
          rotationFactorRange: [0.003, 0.02],
          qualityFactorRange: [0.9, 0.98],
          alphaRange: [0.05, 1]
        },
        ya: [0.65, 1, 0.262],
        ca: [0.092, 0.092, 0.3],
        Ac: 0.2,
        Cc: 2,
        Bc: 0.1,
        Ad: 8,
        ic: 1,
        cd: db.Ia.bind(null, 0.3, 0.7),
        Yd: 20
      },
      ha = {
        facingMode: 'user',
        idealWidth: 800,
        idealHeight: 600,
        minWidth: 480,
        maxWidth: 1280,
        minHeight: 480,
        maxHeight: 1280,
        rotate: 0,
        flipX: !1
      },
      ba = { nb: -3, wd: -1, error: -2, play: 1, pause: 2 },
      ea = ba.nb,
      u = null,
      dc = {
        jb: !1,
        element: null,
        aa: null,
        ba: null,
        v: [0, 0],
        C: [0.5, 0.5],
        m: [0.5, 0, 0, 0.5],
        Oa: 0,
        qa: null
      },
      H = null,
      ec = {
        pa: null,
        Ca: null,
        xb: './',
        la: null,
        V: null,
        Aa: I.Ab,
        nc: I.Ab,
        Ha: !1,
        ga: !1
      },
      za = null,
      X = null,
      sa = null;
    var vb = (Oa = Ya = Xa = Na = Ma = Za = Pa = mb = lb = kb = jb = bb = ab = $a = 0);
    var V = null,
      fc = { M: 0, O: 0, v: [0, 0], Ga: null },
      U = { Qa: null, buffer: null, ca: null, ya: null, R: I.ic, ta: null },
      Ua = null,
      ma = null,
      cb = null,
      Qa = null,
      E = { i: 1, Z: 0, L: null, Zb: !1, bc: 0, ob: 0 },
      P = {
        ra: 0,
        timestamp: 0,
        fc: 0,
        hc: 0,
        G: I.za[0],
        ec: I.za[0],
        jc: 0,
        ia: 0,
        ke: 1
      },
      rb = [],
      sb = [],
      Kb = {
        VERSION: '1.2.7',
        init: function (a) {
          function c() {
            ea !== ba.error &&
              2 === ++e &&
              (Ha(),
              Gb(),
              Ga(),
              H.pa &&
                (H.pa(!1, {
                  GL: b,
                  canvasElement: H.V,
                  videoTexture: u.ba.get(),
                  maxFacesDetected: E.i,
                  videoElement: u.element
                }),
                Cb()),
              pb());
          }
          if (ea !== ba.nb)
            return a.callbackReady && a.callbackReady('ALREADY_INITIALIZED'), !1;
          ea = ba.wd;
          u = Object.assign({}, dc);
          H = Object.assign({}, ec);
          V = Object.assign({}, fc);
          E.L = [0];
          U.ca = I.ca.slice(0);
          U.ya = I.ya.slice(0);
          a.callbackReady && (H.pa = a.callbackReady);
          a.callbackTrack && (H.Ca = a.callbackTrack);
          a.nExpressions && (U.R = a.nExpressions);
          a.expressionsEasings && (U.ta = a.expressionsEasings);
          'undefined' !== typeof a.animateDelay && (H.Aa = a.animateDelay);
          'undefined' !== typeof a.NNCpath && (H.xb = a.NNCpath);
          'undefined' !== typeof a.NNC && (H.la = a.NNC);
          'undefined' !== typeof a.maxFacesDetected &&
            (E.i = Math.max(1, a.maxFacesDetected));
          'undefined' !== typeof a.followZRot && (H.ga = a.followZRot ? !0 : !1);
          if (E.i > I.zd) return Da('MAXFACES_TOOHIGH'), !1;
          if (!a.canvasId && !a.canvas) return Da('NO_CANVASID'), !1;
          H.V = a.canvas ? a.canvas : document.getElementById(a.canvasId);
          if (!H.V) return Da('INVALID_CANVASID'), !1;
          V.M = H.V.width;
          V.O = H.V.height;
          if (!V.M || !V.O) return Da('INVALID_CANVASDIMENSIONS'), !1;
          for (var d = 0; d < E.i; ++d) rb.push(new Float32Array(I.Ad)), sb.push(0);
          X = Object.create(I.Hd);
          a.scanSettings && Ra(X, a.scanSettings);
          sa = Object.create(I.Sd);
          a.stabilizationSettings && Ra(sa, a.stabilizationSettings);
          var e = 0;
          a.videoSettings && a.videoSettings.videoElement
            ? eb(a.videoSettings.videoElement, c)
            : (a.videoSettings && Ra(ha, a.videoSettings),
              Hb(a.onWebcamAsk, a.onWebcamGet, function (f) {
                eb(f, c);
              }));
          Sb(function (f) {
            if (!Tb()) return !1;
            za = new zb({});
            za.Jd(f.layers);
            za.Ld({ lc: 'gpuRawAvg', Cd: Vb });
            t.zc([
              {
                id: 's48',
                name: '_',
                da:
                  'attribute vec2 a0;uniform mat2 u33;varying vec2 vv0;void main(){gl_Position=vec4(a0,0.,1.),vv0=vec2(.5,.5)+u33*a0;}',
                Ba: ['a0'],
                ma: [2],
                a:
                  'uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}',
                c: ['u1', 'u33'],
                precision: 'lowp'
              },
              {
                id: 's49',
                name: '_',
                a:
                  'uniform sampler2D u1;varying vec2 vv0;void main(){gl_FragColor=texture2D(u1,vv0);}',
                da:
                  'attribute vec2 a0;uniform sampler2D u34;uniform vec2 u35;uniform float u36,u37;varying vec2 vv0;void main(){vec4 a=texture2D(u34,vec2(.17,u36));vec2 d=a.gb,e=a.a*u35;float b=cos(u37),c=sin(u37);vec2 g=mat2(b,c,-c,b)*a0;vv0=d+g*.5*e,gl_Position=vec4(a0,0.,1.);}',
                Ba: ['a0'],
                ma: [2],
                c: ['u1', 'u34', 'u35', 'u36', 'u37'],
                precision: 'lowp'
              },
              {
                id: 's50',
                name: '_',
                a:
                  'uniform sampler2D u38,u34;uniform vec3 u39,u40;uniform float u41,u42,u43,u36,u44,u37,u45;const vec4 e=vec4(.25,.25,.25,.25);void main(){vec4 g=texture2D(u38,vec2(.625,.625)),h=texture2D(u38,vec2(.875,.625)),a=texture2D(u34,vec2(.17,u36));float b=dot(g,e),i=dot(h,e);bool j=b>u42&&b>i+u43;j?a.r=2.:a.r>u41?a.r=0.:a.r>1.9?a.r+=1.:0.,a.r*=u44;if(a.r<.9)a=vec4(1.,u39);else{a.r*=step(1.9,a.r);float k=dot(e,texture2D(u38,vec2(.875,.875))),l=dot(e,texture2D(u38,vec2(.125,.625))),m=dot(e,texture2D(u38,vec2(.375,.625))),c=cos(u37),d=sin(u37);vec2 f=mat2(c,d*u45,-d/u45,c)*vec2(k,l);a.gba+=vec3(f,m)*u40*a.a;}gl_FragColor=a;}',
                da: 'attribute vec2 a0;void main(){gl_Position=vec4(a0,0.,1.);}',
                c: 'u38 u34 u39 u41 u40 u44 u37 u45 u42 u43 u36'.split(' ')
              },
              {
                id: 's51',
                name: '_',
                da: 'attribute vec2 a0;void main(){gl_Position=vec4(a0,0.,1.);}',
                a:
                  'uniform sampler2D u38;const vec4 e=vec4(.25,.25,.25,.25);const vec3 g=vec3(.5,.5,.5);void main(){float a=dot(e,texture2D(u38,vec2(.125,.875))),b=dot(e,texture2D(u38,vec2(.375,.875))),c=dot(e,texture2D(u38,vec2(.625,.875))),d=dot(e,texture2D(u38,vec2(.625,.625)));vec3 f=vec3(a,b,c)*.5+g;gl_FragColor=vec4(f,d);}',
                c: ['u38']
              },
              {
                id: 's52',
                name: '_',
                da: 'attribute vec2 a0;void main(){gl_Position=vec4(a0,0.,1.);}',
                a:
                  'uniform sampler2D u38;const vec4 e=vec4(.25,.25,.25,.25);void main(){float a=dot(e,texture2D(u38,vec2(.375,.375))),b=dot(e,texture2D(u38,vec2(.625,.375))),c=dot(e,texture2D(u38,vec2(.875,.375))),d=dot(e,texture2D(u38,vec2(.125,.125)));gl_FragColor=vec4(a,b,c,d);}',
                c: ['u38']
              },
              {
                id: 's47',
                name: '_',
                a:
                  'uniform sampler2D u34;uniform vec2 u46;uniform float u47;varying vec2 vv0;void main(){float g=step(.5,mod(gl_FragCoord.y+1.5,2.)),c=step(.33,vv0.x);vec4 a=texture2D(u34,vv0+u46);a.a=mix(a.a*u47,a.a,c);vec4 d=floor(255.*a),f=255.*(255.*a-d),b=mix(d,f,g)/255.;b.x=mix(step(a.x,1.5),b.x,c),gl_FragColor=b;}',
                c: ['u34', 'u47', 'u46']
              }
            ]);
            Qb();
            ub();
            tb();
            c();
          });
          return !0;
        },
        destroy: function () {
          return new Promise(function (a) {
            Kb.toggle_pause(!0, !0).finally(function () {
              za && za.h();
              Aa.h();
              za = ma = Ua = null;
              rb.splice(0);
              sb.splice(0);
              ea = ba.nb;
              a();
            });
          });
        },
        toggle_pause: function (a, c) {
          if (!ob()) return Promise.reject();
          c = c ? S.tc(u.element, !a, u.qa) : Promise.resolve();
          a ? Bb() : pb();
          return c;
        },
        update_videoSettings: function (a) {
          Bb();
          return new Promise(function (c) {
            S.tc(u.element, !1, u.qa).then(function () {
              Ra(ha, a);
              Hb(null, null, function (d) {
                eb(d, function () {
                  Ha();
                  Ga();
                  pb();
                  c();
                });
              });
            });
          });
        },
        toggle_slow: function (a) {
          ob() &&
            ea === ba.play &&
            (a && !H.Ha
              ? ((H.nc = H.Aa),
                (X.nDetectsPerLoop = 1),
                this.set_animateDelay(100),
                (H.Ha = !0))
              : !a &&
                H.Ha &&
                ((X.nDetectsPerLoop = -1), this.set_animateDelay(H.nc), (H.Ha = !1)));
        },
        set_animateDelay: function (a) {
          H.Aa = a;
        },
        resize: function () {
          var a = H.V.width,
            c = H.V.height;
          if (!wb() && a === V.M && c === V.O) return !1;
          V.M = a;
          V.O = c;
          ub();
          tb();
          Ha();
          Ga();
          u.ba && u.ba.resize(V.M, V.O);
          return !0;
        },
        set_inputTexture: function (a, c, d) {
          u.v[0] = c;
          u.v[1] = d;
          u.jb = !0;
          Ha();
          Cb();
          Ga();
          t.set('s48');
          u.ba.J();
          b.activeTexture(b.TEXTURE0);
          b.bindTexture(b.TEXTURE_2D, a);
          Q.g(!0, !0);
        },
        reset_inputTexture: function () {
          wb();
          u.jb = !1;
          Ha();
          Ga();
        },
        get_videoDevices: function (a) {
          return S.ld(a);
        },
        set_scanSettings: function (a) {
          Ra(X, a);
          ub();
          tb();
        },
        set_stabilizationSettings: function (a) {
          Ra(sa, a);
        },
        set_videoOrientation: function (a, c) {
          ob() && ((ha.flipX = c), (ha.rotate = a), Ha(), Ga());
        },
        update_videoElement: function (a, c) {
          eb(a ? a : u.element, function () {
            Gb();
            Ha();
            Ga();
            c && c();
          });
        }
      };
    return Kb;
  };
  window.JEEFACEFILTERAPI = window.JEEFACEFILTERAPIGEN();
  return JEEFACEFILTERAPI;
})();

/* threejs/v97/three.js */
!(function (t, e) {
  'object' == typeof exports && 'undefined' != typeof module
    ? e(exports)
    : 'function' == typeof define && define.amd
    ? define(['exports'], e)
    : e((t.THREE = {}));
})(this, function (t) {
  'use strict';
  function e() {}
  void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
    void 0 === Number.isInteger &&
      (Number.isInteger = function (t) {
        return 'number' == typeof t && isFinite(t) && Math.floor(t) === t;
      }),
    void 0 === Math.sign &&
      (Math.sign = function (t) {
        return t < 0 ? -1 : 0 < t ? 1 : +t;
      }),
    'name' in Function.prototype == !1 &&
      Object.defineProperty(Function.prototype, 'name', {
        get: function () {
          return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
        }
      }),
    void 0 === Object.assign &&
      (Object.assign = function (t) {
        if (null == t) throw new TypeError('Cannot convert undefined or null to object');
        for (var e = Object(t), i = 1; i < arguments.length; i++) {
          var n = arguments[i];
          if (null != n)
            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
        }
        return e;
      }),
    Object.assign(e.prototype, {
      addEventListener: function (t, e) {
        void 0 === this._listeners && (this._listeners = {});
        var i = this._listeners;
        void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e);
      },
      hasEventListener: function (t, e) {
        if (void 0 === this._listeners) return !1;
        var i = this._listeners;
        return void 0 !== i[t] && -1 !== i[t].indexOf(e);
      },
      removeEventListener: function (t, e) {
        if (void 0 !== this._listeners) {
          var i = this._listeners[t];
          if (void 0 !== i) {
            var n = i.indexOf(e);
            -1 !== n && i.splice(n, 1);
          }
        }
      },
      dispatchEvent: function (t) {
        if (void 0 !== this._listeners) {
          var e = this._listeners[t.type];
          if (void 0 !== e) {
            t.target = this;
            for (var i = e.slice(0), n = 0, r = i.length; n < r; n++) i[n].call(this, t);
          }
        }
      }
    });
  var i,
    n,
    l,
    u,
    r,
    a,
    o,
    s,
    c,
    h,
    p,
    d,
    f,
    m,
    g,
    v,
    y,
    x,
    b,
    _,
    w,
    X = 0,
    q = 1,
    Y = 2,
    G = 1,
    H = 2,
    D = 0,
    wt = 1,
    J = 2,
    M = 0,
    E = 2,
    Z = 0,
    Q = 1,
    K = 2,
    $ = 3,
    tt = 4,
    et = 5,
    it = 100,
    T = 101,
    S = 102,
    A = 103,
    L = 104,
    R = 200,
    P = 201,
    C = 202,
    O = 203,
    I = 204,
    N = 205,
    U = 206,
    B = 207,
    F = 208,
    z = 209,
    V = 210,
    nt = 0,
    rt = 1,
    at = 2,
    ot = 3,
    st = 4,
    ct = 5,
    ht = 6,
    lt = 7,
    k = 0,
    j = 1,
    W = 2,
    ut = 0,
    Mt = 1,
    pt = 2,
    dt = 3,
    ft = 4,
    mt = 301,
    gt = 302,
    vt = 303,
    yt = 304,
    xt = 305,
    bt = 306,
    _t = 307,
    Et = 1e3,
    Tt = 1001,
    St = 1002,
    At = 1003,
    Lt = 1004,
    Rt = 1005,
    Pt = 1006,
    Ct = 1007,
    Ot = 1008,
    It = 1009,
    Nt = 1010,
    Dt = 1011,
    Ut = 1012,
    Bt = 1013,
    Ft = 1014,
    zt = 1015,
    Gt = 1016,
    Ht = 1017,
    Vt = 1018,
    kt = 1019,
    jt = 1020,
    Wt = 1021,
    Xt = 1022,
    qt = 1023,
    Yt = 1024,
    Jt = 1025,
    Zt = qt,
    Qt = 1026,
    Kt = 1027,
    $t = 1028,
    te = 33776,
    ee = 33777,
    ie = 33778,
    ne = 33779,
    re = 35840,
    ae = 35841,
    oe = 35842,
    se = 35843,
    ce = 36196,
    he = 37808,
    le = 37809,
    ue = 37810,
    pe = 37811,
    de = 37812,
    fe = 37813,
    me = 37814,
    ge = 37815,
    ve = 37816,
    ye = 37817,
    xe = 37818,
    be = 37819,
    _e = 37820,
    we = 37821,
    Me = 2300,
    Ee = 2301,
    Te = 2400,
    Se = 2401,
    Ae = 2402,
    Le = 0,
    Re = 3e3,
    Pe = 3001,
    Ce = 3007,
    Oe = 3002,
    Ie = 3004,
    Ne = 3005,
    De = 3006,
    Ue = 3200,
    Be = 3201,
    Fe = 0,
    ze = 1,
    Ge = {
      DEG2RAD: Math.PI / 180,
      RAD2DEG: 180 / Math.PI,
      generateUUID: (function () {
        for (var r = [], t = 0; t < 256; t++) r[t] = (t < 16 ? '0' : '') + t.toString(16);
        return function () {
          var t = (4294967295 * Math.random()) | 0,
            e = (4294967295 * Math.random()) | 0,
            i = (4294967295 * Math.random()) | 0,
            n = (4294967295 * Math.random()) | 0;
          return (
            r[255 & t] +
            r[(t >> 8) & 255] +
            r[(t >> 16) & 255] +
            r[(t >> 24) & 255] +
            '-' +
            r[255 & e] +
            r[(e >> 8) & 255] +
            '-' +
            r[((e >> 16) & 15) | 64] +
            r[(e >> 24) & 255] +
            '-' +
            r[(63 & i) | 128] +
            r[(i >> 8) & 255] +
            '-' +
            r[(i >> 16) & 255] +
            r[(i >> 24) & 255] +
            r[255 & n] +
            r[(n >> 8) & 255] +
            r[(n >> 16) & 255] +
            r[(n >> 24) & 255]
          ).toUpperCase();
        };
      })(),
      clamp: function (t, e, i) {
        return Math.max(e, Math.min(i, t));
      },
      euclideanModulo: function (t, e) {
        return ((t % e) + e) % e;
      },
      mapLinear: function (t, e, i, n, r) {
        return n + ((t - e) * (r - n)) / (i - e);
      },
      lerp: function (t, e, i) {
        return (1 - i) * t + i * e;
      },
      smoothstep: function (t, e, i) {
        return t <= e ? 0 : i <= t ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t);
      },
      smootherstep: function (t, e, i) {
        return t <= e
          ? 0
          : i <= t
          ? 1
          : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10);
      },
      randInt: function (t, e) {
        return t + Math.floor(Math.random() * (e - t + 1));
      },
      randFloat: function (t, e) {
        return t + Math.random() * (e - t);
      },
      randFloatSpread: function (t) {
        return t * (0.5 - Math.random());
      },
      degToRad: function (t) {
        return t * Ge.DEG2RAD;
      },
      radToDeg: function (t) {
        return t * Ge.RAD2DEG;
      },
      isPowerOfTwo: function (t) {
        return 0 == (t & (t - 1)) && 0 !== t;
      },
      ceilPowerOfTwo: function (t) {
        return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2));
      },
      floorPowerOfTwo: function (t) {
        return Math.pow(2, Math.floor(Math.log(t) / Math.LN2));
      }
    };
  function He(t, e) {
    (this.x = t || 0), (this.y = e || 0);
  }
  function Ve() {
    (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      0 < arguments.length &&
        console.error(
          'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.'
        );
  }
  function ke(t, e, i, n) {
    (this._x = t || 0),
      (this._y = e || 0),
      (this._z = i || 0),
      (this._w = void 0 !== n ? n : 1);
  }
  function je(t, e, i) {
    (this.x = t || 0), (this.y = e || 0), (this.z = i || 0);
  }
  function We() {
    (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      0 < arguments.length &&
        console.error(
          'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.'
        );
  }
  Object.defineProperties(He.prototype, {
    width: {
      get: function () {
        return this.x;
      },
      set: function (t) {
        this.x = t;
      }
    },
    height: {
      get: function () {
        return this.y;
      },
      set: function (t) {
        this.y = t;
      }
    }
  }),
    Object.assign(He.prototype, {
      isVector2: !0,
      set: function (t, e) {
        return (this.x = t), (this.y = e), this;
      },
      setScalar: function (t) {
        return (this.x = t), (this.y = t), this;
      },
      setX: function (t) {
        return (this.x = t), this;
      },
      setY: function (t) {
        return (this.y = t), this;
      },
      setComponent: function (t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          default:
            throw new Error('index is out of range: ' + t);
        }
        return this;
      },
      getComponent: function (t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error('index is out of range: ' + t);
        }
      },
      clone: function () {
        return new this.constructor(this.x, this.y);
      },
      copy: function (t) {
        return (this.x = t.x), (this.y = t.y), this;
      },
      add: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
            ),
            this.addVectors(t, e))
          : ((this.x += t.x), (this.y += t.y), this);
      },
      addScalar: function (t) {
        return (this.x += t), (this.y += t), this;
      },
      addVectors: function (t, e) {
        return (this.x = t.x + e.x), (this.y = t.y + e.y), this;
      },
      addScaledVector: function (t, e) {
        return (this.x += t.x * e), (this.y += t.y * e), this;
      },
      sub: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
            ),
            this.subVectors(t, e))
          : ((this.x -= t.x), (this.y -= t.y), this);
      },
      subScalar: function (t) {
        return (this.x -= t), (this.y -= t), this;
      },
      subVectors: function (t, e) {
        return (this.x = t.x - e.x), (this.y = t.y - e.y), this;
      },
      multiply: function (t) {
        return (this.x *= t.x), (this.y *= t.y), this;
      },
      multiplyScalar: function (t) {
        return (this.x *= t), (this.y *= t), this;
      },
      divide: function (t) {
        return (this.x /= t.x), (this.y /= t.y), this;
      },
      divideScalar: function (t) {
        return this.multiplyScalar(1 / t);
      },
      applyMatrix3: function (t) {
        var e = this.x,
          i = this.y,
          n = t.elements;
        return (
          (this.x = n[0] * e + n[3] * i + n[6]),
          (this.y = n[1] * e + n[4] * i + n[7]),
          this
        );
      },
      min: function (t) {
        return (this.x = Math.min(this.x, t.x)), (this.y = Math.min(this.y, t.y)), this;
      },
      max: function (t) {
        return (this.x = Math.max(this.x, t.x)), (this.y = Math.max(this.y, t.y)), this;
      },
      clamp: function (t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          this
        );
      },
      clampScalar:
        ((i = new He()),
        (n = new He()),
        function (t, e) {
          return i.set(t, t), n.set(e, e), this.clamp(i, n);
        }),
      clampLength: function (t, e) {
        var i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
      },
      floor: function () {
        return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
      },
      ceil: function () {
        return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
      },
      round: function () {
        return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
      },
      roundToZero: function () {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          this
        );
      },
      negate: function () {
        return (this.x = -this.x), (this.y = -this.y), this;
      },
      dot: function (t) {
        return this.x * t.x + this.y * t.y;
      },
      cross: function (t) {
        return this.x * t.y - this.y * t.x;
      },
      lengthSq: function () {
        return this.x * this.x + this.y * this.y;
      },
      length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      },
      manhattanLength: function () {
        return Math.abs(this.x) + Math.abs(this.y);
      },
      normalize: function () {
        return this.divideScalar(this.length() || 1);
      },
      angle: function () {
        var t = Math.atan2(this.y, this.x);
        return t < 0 && (t += 2 * Math.PI), t;
      },
      distanceTo: function (t) {
        return Math.sqrt(this.distanceToSquared(t));
      },
      distanceToSquared: function (t) {
        var e = this.x - t.x,
          i = this.y - t.y;
        return e * e + i * i;
      },
      manhattanDistanceTo: function (t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y);
      },
      setLength: function (t) {
        return this.normalize().multiplyScalar(t);
      },
      lerp: function (t, e) {
        return (this.x += (t.x - this.x) * e), (this.y += (t.y - this.y) * e), this;
      },
      lerpVectors: function (t, e, i) {
        return this.subVectors(e, t).multiplyScalar(i).add(t);
      },
      equals: function (t) {
        return t.x === this.x && t.y === this.y;
      },
      fromArray: function (t, e) {
        return void 0 === e && (e = 0), (this.x = t[e]), (this.y = t[e + 1]), this;
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this.x),
          (t[e + 1] = this.y),
          t
        );
      },
      fromBufferAttribute: function (t, e, i) {
        return (
          void 0 !== i &&
            console.warn(
              'THREE.Vector2: offset has been removed from .fromBufferAttribute().'
            ),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          this
        );
      },
      rotateAround: function (t, e) {
        var i = Math.cos(e),
          n = Math.sin(e),
          r = this.x - t.x,
          a = this.y - t.y;
        return (this.x = r * i - a * n + t.x), (this.y = r * n + a * i + t.y), this;
      }
    }),
    Object.assign(Ve.prototype, {
      isMatrix4: !0,
      set: function (t, e, i, n, r, a, o, s, c, h, l, u, p, d, f, m) {
        var g = this.elements;
        return (
          (g[0] = t),
          (g[4] = e),
          (g[8] = i),
          (g[12] = n),
          (g[1] = r),
          (g[5] = a),
          (g[9] = o),
          (g[13] = s),
          (g[2] = c),
          (g[6] = h),
          (g[10] = l),
          (g[14] = u),
          (g[3] = p),
          (g[7] = d),
          (g[11] = f),
          (g[15] = m),
          this
        );
      },
      identity: function () {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      },
      clone: function () {
        return new Ve().fromArray(this.elements);
      },
      copy: function (t) {
        var e = this.elements,
          i = t.elements;
        return (
          (e[0] = i[0]),
          (e[1] = i[1]),
          (e[2] = i[2]),
          (e[3] = i[3]),
          (e[4] = i[4]),
          (e[5] = i[5]),
          (e[6] = i[6]),
          (e[7] = i[7]),
          (e[8] = i[8]),
          (e[9] = i[9]),
          (e[10] = i[10]),
          (e[11] = i[11]),
          (e[12] = i[12]),
          (e[13] = i[13]),
          (e[14] = i[14]),
          (e[15] = i[15]),
          this
        );
      },
      copyPosition: function (t) {
        var e = this.elements,
          i = t.elements;
        return (e[12] = i[12]), (e[13] = i[13]), (e[14] = i[14]), this;
      },
      extractBasis: function (t, e, i) {
        return (
          t.setFromMatrixColumn(this, 0),
          e.setFromMatrixColumn(this, 1),
          i.setFromMatrixColumn(this, 2),
          this
        );
      },
      makeBasis: function (t, e, i) {
        return (
          this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
        );
      },
      extractRotation:
        ((p = new je()),
        function (t) {
          var e = this.elements,
            i = t.elements,
            n = 1 / p.setFromMatrixColumn(t, 0).length(),
            r = 1 / p.setFromMatrixColumn(t, 1).length(),
            a = 1 / p.setFromMatrixColumn(t, 2).length();
          return (
            (e[0] = i[0] * n),
            (e[1] = i[1] * n),
            (e[2] = i[2] * n),
            (e[3] = 0),
            (e[4] = i[4] * r),
            (e[5] = i[5] * r),
            (e[6] = i[6] * r),
            (e[7] = 0),
            (e[8] = i[8] * a),
            (e[9] = i[9] * a),
            (e[10] = i[10] * a),
            (e[11] = 0),
            (e[12] = 0),
            (e[13] = 0),
            (e[14] = 0),
            (e[15] = 1),
            this
          );
        }),
      makeRotationFromEuler: function (t) {
        (t && t.isEuler) ||
          console.error(
            'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.'
          );
        var e = this.elements,
          i = t.x,
          n = t.y,
          r = t.z,
          a = Math.cos(i),
          o = Math.sin(i),
          s = Math.cos(n),
          c = Math.sin(n),
          h = Math.cos(r),
          l = Math.sin(r);
        if ('XYZ' === t.order) {
          var u = a * h,
            p = a * l,
            d = o * h,
            f = o * l;
          (e[0] = s * h),
            (e[4] = -s * l),
            (e[8] = c),
            (e[1] = p + d * c),
            (e[5] = u - f * c),
            (e[9] = -o * s),
            (e[2] = f - u * c),
            (e[6] = d + p * c),
            (e[10] = a * s);
        } else if ('YXZ' === t.order) {
          var m = s * h,
            g = s * l,
            v = c * h,
            y = c * l;
          (e[0] = m + y * o),
            (e[4] = v * o - g),
            (e[8] = a * c),
            (e[1] = a * l),
            (e[5] = a * h),
            (e[9] = -o),
            (e[2] = g * o - v),
            (e[6] = y + m * o),
            (e[10] = a * s);
        } else if ('ZXY' === t.order) {
          (m = s * h), (g = s * l), (v = c * h), (y = c * l);
          (e[0] = m - y * o),
            (e[4] = -a * l),
            (e[8] = v + g * o),
            (e[1] = g + v * o),
            (e[5] = a * h),
            (e[9] = y - m * o),
            (e[2] = -a * c),
            (e[6] = o),
            (e[10] = a * s);
        } else if ('ZYX' === t.order) {
          (u = a * h), (p = a * l), (d = o * h), (f = o * l);
          (e[0] = s * h),
            (e[4] = d * c - p),
            (e[8] = u * c + f),
            (e[1] = s * l),
            (e[5] = f * c + u),
            (e[9] = p * c - d),
            (e[2] = -c),
            (e[6] = o * s),
            (e[10] = a * s);
        } else if ('YZX' === t.order) {
          var x = a * s,
            b = a * c,
            _ = o * s,
            w = o * c;
          (e[0] = s * h),
            (e[4] = w - x * l),
            (e[8] = _ * l + b),
            (e[1] = l),
            (e[5] = a * h),
            (e[9] = -o * h),
            (e[2] = -c * h),
            (e[6] = b * l + _),
            (e[10] = x - w * l);
        } else if ('XZY' === t.order) {
          (x = a * s), (b = a * c), (_ = o * s), (w = o * c);
          (e[0] = s * h),
            (e[4] = -l),
            (e[8] = c * h),
            (e[1] = x * l + w),
            (e[5] = a * h),
            (e[9] = b * l - _),
            (e[2] = _ * l - b),
            (e[6] = o * h),
            (e[10] = w * l + x);
        }
        return (
          (e[3] = 0),
          (e[7] = 0),
          (e[11] = 0),
          (e[12] = 0),
          (e[13] = 0),
          (e[14] = 0),
          (e[15] = 1),
          this
        );
      },
      makeRotationFromQuaternion:
        ((c = new je(0, 0, 0)),
        (h = new je(1, 1, 1)),
        function (t) {
          return this.compose(c, t, h);
        }),
      lookAt:
        ((a = new je()),
        (o = new je()),
        (s = new je()),
        function (t, e, i) {
          var n = this.elements;
          return (
            s.subVectors(t, e),
            0 === s.lengthSq() && (s.z = 1),
            s.normalize(),
            a.crossVectors(i, s),
            0 === a.lengthSq() &&
              (1 === Math.abs(i.z) ? (s.x += 1e-4) : (s.z += 1e-4),
              s.normalize(),
              a.crossVectors(i, s)),
            a.normalize(),
            o.crossVectors(s, a),
            (n[0] = a.x),
            (n[4] = o.x),
            (n[8] = s.x),
            (n[1] = a.y),
            (n[5] = o.y),
            (n[9] = s.y),
            (n[2] = a.z),
            (n[6] = o.z),
            (n[10] = s.z),
            this
          );
        }),
      multiply: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.'
            ),
            this.multiplyMatrices(t, e))
          : this.multiplyMatrices(this, t);
      },
      premultiply: function (t) {
        return this.multiplyMatrices(t, this);
      },
      multiplyMatrices: function (t, e) {
        var i = t.elements,
          n = e.elements,
          r = this.elements,
          a = i[0],
          o = i[4],
          s = i[8],
          c = i[12],
          h = i[1],
          l = i[5],
          u = i[9],
          p = i[13],
          d = i[2],
          f = i[6],
          m = i[10],
          g = i[14],
          v = i[3],
          y = i[7],
          x = i[11],
          b = i[15],
          _ = n[0],
          w = n[4],
          M = n[8],
          E = n[12],
          T = n[1],
          S = n[5],
          A = n[9],
          L = n[13],
          R = n[2],
          P = n[6],
          C = n[10],
          O = n[14],
          I = n[3],
          N = n[7],
          D = n[11],
          U = n[15];
        return (
          (r[0] = a * _ + o * T + s * R + c * I),
          (r[4] = a * w + o * S + s * P + c * N),
          (r[8] = a * M + o * A + s * C + c * D),
          (r[12] = a * E + o * L + s * O + c * U),
          (r[1] = h * _ + l * T + u * R + p * I),
          (r[5] = h * w + l * S + u * P + p * N),
          (r[9] = h * M + l * A + u * C + p * D),
          (r[13] = h * E + l * L + u * O + p * U),
          (r[2] = d * _ + f * T + m * R + g * I),
          (r[6] = d * w + f * S + m * P + g * N),
          (r[10] = d * M + f * A + m * C + g * D),
          (r[14] = d * E + f * L + m * O + g * U),
          (r[3] = v * _ + y * T + x * R + b * I),
          (r[7] = v * w + y * S + x * P + b * N),
          (r[11] = v * M + y * A + x * C + b * D),
          (r[15] = v * E + y * L + x * O + b * U),
          this
        );
      },
      multiplyScalar: function (t) {
        var e = this.elements;
        return (
          (e[0] *= t),
          (e[4] *= t),
          (e[8] *= t),
          (e[12] *= t),
          (e[1] *= t),
          (e[5] *= t),
          (e[9] *= t),
          (e[13] *= t),
          (e[2] *= t),
          (e[6] *= t),
          (e[10] *= t),
          (e[14] *= t),
          (e[3] *= t),
          (e[7] *= t),
          (e[11] *= t),
          (e[15] *= t),
          this
        );
      },
      applyToBufferAttribute:
        ((r = new je()),
        function (t) {
          for (var e = 0, i = t.count; e < i; e++)
            (r.x = t.getX(e)),
              (r.y = t.getY(e)),
              (r.z = t.getZ(e)),
              r.applyMatrix4(this),
              t.setXYZ(e, r.x, r.y, r.z);
          return t;
        }),
      determinant: function () {
        var t = this.elements,
          e = t[0],
          i = t[4],
          n = t[8],
          r = t[12],
          a = t[1],
          o = t[5],
          s = t[9],
          c = t[13],
          h = t[2],
          l = t[6],
          u = t[10],
          p = t[14];
        return (
          t[3] * (r * s * l - n * c * l - r * o * u + i * c * u + n * o * p - i * s * p) +
          t[7] * (e * s * p - e * c * u + r * a * u - n * a * p + n * c * h - r * s * h) +
          t[11] *
            (e * c * l - e * o * p - r * a * l + i * a * p + r * o * h - i * c * h) +
          t[15] * (-n * o * h - e * s * l + e * o * u + n * a * l - i * a * u + i * s * h)
        );
      },
      transpose: function () {
        var t,
          e = this.elements;
        return (
          (t = e[1]),
          (e[1] = e[4]),
          (e[4] = t),
          (t = e[2]),
          (e[2] = e[8]),
          (e[8] = t),
          (t = e[6]),
          (e[6] = e[9]),
          (e[9] = t),
          (t = e[3]),
          (e[3] = e[12]),
          (e[12] = t),
          (t = e[7]),
          (e[7] = e[13]),
          (e[13] = t),
          (t = e[11]),
          (e[11] = e[14]),
          (e[14] = t),
          this
        );
      },
      setPosition: function (t) {
        var e = this.elements;
        return (e[12] = t.x), (e[13] = t.y), (e[14] = t.z), this;
      },
      getInverse: function (t, e) {
        var i = this.elements,
          n = t.elements,
          r = n[0],
          a = n[1],
          o = n[2],
          s = n[3],
          c = n[4],
          h = n[5],
          l = n[6],
          u = n[7],
          p = n[8],
          d = n[9],
          f = n[10],
          m = n[11],
          g = n[12],
          v = n[13],
          y = n[14],
          x = n[15],
          b = d * y * u - v * f * u + v * l * m - h * y * m - d * l * x + h * f * x,
          _ = g * f * u - p * y * u - g * l * m + c * y * m + p * l * x - c * f * x,
          w = p * v * u - g * d * u + g * h * m - c * v * m - p * h * x + c * d * x,
          M = g * d * l - p * v * l - g * h * f + c * v * f + p * h * y - c * d * y,
          E = r * b + a * _ + o * w + s * M;
        if (0 == E) {
          var T = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
          if (!0 === e) throw new Error(T);
          return console.warn(T), this.identity();
        }
        var S = 1 / E;
        return (
          (i[0] = b * S),
          (i[1] =
            (v * f * s - d * y * s - v * o * m + a * y * m + d * o * x - a * f * x) * S),
          (i[2] =
            (h * y * s - v * l * s + v * o * u - a * y * u - h * o * x + a * l * x) * S),
          (i[3] =
            (d * l * s - h * f * s - d * o * u + a * f * u + h * o * m - a * l * m) * S),
          (i[4] = _ * S),
          (i[5] =
            (p * y * s - g * f * s + g * o * m - r * y * m - p * o * x + r * f * x) * S),
          (i[6] =
            (g * l * s - c * y * s - g * o * u + r * y * u + c * o * x - r * l * x) * S),
          (i[7] =
            (c * f * s - p * l * s + p * o * u - r * f * u - c * o * m + r * l * m) * S),
          (i[8] = w * S),
          (i[9] =
            (g * d * s - p * v * s - g * a * m + r * v * m + p * a * x - r * d * x) * S),
          (i[10] =
            (c * v * s - g * h * s + g * a * u - r * v * u - c * a * x + r * h * x) * S),
          (i[11] =
            (p * h * s - c * d * s - p * a * u + r * d * u + c * a * m - r * h * m) * S),
          (i[12] = M * S),
          (i[13] =
            (p * v * o - g * d * o + g * a * f - r * v * f - p * a * y + r * d * y) * S),
          (i[14] =
            (g * h * o - c * v * o - g * a * l + r * v * l + c * a * y - r * h * y) * S),
          (i[15] =
            (c * d * o - p * h * o + p * a * l - r * d * l - c * a * f + r * h * f) * S),
          this
        );
      },
      scale: function (t) {
        var e = this.elements,
          i = t.x,
          n = t.y,
          r = t.z;
        return (
          (e[0] *= i),
          (e[4] *= n),
          (e[8] *= r),
          (e[1] *= i),
          (e[5] *= n),
          (e[9] *= r),
          (e[2] *= i),
          (e[6] *= n),
          (e[10] *= r),
          (e[3] *= i),
          (e[7] *= n),
          (e[11] *= r),
          this
        );
      },
      getMaxScaleOnAxis: function () {
        var t = this.elements,
          e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
          i = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
          n = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
        return Math.sqrt(Math.max(e, i, n));
      },
      makeTranslation: function (t, e, i) {
        return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this;
      },
      makeRotationX: function (t) {
        var e = Math.cos(t),
          i = Math.sin(t);
        return this.set(1, 0, 0, 0, 0, e, -i, 0, 0, i, e, 0, 0, 0, 0, 1), this;
      },
      makeRotationY: function (t) {
        var e = Math.cos(t),
          i = Math.sin(t);
        return this.set(e, 0, i, 0, 0, 1, 0, 0, -i, 0, e, 0, 0, 0, 0, 1), this;
      },
      makeRotationZ: function (t) {
        var e = Math.cos(t),
          i = Math.sin(t);
        return this.set(e, -i, 0, 0, i, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
      },
      makeRotationAxis: function (t, e) {
        var i = Math.cos(e),
          n = Math.sin(e),
          r = 1 - i,
          a = t.x,
          o = t.y,
          s = t.z,
          c = r * a,
          h = r * o;
        return (
          this.set(
            c * a + i,
            c * o - n * s,
            c * s + n * o,
            0,
            c * o + n * s,
            h * o + i,
            h * s - n * a,
            0,
            c * s - n * o,
            h * s + n * a,
            r * s * s + i,
            0,
            0,
            0,
            0,
            1
          ),
          this
        );
      },
      makeScale: function (t, e, i) {
        return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
      },
      makeShear: function (t, e, i) {
        return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this;
      },
      compose: function (t, e, i) {
        var n = this.elements,
          r = e._x,
          a = e._y,
          o = e._z,
          s = e._w,
          c = r + r,
          h = a + a,
          l = o + o,
          u = r * c,
          p = r * h,
          d = r * l,
          f = a * h,
          m = a * l,
          g = o * l,
          v = s * c,
          y = s * h,
          x = s * l,
          b = i.x,
          _ = i.y,
          w = i.z;
        return (
          (n[0] = (1 - (f + g)) * b),
          (n[1] = (p + x) * b),
          (n[2] = (d - y) * b),
          (n[3] = 0),
          (n[4] = (p - x) * _),
          (n[5] = (1 - (u + g)) * _),
          (n[6] = (m + v) * _),
          (n[7] = 0),
          (n[8] = (d + y) * w),
          (n[9] = (m - v) * w),
          (n[10] = (1 - (u + f)) * w),
          (n[11] = 0),
          (n[12] = t.x),
          (n[13] = t.y),
          (n[14] = t.z),
          (n[15] = 1),
          this
        );
      },
      decompose:
        ((l = new je()),
        (u = new Ve()),
        function (t, e, i) {
          var n = this.elements,
            r = l.set(n[0], n[1], n[2]).length(),
            a = l.set(n[4], n[5], n[6]).length(),
            o = l.set(n[8], n[9], n[10]).length();
          this.determinant() < 0 && (r = -r),
            (t.x = n[12]),
            (t.y = n[13]),
            (t.z = n[14]),
            u.copy(this);
          var s = 1 / r,
            c = 1 / a,
            h = 1 / o;
          return (
            (u.elements[0] *= s),
            (u.elements[1] *= s),
            (u.elements[2] *= s),
            (u.elements[4] *= c),
            (u.elements[5] *= c),
            (u.elements[6] *= c),
            (u.elements[8] *= h),
            (u.elements[9] *= h),
            (u.elements[10] *= h),
            e.setFromRotationMatrix(u),
            (i.x = r),
            (i.y = a),
            (i.z = o),
            this
          );
        }),
      makePerspective: function (t, e, i, n, r, a) {
        void 0 === a &&
          console.warn(
            'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.'
          );
        var o = this.elements,
          s = (2 * r) / (e - t),
          c = (2 * r) / (i - n),
          h = (e + t) / (e - t),
          l = (i + n) / (i - n),
          u = -(a + r) / (a - r),
          p = (-2 * a * r) / (a - r);
        return (
          (o[0] = s),
          (o[4] = 0),
          (o[8] = h),
          (o[12] = 0),
          (o[1] = 0),
          (o[5] = c),
          (o[9] = l),
          (o[13] = 0),
          (o[2] = 0),
          (o[6] = 0),
          (o[10] = u),
          (o[14] = p),
          (o[3] = 0),
          (o[7] = 0),
          (o[11] = -1),
          (o[15] = 0),
          this
        );
      },
      makeOrthographic: function (t, e, i, n, r, a) {
        var o = this.elements,
          s = 1 / (e - t),
          c = 1 / (i - n),
          h = 1 / (a - r),
          l = (e + t) * s,
          u = (i + n) * c,
          p = (a + r) * h;
        return (
          (o[0] = 2 * s),
          (o[4] = 0),
          (o[8] = 0),
          (o[12] = -l),
          (o[1] = 0),
          (o[5] = 2 * c),
          (o[9] = 0),
          (o[13] = -u),
          (o[2] = 0),
          (o[6] = 0),
          (o[10] = -2 * h),
          (o[14] = -p),
          (o[3] = 0),
          (o[7] = 0),
          (o[11] = 0),
          (o[15] = 1),
          this
        );
      },
      equals: function (t) {
        for (var e = this.elements, i = t.elements, n = 0; n < 16; n++)
          if (e[n] !== i[n]) return !1;
        return !0;
      },
      fromArray: function (t, e) {
        void 0 === e && (e = 0);
        for (var i = 0; i < 16; i++) this.elements[i] = t[i + e];
        return this;
      },
      toArray: function (t, e) {
        void 0 === t && (t = []), void 0 === e && (e = 0);
        var i = this.elements;
        return (
          (t[e] = i[0]),
          (t[e + 1] = i[1]),
          (t[e + 2] = i[2]),
          (t[e + 3] = i[3]),
          (t[e + 4] = i[4]),
          (t[e + 5] = i[5]),
          (t[e + 6] = i[6]),
          (t[e + 7] = i[7]),
          (t[e + 8] = i[8]),
          (t[e + 9] = i[9]),
          (t[e + 10] = i[10]),
          (t[e + 11] = i[11]),
          (t[e + 12] = i[12]),
          (t[e + 13] = i[13]),
          (t[e + 14] = i[14]),
          (t[e + 15] = i[15]),
          t
        );
      }
    }),
    Object.assign(ke, {
      slerp: function (t, e, i, n) {
        return i.copy(t).slerp(e, n);
      },
      slerpFlat: function (t, e, i, n, r, a, o) {
        var s = i[n + 0],
          c = i[n + 1],
          h = i[n + 2],
          l = i[n + 3],
          u = r[a + 0],
          p = r[a + 1],
          d = r[a + 2],
          f = r[a + 3];
        if (l !== f || s !== u || c !== p || h !== d) {
          var m = 1 - o,
            g = s * u + c * p + h * d + l * f,
            v = 0 <= g ? 1 : -1,
            y = 1 - g * g;
          if (y > Number.EPSILON) {
            var x = Math.sqrt(y),
              b = Math.atan2(x, g * v);
            (m = Math.sin(m * b) / x), (o = Math.sin(o * b) / x);
          }
          var _ = o * v;
          if (
            ((s = s * m + u * _),
            (c = c * m + p * _),
            (h = h * m + d * _),
            (l = l * m + f * _),
            m === 1 - o)
          ) {
            var w = 1 / Math.sqrt(s * s + c * c + h * h + l * l);
            (s *= w), (c *= w), (h *= w), (l *= w);
          }
        }
        (t[e] = s), (t[e + 1] = c), (t[e + 2] = h), (t[e + 3] = l);
      }
    }),
    Object.defineProperties(ke.prototype, {
      x: {
        get: function () {
          return this._x;
        },
        set: function (t) {
          (this._x = t), this.onChangeCallback();
        }
      },
      y: {
        get: function () {
          return this._y;
        },
        set: function (t) {
          (this._y = t), this.onChangeCallback();
        }
      },
      z: {
        get: function () {
          return this._z;
        },
        set: function (t) {
          (this._z = t), this.onChangeCallback();
        }
      },
      w: {
        get: function () {
          return this._w;
        },
        set: function (t) {
          (this._w = t), this.onChangeCallback();
        }
      }
    }),
    Object.assign(ke.prototype, {
      isQuaternion: !0,
      set: function (t, e, i, n) {
        return (
          (this._x = t),
          (this._y = e),
          (this._z = i),
          (this._w = n),
          this.onChangeCallback(),
          this
        );
      },
      clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._w);
      },
      copy: function (t) {
        return (
          (this._x = t.x),
          (this._y = t.y),
          (this._z = t.z),
          (this._w = t.w),
          this.onChangeCallback(),
          this
        );
      },
      setFromEuler: function (t, e) {
        if (!t || !t.isEuler)
          throw new Error(
            'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.'
          );
        var i = t._x,
          n = t._y,
          r = t._z,
          a = t.order,
          o = Math.cos,
          s = Math.sin,
          c = o(i / 2),
          h = o(n / 2),
          l = o(r / 2),
          u = s(i / 2),
          p = s(n / 2),
          d = s(r / 2);
        return (
          'XYZ' === a
            ? ((this._x = u * h * l + c * p * d),
              (this._y = c * p * l - u * h * d),
              (this._z = c * h * d + u * p * l),
              (this._w = c * h * l - u * p * d))
            : 'YXZ' === a
            ? ((this._x = u * h * l + c * p * d),
              (this._y = c * p * l - u * h * d),
              (this._z = c * h * d - u * p * l),
              (this._w = c * h * l + u * p * d))
            : 'ZXY' === a
            ? ((this._x = u * h * l - c * p * d),
              (this._y = c * p * l + u * h * d),
              (this._z = c * h * d + u * p * l),
              (this._w = c * h * l - u * p * d))
            : 'ZYX' === a
            ? ((this._x = u * h * l - c * p * d),
              (this._y = c * p * l + u * h * d),
              (this._z = c * h * d - u * p * l),
              (this._w = c * h * l + u * p * d))
            : 'YZX' === a
            ? ((this._x = u * h * l + c * p * d),
              (this._y = c * p * l + u * h * d),
              (this._z = c * h * d - u * p * l),
              (this._w = c * h * l - u * p * d))
            : 'XZY' === a &&
              ((this._x = u * h * l - c * p * d),
              (this._y = c * p * l - u * h * d),
              (this._z = c * h * d + u * p * l),
              (this._w = c * h * l + u * p * d)),
          !1 !== e && this.onChangeCallback(),
          this
        );
      },
      setFromAxisAngle: function (t, e) {
        var i = e / 2,
          n = Math.sin(i);
        return (
          (this._x = t.x * n),
          (this._y = t.y * n),
          (this._z = t.z * n),
          (this._w = Math.cos(i)),
          this.onChangeCallback(),
          this
        );
      },
      setFromRotationMatrix: function (t) {
        var e,
          i = t.elements,
          n = i[0],
          r = i[4],
          a = i[8],
          o = i[1],
          s = i[5],
          c = i[9],
          h = i[2],
          l = i[6],
          u = i[10],
          p = n + s + u;
        return (
          0 < p
            ? ((e = 0.5 / Math.sqrt(p + 1)),
              (this._w = 0.25 / e),
              (this._x = (l - c) * e),
              (this._y = (a - h) * e),
              (this._z = (o - r) * e))
            : s < n && u < n
            ? ((e = 2 * Math.sqrt(1 + n - s - u)),
              (this._w = (l - c) / e),
              (this._x = 0.25 * e),
              (this._y = (r + o) / e),
              (this._z = (a + h) / e))
            : u < s
            ? ((e = 2 * Math.sqrt(1 + s - n - u)),
              (this._w = (a - h) / e),
              (this._x = (r + o) / e),
              (this._y = 0.25 * e),
              (this._z = (c + l) / e))
            : ((e = 2 * Math.sqrt(1 + u - n - s)),
              (this._w = (o - r) / e),
              (this._x = (a + h) / e),
              (this._y = (c + l) / e),
              (this._z = 0.25 * e)),
          this.onChangeCallback(),
          this
        );
      },
      setFromUnitVectors:
        ((f = new je()),
        function (t, e) {
          return (
            void 0 === f && (f = new je()),
            (d = t.dot(e) + 1) < 1e-6
              ? ((d = 0),
                Math.abs(t.x) > Math.abs(t.z) ? f.set(-t.y, t.x, 0) : f.set(0, -t.z, t.y))
              : f.crossVectors(t, e),
            (this._x = f.x),
            (this._y = f.y),
            (this._z = f.z),
            (this._w = d),
            this.normalize()
          );
        }),
      angleTo: function (t) {
        return 2 * Math.acos(Math.abs(Ge.clamp(this.dot(t), -1, 1)));
      },
      rotateTowards: function (t, e) {
        var i = this.angleTo(t);
        if (0 === i) return this;
        var n = Math.min(1, e / i);
        return this.slerp(t, n), this;
      },
      inverse: function () {
        return this.conjugate();
      },
      conjugate: function () {
        return (
          (this._x *= -1), (this._y *= -1), (this._z *= -1), this.onChangeCallback(), this
        );
      },
      dot: function (t) {
        return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w;
      },
      lengthSq: function () {
        return (
          this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        );
      },
      length: function () {
        return Math.sqrt(
          this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        );
      },
      normalize: function () {
        var t = this.length();
        return (
          0 === t
            ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
            : ((t = 1 / t),
              (this._x = this._x * t),
              (this._y = this._y * t),
              (this._z = this._z * t),
              (this._w = this._w * t)),
          this.onChangeCallback(),
          this
        );
      },
      multiply: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.'
            ),
            this.multiplyQuaternions(t, e))
          : this.multiplyQuaternions(this, t);
      },
      premultiply: function (t) {
        return this.multiplyQuaternions(t, this);
      },
      multiplyQuaternions: function (t, e) {
        var i = t._x,
          n = t._y,
          r = t._z,
          a = t._w,
          o = e._x,
          s = e._y,
          c = e._z,
          h = e._w;
        return (
          (this._x = i * h + a * o + n * c - r * s),
          (this._y = n * h + a * s + r * o - i * c),
          (this._z = r * h + a * c + i * s - n * o),
          (this._w = a * h - i * o - n * s - r * c),
          this.onChangeCallback(),
          this
        );
      },
      slerp: function (t, e) {
        if (0 === e) return this;
        if (1 === e) return this.copy(t);
        var i = this._x,
          n = this._y,
          r = this._z,
          a = this._w,
          o = a * t._w + i * t._x + n * t._y + r * t._z;
        if (
          (o < 0
            ? ((this._w = -t._w),
              (this._x = -t._x),
              (this._y = -t._y),
              (this._z = -t._z),
              (o = -o))
            : this.copy(t),
          1 <= o)
        )
          return (this._w = a), (this._x = i), (this._y = n), (this._z = r), this;
        var s = 1 - o * o;
        if (s <= Number.EPSILON) {
          var c = 1 - e;
          return (
            (this._w = c * a + e * this._w),
            (this._x = c * i + e * this._x),
            (this._y = c * n + e * this._y),
            (this._z = c * r + e * this._z),
            this.normalize()
          );
        }
        var h = Math.sqrt(s),
          l = Math.atan2(h, o),
          u = Math.sin((1 - e) * l) / h,
          p = Math.sin(e * l) / h;
        return (
          (this._w = a * u + this._w * p),
          (this._x = i * u + this._x * p),
          (this._y = n * u + this._y * p),
          (this._z = r * u + this._z * p),
          this.onChangeCallback(),
          this
        );
      },
      equals: function (t) {
        return (
          t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        );
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0),
          (this._x = t[e]),
          (this._y = t[e + 1]),
          (this._z = t[e + 2]),
          (this._w = t[e + 3]),
          this.onChangeCallback(),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this._x),
          (t[e + 1] = this._y),
          (t[e + 2] = this._z),
          (t[e + 3] = this._w),
          t
        );
      },
      onChange: function (t) {
        return (this.onChangeCallback = t), this;
      },
      onChangeCallback: function () {}
    }),
    Object.assign(je.prototype, {
      isVector3: !0,
      set: function (t, e, i) {
        return (this.x = t), (this.y = e), (this.z = i), this;
      },
      setScalar: function (t) {
        return (this.x = t), (this.y = t), (this.z = t), this;
      },
      setX: function (t) {
        return (this.x = t), this;
      },
      setY: function (t) {
        return (this.y = t), this;
      },
      setZ: function (t) {
        return (this.z = t), this;
      },
      setComponent: function (t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          default:
            throw new Error('index is out of range: ' + t);
        }
        return this;
      },
      getComponent: function (t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error('index is out of range: ' + t);
        }
      },
      clone: function () {
        return new this.constructor(this.x, this.y, this.z);
      },
      copy: function (t) {
        return (this.x = t.x), (this.y = t.y), (this.z = t.z), this;
      },
      add: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
            ),
            this.addVectors(t, e))
          : ((this.x += t.x), (this.y += t.y), (this.z += t.z), this);
      },
      addScalar: function (t) {
        return (this.x += t), (this.y += t), (this.z += t), this;
      },
      addVectors: function (t, e) {
        return (this.x = t.x + e.x), (this.y = t.y + e.y), (this.z = t.z + e.z), this;
      },
      addScaledVector: function (t, e) {
        return (this.x += t.x * e), (this.y += t.y * e), (this.z += t.z * e), this;
      },
      sub: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
            ),
            this.subVectors(t, e))
          : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), this);
      },
      subScalar: function (t) {
        return (this.x -= t), (this.y -= t), (this.z -= t), this;
      },
      subVectors: function (t, e) {
        return (this.x = t.x - e.x), (this.y = t.y - e.y), (this.z = t.z - e.z), this;
      },
      multiply: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.'
            ),
            this.multiplyVectors(t, e))
          : ((this.x *= t.x), (this.y *= t.y), (this.z *= t.z), this);
      },
      multiplyScalar: function (t) {
        return (this.x *= t), (this.y *= t), (this.z *= t), this;
      },
      multiplyVectors: function (t, e) {
        return (this.x = t.x * e.x), (this.y = t.y * e.y), (this.z = t.z * e.z), this;
      },
      applyEuler:
        ((_ = new ke()),
        function (t) {
          return (
            (t && t.isEuler) ||
              console.error(
                'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.'
              ),
            this.applyQuaternion(_.setFromEuler(t))
          );
        }),
      applyAxisAngle:
        ((b = new ke()),
        function (t, e) {
          return this.applyQuaternion(b.setFromAxisAngle(t, e));
        }),
      applyMatrix3: function (t) {
        var e = this.x,
          i = this.y,
          n = this.z,
          r = t.elements;
        return (
          (this.x = r[0] * e + r[3] * i + r[6] * n),
          (this.y = r[1] * e + r[4] * i + r[7] * n),
          (this.z = r[2] * e + r[5] * i + r[8] * n),
          this
        );
      },
      applyMatrix4: function (t) {
        var e = this.x,
          i = this.y,
          n = this.z,
          r = t.elements,
          a = 1 / (r[3] * e + r[7] * i + r[11] * n + r[15]);
        return (
          (this.x = (r[0] * e + r[4] * i + r[8] * n + r[12]) * a),
          (this.y = (r[1] * e + r[5] * i + r[9] * n + r[13]) * a),
          (this.z = (r[2] * e + r[6] * i + r[10] * n + r[14]) * a),
          this
        );
      },
      applyQuaternion: function (t) {
        var e = this.x,
          i = this.y,
          n = this.z,
          r = t.x,
          a = t.y,
          o = t.z,
          s = t.w,
          c = s * e + a * n - o * i,
          h = s * i + o * e - r * n,
          l = s * n + r * i - a * e,
          u = -r * e - a * i - o * n;
        return (
          (this.x = c * s + u * -r + h * -o - l * -a),
          (this.y = h * s + u * -a + l * -r - c * -o),
          (this.z = l * s + u * -o + c * -a - h * -r),
          this
        );
      },
      project: function (t) {
        return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix);
      },
      unproject:
        ((x = new Ve()),
        function (t) {
          return this.applyMatrix4(x.getInverse(t.projectionMatrix)).applyMatrix4(
            t.matrixWorld
          );
        }),
      transformDirection: function (t) {
        var e = this.x,
          i = this.y,
          n = this.z,
          r = t.elements;
        return (
          (this.x = r[0] * e + r[4] * i + r[8] * n),
          (this.y = r[1] * e + r[5] * i + r[9] * n),
          (this.z = r[2] * e + r[6] * i + r[10] * n),
          this.normalize()
        );
      },
      divide: function (t) {
        return (this.x /= t.x), (this.y /= t.y), (this.z /= t.z), this;
      },
      divideScalar: function (t) {
        return this.multiplyScalar(1 / t);
      },
      min: function (t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          (this.z = Math.min(this.z, t.z)),
          this
        );
      },
      max: function (t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          (this.z = Math.max(this.z, t.z)),
          this
        );
      },
      clamp: function (t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          (this.z = Math.max(t.z, Math.min(e.z, this.z))),
          this
        );
      },
      clampScalar:
        ((v = new je()),
        (y = new je()),
        function (t, e) {
          return v.set(t, t, t), y.set(e, e, e), this.clamp(v, y);
        }),
      clampLength: function (t, e) {
        var i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
      },
      floor: function () {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          this
        );
      },
      ceil: function () {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          this
        );
      },
      round: function () {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          this
        );
      },
      roundToZero: function () {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          this
        );
      },
      negate: function () {
        return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
      },
      dot: function (t) {
        return this.x * t.x + this.y * t.y + this.z * t.z;
      },
      lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      },
      length: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      },
      manhattanLength: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      },
      normalize: function () {
        return this.divideScalar(this.length() || 1);
      },
      setLength: function (t) {
        return this.normalize().multiplyScalar(t);
      },
      lerp: function (t, e) {
        return (
          (this.x += (t.x - this.x) * e),
          (this.y += (t.y - this.y) * e),
          (this.z += (t.z - this.z) * e),
          this
        );
      },
      lerpVectors: function (t, e, i) {
        return this.subVectors(e, t).multiplyScalar(i).add(t);
      },
      cross: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.'
            ),
            this.crossVectors(t, e))
          : this.crossVectors(this, t);
      },
      crossVectors: function (t, e) {
        var i = t.x,
          n = t.y,
          r = t.z,
          a = e.x,
          o = e.y,
          s = e.z;
        return (
          (this.x = n * s - r * o),
          (this.y = r * a - i * s),
          (this.z = i * o - n * a),
          this
        );
      },
      projectOnVector: function (t) {
        var e = t.dot(this) / t.lengthSq();
        return this.copy(t).multiplyScalar(e);
      },
      projectOnPlane:
        ((g = new je()),
        function (t) {
          return g.copy(this).projectOnVector(t), this.sub(g);
        }),
      reflect:
        ((m = new je()),
        function (t) {
          return this.sub(m.copy(t).multiplyScalar(2 * this.dot(t)));
        }),
      angleTo: function (t) {
        var e = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq());
        return Math.acos(Ge.clamp(e, -1, 1));
      },
      distanceTo: function (t) {
        return Math.sqrt(this.distanceToSquared(t));
      },
      distanceToSquared: function (t) {
        var e = this.x - t.x,
          i = this.y - t.y,
          n = this.z - t.z;
        return e * e + i * i + n * n;
      },
      manhattanDistanceTo: function (t) {
        return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z);
      },
      setFromSpherical: function (t) {
        return this.setFromSphericalCoords(t.radius, t.phi, t.theta);
      },
      setFromSphericalCoords: function (t, e, i) {
        var n = Math.sin(e) * t;
        return (
          (this.x = n * Math.sin(i)),
          (this.y = Math.cos(e) * t),
          (this.z = n * Math.cos(i)),
          this
        );
      },
      setFromCylindrical: function (t) {
        return this.setFromCylindricalCoords(t.radius, t.theta, t.y);
      },
      setFromCylindricalCoords: function (t, e, i) {
        return (this.x = t * Math.sin(e)), (this.y = i), (this.z = t * Math.cos(e)), this;
      },
      setFromMatrixPosition: function (t) {
        var e = t.elements;
        return (this.x = e[12]), (this.y = e[13]), (this.z = e[14]), this;
      },
      setFromMatrixScale: function (t) {
        var e = this.setFromMatrixColumn(t, 0).length(),
          i = this.setFromMatrixColumn(t, 1).length(),
          n = this.setFromMatrixColumn(t, 2).length();
        return (this.x = e), (this.y = i), (this.z = n), this;
      },
      setFromMatrixColumn: function (t, e) {
        return this.fromArray(t.elements, 4 * e);
      },
      equals: function (t) {
        return t.x === this.x && t.y === this.y && t.z === this.z;
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0),
          (this.x = t[e]),
          (this.y = t[e + 1]),
          (this.z = t[e + 2]),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this.x),
          (t[e + 1] = this.y),
          (t[e + 2] = this.z),
          t
        );
      },
      fromBufferAttribute: function (t, e, i) {
        return (
          void 0 !== i &&
            console.warn(
              'THREE.Vector3: offset has been removed from .fromBufferAttribute().'
            ),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          (this.z = t.getZ(e)),
          this
        );
      }
    }),
    Object.assign(We.prototype, {
      isMatrix3: !0,
      set: function (t, e, i, n, r, a, o, s, c) {
        var h = this.elements;
        return (
          (h[0] = t),
          (h[1] = n),
          (h[2] = o),
          (h[3] = e),
          (h[4] = r),
          (h[5] = s),
          (h[6] = i),
          (h[7] = a),
          (h[8] = c),
          this
        );
      },
      identity: function () {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
      },
      clone: function () {
        return new this.constructor().fromArray(this.elements);
      },
      copy: function (t) {
        var e = this.elements,
          i = t.elements;
        return (
          (e[0] = i[0]),
          (e[1] = i[1]),
          (e[2] = i[2]),
          (e[3] = i[3]),
          (e[4] = i[4]),
          (e[5] = i[5]),
          (e[6] = i[6]),
          (e[7] = i[7]),
          (e[8] = i[8]),
          this
        );
      },
      setFromMatrix4: function (t) {
        var e = t.elements;
        return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this;
      },
      applyToBufferAttribute:
        ((w = new je()),
        function (t) {
          for (var e = 0, i = t.count; e < i; e++)
            (w.x = t.getX(e)),
              (w.y = t.getY(e)),
              (w.z = t.getZ(e)),
              w.applyMatrix3(this),
              t.setXYZ(e, w.x, w.y, w.z);
          return t;
        }),
      multiply: function (t) {
        return this.multiplyMatrices(this, t);
      },
      premultiply: function (t) {
        return this.multiplyMatrices(t, this);
      },
      multiplyMatrices: function (t, e) {
        var i = t.elements,
          n = e.elements,
          r = this.elements,
          a = i[0],
          o = i[3],
          s = i[6],
          c = i[1],
          h = i[4],
          l = i[7],
          u = i[2],
          p = i[5],
          d = i[8],
          f = n[0],
          m = n[3],
          g = n[6],
          v = n[1],
          y = n[4],
          x = n[7],
          b = n[2],
          _ = n[5],
          w = n[8];
        return (
          (r[0] = a * f + o * v + s * b),
          (r[3] = a * m + o * y + s * _),
          (r[6] = a * g + o * x + s * w),
          (r[1] = c * f + h * v + l * b),
          (r[4] = c * m + h * y + l * _),
          (r[7] = c * g + h * x + l * w),
          (r[2] = u * f + p * v + d * b),
          (r[5] = u * m + p * y + d * _),
          (r[8] = u * g + p * x + d * w),
          this
        );
      },
      multiplyScalar: function (t) {
        var e = this.elements;
        return (
          (e[0] *= t),
          (e[3] *= t),
          (e[6] *= t),
          (e[1] *= t),
          (e[4] *= t),
          (e[7] *= t),
          (e[2] *= t),
          (e[5] *= t),
          (e[8] *= t),
          this
        );
      },
      determinant: function () {
        var t = this.elements,
          e = t[0],
          i = t[1],
          n = t[2],
          r = t[3],
          a = t[4],
          o = t[5],
          s = t[6],
          c = t[7],
          h = t[8];
        return e * a * h - e * o * c - i * r * h + i * o * s + n * r * c - n * a * s;
      },
      getInverse: function (t, e) {
        t &&
          t.isMatrix4 &&
          console.error(
            'THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.'
          );
        var i = t.elements,
          n = this.elements,
          r = i[0],
          a = i[1],
          o = i[2],
          s = i[3],
          c = i[4],
          h = i[5],
          l = i[6],
          u = i[7],
          p = i[8],
          d = p * c - h * u,
          f = h * l - p * s,
          m = u * s - c * l,
          g = r * d + a * f + o * m;
        if (0 == g) {
          var v = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
          if (!0 === e) throw new Error(v);
          return console.warn(v), this.identity();
        }
        var y = 1 / g;
        return (
          (n[0] = d * y),
          (n[1] = (o * u - p * a) * y),
          (n[2] = (h * a - o * c) * y),
          (n[3] = f * y),
          (n[4] = (p * r - o * l) * y),
          (n[5] = (o * s - h * r) * y),
          (n[6] = m * y),
          (n[7] = (a * l - u * r) * y),
          (n[8] = (c * r - a * s) * y),
          this
        );
      },
      transpose: function () {
        var t,
          e = this.elements;
        return (
          (t = e[1]),
          (e[1] = e[3]),
          (e[3] = t),
          (t = e[2]),
          (e[2] = e[6]),
          (e[6] = t),
          (t = e[5]),
          (e[5] = e[7]),
          (e[7] = t),
          this
        );
      },
      getNormalMatrix: function (t) {
        return this.setFromMatrix4(t).getInverse(this).transpose();
      },
      transposeIntoArray: function (t) {
        var e = this.elements;
        return (
          (t[0] = e[0]),
          (t[1] = e[3]),
          (t[2] = e[6]),
          (t[3] = e[1]),
          (t[4] = e[4]),
          (t[5] = e[7]),
          (t[6] = e[2]),
          (t[7] = e[5]),
          (t[8] = e[8]),
          this
        );
      },
      setUvTransform: function (t, e, i, n, r, a, o) {
        var s = Math.cos(r),
          c = Math.sin(r);
        this.set(
          i * s,
          i * c,
          -i * (s * a + c * o) + a + t,
          -n * c,
          n * s,
          -n * (-c * a + s * o) + o + e,
          0,
          0,
          1
        );
      },
      scale: function (t, e) {
        var i = this.elements;
        return (
          (i[0] *= t),
          (i[3] *= t),
          (i[6] *= t),
          (i[1] *= e),
          (i[4] *= e),
          (i[7] *= e),
          this
        );
      },
      rotate: function (t) {
        var e = Math.cos(t),
          i = Math.sin(t),
          n = this.elements,
          r = n[0],
          a = n[3],
          o = n[6],
          s = n[1],
          c = n[4],
          h = n[7];
        return (
          (n[0] = e * r + i * s),
          (n[3] = e * a + i * c),
          (n[6] = e * o + i * h),
          (n[1] = -i * r + e * s),
          (n[4] = -i * a + e * c),
          (n[7] = -i * o + e * h),
          this
        );
      },
      translate: function (t, e) {
        var i = this.elements;
        return (
          (i[0] += t * i[2]),
          (i[3] += t * i[5]),
          (i[6] += t * i[8]),
          (i[1] += e * i[2]),
          (i[4] += e * i[5]),
          (i[7] += e * i[8]),
          this
        );
      },
      equals: function (t) {
        for (var e = this.elements, i = t.elements, n = 0; n < 9; n++)
          if (e[n] !== i[n]) return !1;
        return !0;
      },
      fromArray: function (t, e) {
        void 0 === e && (e = 0);
        for (var i = 0; i < 9; i++) this.elements[i] = t[i + e];
        return this;
      },
      toArray: function (t, e) {
        void 0 === t && (t = []), void 0 === e && (e = 0);
        var i = this.elements;
        return (
          (t[e] = i[0]),
          (t[e + 1] = i[1]),
          (t[e + 2] = i[2]),
          (t[e + 3] = i[3]),
          (t[e + 4] = i[4]),
          (t[e + 5] = i[5]),
          (t[e + 6] = i[6]),
          (t[e + 7] = i[7]),
          (t[e + 8] = i[8]),
          t
        );
      }
    });
  var Xe,
    qe,
    Ye,
    Je,
    Ze,
    Qe,
    Ke,
    $e,
    ti,
    ei,
    ii,
    ni,
    ri,
    ai,
    oi,
    si,
    ci,
    hi,
    li,
    ui,
    pi,
    di,
    fi,
    mi,
    gi,
    vi,
    yi,
    xi,
    bi,
    _i,
    wi = {
      getDataURL: function (t) {
        var e;
        if (t instanceof HTMLCanvasElement) e = t;
        else {
          ((e = document.createElementNS(
            'http://www.w3.org/1999/xhtml',
            'canvas'
          )).width = t.width),
            (e.height = t.height);
          var i = e.getContext('2d');
          t instanceof ImageData
            ? i.putImageData(t, 0, 0)
            : i.drawImage(t, 0, 0, t.width, t.height);
        }
        return 2048 < e.width || 2048 < e.height
          ? e.toDataURL('image/jpeg', 0.6)
          : e.toDataURL('image/png');
      }
    },
    Mi = 0;
  function Ei(t, e, i, n, r, a, o, s, c, h) {
    Object.defineProperty(this, 'id', { value: Mi++ }),
      (this.uuid = Ge.generateUUID()),
      (this.name = ''),
      (this.image = void 0 !== t ? t : Ei.DEFAULT_IMAGE),
      (this.mipmaps = []),
      (this.mapping = void 0 !== e ? e : Ei.DEFAULT_MAPPING),
      (this.wrapS = void 0 !== i ? i : Tt),
      (this.wrapT = void 0 !== n ? n : Tt),
      (this.magFilter = void 0 !== r ? r : Pt),
      (this.minFilter = void 0 !== a ? a : Ot),
      (this.anisotropy = void 0 !== c ? c : 1),
      (this.format = void 0 !== o ? o : qt),
      (this.type = void 0 !== s ? s : It),
      (this.offset = new He(0, 0)),
      (this.repeat = new He(1, 1)),
      (this.center = new He(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new We()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      (this.encoding = void 0 !== h ? h : Re),
      (this.version = 0),
      (this.onUpdate = null);
  }
  function Ti(t, e, i, n) {
    (this.x = t || 0),
      (this.y = e || 0),
      (this.z = i || 0),
      (this.w = void 0 !== n ? n : 1);
  }
  function Si(t, e, i) {
    (this.width = t),
      (this.height = e),
      (this.scissor = new Ti(0, 0, t, e)),
      (this.scissorTest = !1),
      (this.viewport = new Ti(0, 0, t, e)),
      void 0 === (i = i || {}).minFilter && (i.minFilter = Pt),
      (this.texture = new Ei(
        void 0,
        void 0,
        i.wrapS,
        i.wrapT,
        i.magFilter,
        i.minFilter,
        i.format,
        i.type,
        i.anisotropy,
        i.encoding
      )),
      (this.texture.generateMipmaps = void 0 === i.generateMipmaps || i.generateMipmaps),
      (this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer),
      (this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer),
      (this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null);
  }
  function Ai(t, e, i) {
    Si.call(this, t, e, i), (this.activeCubeFace = 0), (this.activeMipMapLevel = 0);
  }
  function Li(t, e, i, n, r, a, o, s, c, h, l, u) {
    Ei.call(this, null, a, o, s, c, h, n, r, l, u),
      (this.image = { data: t, width: e, height: i }),
      (this.magFilter = void 0 !== c ? c : At),
      (this.minFilter = void 0 !== h ? h : At),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
  function Ri(t, e) {
    (this.min = void 0 !== t ? t : new je(1 / 0, 1 / 0, 1 / 0)),
      (this.max = void 0 !== e ? e : new je(-1 / 0, -1 / 0, -1 / 0));
  }
  function Pi(t) {
    var e, i;
    for (e = 0, i = t.length - 3; e <= i; e += 3) {
      ni.fromArray(t, e);
      var n = ai.x * Math.abs(ni.x) + ai.y * Math.abs(ni.y) + ai.z * Math.abs(ni.z),
        r = Qe.dot(ni),
        a = Ke.dot(ni),
        o = $e.dot(ni);
      if (Math.max(-Math.max(r, a, o), Math.min(r, a, o)) > n) return !1;
    }
    return !0;
  }
  function Ci(t) {
    var e = t.geometry;
    if (void 0 !== e)
      if (e.isGeometry) {
        var i = e.vertices;
        for (hi = 0, li = i.length; hi < li; hi++)
          ui.copy(i[hi]), ui.applyMatrix4(t.matrixWorld), ci.expandByPoint(ui);
      } else if (e.isBufferGeometry) {
        var n = e.attributes.position;
        if (void 0 !== n)
          for (hi = 0, li = n.count; hi < li; hi++)
            ui.fromBufferAttribute(n, hi).applyMatrix4(t.matrixWorld),
              ci.expandByPoint(ui);
      }
  }
  function Oi(t, e) {
    (this.center = void 0 !== t ? t : new je()), (this.radius = void 0 !== e ? e : 0);
  }
  function Ii(t, e) {
    (this.normal = void 0 !== t ? t : new je(1, 0, 0)),
      (this.constant = void 0 !== e ? e : 0);
  }
  function Ni(t, e, i, n, r, a) {
    this.planes = [
      void 0 !== t ? t : new Ii(),
      void 0 !== e ? e : new Ii(),
      void 0 !== i ? i : new Ii(),
      void 0 !== n ? n : new Ii(),
      void 0 !== r ? r : new Ii(),
      void 0 !== a ? a : new Ii()
    ];
  }
  (Ei.DEFAULT_IMAGE = void 0),
    (Ei.DEFAULT_MAPPING = 300),
    (Ei.prototype = Object.assign(Object.create(e.prototype), {
      constructor: Ei,
      isTexture: !0,
      updateMatrix: function () {
        this.matrix.setUvTransform(
          this.offset.x,
          this.offset.y,
          this.repeat.x,
          this.repeat.y,
          this.rotation,
          this.center.x,
          this.center.y
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (
          (this.name = t.name),
          (this.image = t.image),
          (this.mipmaps = t.mipmaps.slice(0)),
          (this.mapping = t.mapping),
          (this.wrapS = t.wrapS),
          (this.wrapT = t.wrapT),
          (this.magFilter = t.magFilter),
          (this.minFilter = t.minFilter),
          (this.anisotropy = t.anisotropy),
          (this.format = t.format),
          (this.type = t.type),
          this.offset.copy(t.offset),
          this.repeat.copy(t.repeat),
          this.center.copy(t.center),
          (this.rotation = t.rotation),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          this.matrix.copy(t.matrix),
          (this.generateMipmaps = t.generateMipmaps),
          (this.premultiplyAlpha = t.premultiplyAlpha),
          (this.flipY = t.flipY),
          (this.unpackAlignment = t.unpackAlignment),
          (this.encoding = t.encoding),
          this
        );
      },
      toJSON: function (t) {
        var e = void 0 === t || 'string' == typeof t;
        if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
        var i = {
          metadata: { version: 4.5, type: 'Texture', generator: 'Texture.toJSON' },
          uuid: this.uuid,
          name: this.name,
          mapping: this.mapping,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY
        };
        if (void 0 !== this.image) {
          var n = this.image;
          if (
            (void 0 === n.uuid && (n.uuid = Ge.generateUUID()),
            !e && void 0 === t.images[n.uuid])
          ) {
            var r;
            if (Array.isArray(n)) {
              r = [];
              for (var a = 0, o = n.length; a < o; a++) r.push(wi.getDataURL(n[a]));
            } else r = wi.getDataURL(n);
            t.images[n.uuid] = { uuid: n.uuid, url: r };
          }
          i.image = n.uuid;
        }
        return e || (t.textures[this.uuid] = i), i;
      },
      dispose: function () {
        this.dispatchEvent({ type: 'dispose' });
      },
      transformUv: function (t) {
        if (300 !== this.mapping) return t;
        if ((t.applyMatrix3(this.matrix), t.x < 0 || 1 < t.x))
          switch (this.wrapS) {
            case Et:
              t.x = t.x - Math.floor(t.x);
              break;
            case Tt:
              t.x = t.x < 0 ? 0 : 1;
              break;
            case St:
              1 === Math.abs(Math.floor(t.x) % 2)
                ? (t.x = Math.ceil(t.x) - t.x)
                : (t.x = t.x - Math.floor(t.x));
          }
        if (t.y < 0 || 1 < t.y)
          switch (this.wrapT) {
            case Et:
              t.y = t.y - Math.floor(t.y);
              break;
            case Tt:
              t.y = t.y < 0 ? 0 : 1;
              break;
            case St:
              1 === Math.abs(Math.floor(t.y) % 2)
                ? (t.y = Math.ceil(t.y) - t.y)
                : (t.y = t.y - Math.floor(t.y));
          }
        return this.flipY && (t.y = 1 - t.y), t;
      }
    })),
    Object.defineProperty(Ei.prototype, 'needsUpdate', {
      set: function (t) {
        !0 === t && this.version++;
      }
    }),
    Object.assign(Ti.prototype, {
      isVector4: !0,
      set: function (t, e, i, n) {
        return (this.x = t), (this.y = e), (this.z = i), (this.w = n), this;
      },
      setScalar: function (t) {
        return (this.x = t), (this.y = t), (this.z = t), (this.w = t), this;
      },
      setX: function (t) {
        return (this.x = t), this;
      },
      setY: function (t) {
        return (this.y = t), this;
      },
      setZ: function (t) {
        return (this.z = t), this;
      },
      setW: function (t) {
        return (this.w = t), this;
      },
      setComponent: function (t, e) {
        switch (t) {
          case 0:
            this.x = e;
            break;
          case 1:
            this.y = e;
            break;
          case 2:
            this.z = e;
            break;
          case 3:
            this.w = e;
            break;
          default:
            throw new Error('index is out of range: ' + t);
        }
        return this;
      },
      getComponent: function (t) {
        switch (t) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error('index is out of range: ' + t);
        }
      },
      clone: function () {
        return new this.constructor(this.x, this.y, this.z, this.w);
      },
      copy: function (t) {
        return (
          (this.x = t.x),
          (this.y = t.y),
          (this.z = t.z),
          (this.w = void 0 !== t.w ? t.w : 1),
          this
        );
      },
      add: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.'
            ),
            this.addVectors(t, e))
          : ((this.x += t.x), (this.y += t.y), (this.z += t.z), (this.w += t.w), this);
      },
      addScalar: function (t) {
        return (this.x += t), (this.y += t), (this.z += t), (this.w += t), this;
      },
      addVectors: function (t, e) {
        return (
          (this.x = t.x + e.x),
          (this.y = t.y + e.y),
          (this.z = t.z + e.z),
          (this.w = t.w + e.w),
          this
        );
      },
      addScaledVector: function (t, e) {
        return (
          (this.x += t.x * e),
          (this.y += t.y * e),
          (this.z += t.z * e),
          (this.w += t.w * e),
          this
        );
      },
      sub: function (t, e) {
        return void 0 !== e
          ? (console.warn(
              'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.'
            ),
            this.subVectors(t, e))
          : ((this.x -= t.x), (this.y -= t.y), (this.z -= t.z), (this.w -= t.w), this);
      },
      subScalar: function (t) {
        return (this.x -= t), (this.y -= t), (this.z -= t), (this.w -= t), this;
      },
      subVectors: function (t, e) {
        return (
          (this.x = t.x - e.x),
          (this.y = t.y - e.y),
          (this.z = t.z - e.z),
          (this.w = t.w - e.w),
          this
        );
      },
      multiplyScalar: function (t) {
        return (this.x *= t), (this.y *= t), (this.z *= t), (this.w *= t), this;
      },
      applyMatrix4: function (t) {
        var e = this.x,
          i = this.y,
          n = this.z,
          r = this.w,
          a = t.elements;
        return (
          (this.x = a[0] * e + a[4] * i + a[8] * n + a[12] * r),
          (this.y = a[1] * e + a[5] * i + a[9] * n + a[13] * r),
          (this.z = a[2] * e + a[6] * i + a[10] * n + a[14] * r),
          (this.w = a[3] * e + a[7] * i + a[11] * n + a[15] * r),
          this
        );
      },
      divideScalar: function (t) {
        return this.multiplyScalar(1 / t);
      },
      setAxisAngleFromQuaternion: function (t) {
        this.w = 2 * Math.acos(t.w);
        var e = Math.sqrt(1 - t.w * t.w);
        return (
          e < 1e-4
            ? ((this.x = 1), (this.y = 0), (this.z = 0))
            : ((this.x = t.x / e), (this.y = t.y / e), (this.z = t.z / e)),
          this
        );
      },
      setAxisAngleFromRotationMatrix: function (t) {
        var e,
          i,
          n,
          r,
          a = t.elements,
          o = a[0],
          s = a[4],
          c = a[8],
          h = a[1],
          l = a[5],
          u = a[9],
          p = a[2],
          d = a[6],
          f = a[10];
        if (Math.abs(s - h) < 0.01 && Math.abs(c - p) < 0.01 && Math.abs(u - d) < 0.01) {
          if (
            Math.abs(s + h) < 0.1 &&
            Math.abs(c + p) < 0.1 &&
            Math.abs(u + d) < 0.1 &&
            Math.abs(o + l + f - 3) < 0.1
          )
            return this.set(1, 0, 0, 0), this;
          e = Math.PI;
          var m = (o + 1) / 2,
            g = (l + 1) / 2,
            v = (f + 1) / 2,
            y = (s + h) / 4,
            x = (c + p) / 4,
            b = (u + d) / 4;
          return (
            g < m && v < m
              ? (r =
                  m < 0.01
                    ? ((i = 0), (n = 0.707106781))
                    : ((n = y / (i = Math.sqrt(m))), x / i))
              : v < g
              ? (r =
                  g < 0.01
                    ? ((n = 0), (i = 0.707106781))
                    : ((i = y / (n = Math.sqrt(g))), b / n))
              : v < 0.01
              ? ((n = i = 0.707106781), (r = 0))
              : ((i = x / (r = Math.sqrt(v))), (n = b / r)),
            this.set(i, n, r, e),
            this
          );
        }
        var _ = Math.sqrt((d - u) * (d - u) + (c - p) * (c - p) + (h - s) * (h - s));
        return (
          Math.abs(_) < 0.001 && (_ = 1),
          (this.x = (d - u) / _),
          (this.y = (c - p) / _),
          (this.z = (h - s) / _),
          (this.w = Math.acos((o + l + f - 1) / 2)),
          this
        );
      },
      min: function (t) {
        return (
          (this.x = Math.min(this.x, t.x)),
          (this.y = Math.min(this.y, t.y)),
          (this.z = Math.min(this.z, t.z)),
          (this.w = Math.min(this.w, t.w)),
          this
        );
      },
      max: function (t) {
        return (
          (this.x = Math.max(this.x, t.x)),
          (this.y = Math.max(this.y, t.y)),
          (this.z = Math.max(this.z, t.z)),
          (this.w = Math.max(this.w, t.w)),
          this
        );
      },
      clamp: function (t, e) {
        return (
          (this.x = Math.max(t.x, Math.min(e.x, this.x))),
          (this.y = Math.max(t.y, Math.min(e.y, this.y))),
          (this.z = Math.max(t.z, Math.min(e.z, this.z))),
          (this.w = Math.max(t.w, Math.min(e.w, this.w))),
          this
        );
      },
      clampScalar: function (t, e) {
        return (
          void 0 === Xe && ((Xe = new Ti()), (qe = new Ti())),
          Xe.set(t, t, t, t),
          qe.set(e, e, e, e),
          this.clamp(Xe, qe)
        );
      },
      clampLength: function (t, e) {
        var i = this.length();
        return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)));
      },
      floor: function () {
        return (
          (this.x = Math.floor(this.x)),
          (this.y = Math.floor(this.y)),
          (this.z = Math.floor(this.z)),
          (this.w = Math.floor(this.w)),
          this
        );
      },
      ceil: function () {
        return (
          (this.x = Math.ceil(this.x)),
          (this.y = Math.ceil(this.y)),
          (this.z = Math.ceil(this.z)),
          (this.w = Math.ceil(this.w)),
          this
        );
      },
      round: function () {
        return (
          (this.x = Math.round(this.x)),
          (this.y = Math.round(this.y)),
          (this.z = Math.round(this.z)),
          (this.w = Math.round(this.w)),
          this
        );
      },
      roundToZero: function () {
        return (
          (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
          (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
          (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
          (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
          this
        );
      },
      negate: function () {
        return (
          (this.x = -this.x),
          (this.y = -this.y),
          (this.z = -this.z),
          (this.w = -this.w),
          this
        );
      },
      dot: function (t) {
        return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w;
      },
      lengthSq: function () {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      },
      length: function () {
        return Math.sqrt(
          this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        );
      },
      manhattanLength: function () {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      },
      normalize: function () {
        return this.divideScalar(this.length() || 1);
      },
      setLength: function (t) {
        return this.normalize().multiplyScalar(t);
      },
      lerp: function (t, e) {
        return (
          (this.x += (t.x - this.x) * e),
          (this.y += (t.y - this.y) * e),
          (this.z += (t.z - this.z) * e),
          (this.w += (t.w - this.w) * e),
          this
        );
      },
      lerpVectors: function (t, e, i) {
        return this.subVectors(e, t).multiplyScalar(i).add(t);
      },
      equals: function (t) {
        return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w;
      },
      fromArray: function (t, e) {
        return (
          void 0 === e && (e = 0),
          (this.x = t[e]),
          (this.y = t[e + 1]),
          (this.z = t[e + 2]),
          (this.w = t[e + 3]),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this.x),
          (t[e + 1] = this.y),
          (t[e + 2] = this.z),
          (t[e + 3] = this.w),
          t
        );
      },
      fromBufferAttribute: function (t, e, i) {
        return (
          void 0 !== i &&
            console.warn(
              'THREE.Vector4: offset has been removed from .fromBufferAttribute().'
            ),
          (this.x = t.getX(e)),
          (this.y = t.getY(e)),
          (this.z = t.getZ(e)),
          (this.w = t.getW(e)),
          this
        );
      }
    }),
    (Si.prototype = Object.assign(Object.create(e.prototype), {
      constructor: Si,
      isWebGLRenderTarget: !0,
      setSize: function (t, e) {
        (this.width === t && this.height === e) ||
          ((this.width = t), (this.height = e), this.dispose()),
          this.viewport.set(0, 0, t, e),
          this.scissor.set(0, 0, t, e);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (
          (this.width = t.width),
          (this.height = t.height),
          this.viewport.copy(t.viewport),
          (this.texture = t.texture.clone()),
          (this.depthBuffer = t.depthBuffer),
          (this.stencilBuffer = t.stencilBuffer),
          (this.depthTexture = t.depthTexture),
          this
        );
      },
      dispose: function () {
        this.dispatchEvent({ type: 'dispose' });
      }
    })),
    (((Ai.prototype = Object.create(
      Si.prototype
    )).constructor = Ai).prototype.isWebGLRenderTargetCube = !0),
    (((Li.prototype = Object.create(
      Ei.prototype
    )).constructor = Li).prototype.isDataTexture = !0),
    Object.assign(Ri.prototype, {
      isBox3: !0,
      set: function (t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      },
      setFromArray: function (t) {
        for (
          var e = 1 / 0,
            i = 1 / 0,
            n = 1 / 0,
            r = -1 / 0,
            a = -1 / 0,
            o = -1 / 0,
            s = 0,
            c = t.length;
          s < c;
          s += 3
        ) {
          var h = t[s],
            l = t[s + 1],
            u = t[s + 2];
          h < e && (e = h),
            l < i && (i = l),
            u < n && (n = u),
            r < h && (r = h),
            a < l && (a = l),
            o < u && (o = u);
        }
        return this.min.set(e, i, n), this.max.set(r, a, o), this;
      },
      setFromBufferAttribute: function (t) {
        for (
          var e = 1 / 0,
            i = 1 / 0,
            n = 1 / 0,
            r = -1 / 0,
            a = -1 / 0,
            o = -1 / 0,
            s = 0,
            c = t.count;
          s < c;
          s++
        ) {
          var h = t.getX(s),
            l = t.getY(s),
            u = t.getZ(s);
          h < e && (e = h),
            l < i && (i = l),
            u < n && (n = u),
            r < h && (r = h),
            a < l && (a = l),
            o < u && (o = u);
        }
        return this.min.set(e, i, n), this.max.set(r, a, o), this;
      },
      setFromPoints: function (t) {
        this.makeEmpty();
        for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
        return this;
      },
      setFromCenterAndSize:
        ((pi = new je()),
        function (t, e) {
          var i = pi.copy(e).multiplyScalar(0.5);
          return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
        }),
      setFromObject: function (t) {
        return this.makeEmpty(), this.expandByObject(t);
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      },
      makeEmpty: function () {
        return (
          (this.min.x = this.min.y = this.min.z = 1 / 0),
          (this.max.x = this.max.y = this.max.z = -1 / 0),
          this
        );
      },
      isEmpty: function () {
        return (
          this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        );
      },
      getCenter: function (t) {
        return (
          void 0 === t &&
            (console.warn('THREE.Box3: .getCenter() target is now required'),
            (t = new je())),
          this.isEmpty()
            ? t.set(0, 0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5)
        );
      },
      getSize: function (t) {
        return (
          void 0 === t &&
            (console.warn('THREE.Box3: .getSize() target is now required'),
            (t = new je())),
          this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        );
      },
      expandByPoint: function (t) {
        return this.min.min(t), this.max.max(t), this;
      },
      expandByVector: function (t) {
        return this.min.sub(t), this.max.add(t), this;
      },
      expandByScalar: function (t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      },
      expandByObject:
        ((ui = new je()),
        function (t) {
          return (ci = this), t.updateMatrixWorld(!0), t.traverse(Ci), this;
        }),
      containsPoint: function (t) {
        return !(
          t.x < this.min.x ||
          t.x > this.max.x ||
          t.y < this.min.y ||
          t.y > this.max.y ||
          t.z < this.min.z ||
          t.z > this.max.z
        );
      },
      containsBox: function (t) {
        return (
          this.min.x <= t.min.x &&
          t.max.x <= this.max.x &&
          this.min.y <= t.min.y &&
          t.max.y <= this.max.y &&
          this.min.z <= t.min.z &&
          t.max.z <= this.max.z
        );
      },
      getParameter: function (t, e) {
        return (
          void 0 === e &&
            (console.warn('THREE.Box3: .getParameter() target is now required'),
            (e = new je())),
          e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y),
            (t.z - this.min.z) / (this.max.z - this.min.z)
          )
        );
      },
      intersectsBox: function (t) {
        return !(
          t.max.x < this.min.x ||
          t.min.x > this.max.x ||
          t.max.y < this.min.y ||
          t.min.y > this.max.y ||
          t.max.z < this.min.z ||
          t.min.z > this.max.z
        );
      },
      intersectsSphere:
        ((si = new je()),
        function (t) {
          return (
            this.clampPoint(t.center, si),
            si.distanceToSquared(t.center) <= t.radius * t.radius
          );
        }),
      intersectsPlane: function (t) {
        var e, i;
        return (
          (i =
            0 < t.normal.x
              ? ((e = t.normal.x * this.min.x), t.normal.x * this.max.x)
              : ((e = t.normal.x * this.max.x), t.normal.x * this.min.x)),
          0 < t.normal.y
            ? ((e += t.normal.y * this.min.y), (i += t.normal.y * this.max.y))
            : ((e += t.normal.y * this.max.y), (i += t.normal.y * this.min.y)),
          0 < t.normal.z
            ? ((e += t.normal.z * this.min.z), (i += t.normal.z * this.max.z))
            : ((e += t.normal.z * this.max.z), (i += t.normal.z * this.min.z)),
          e <= -t.constant && i >= -t.constant
        );
      },
      intersectsTriangle:
        ((Qe = new je()),
        (Ke = new je()),
        ($e = new je()),
        (ti = new je()),
        (ei = new je()),
        (ii = new je()),
        (ni = new je()),
        (ri = new je()),
        (ai = new je()),
        (oi = new je()),
        function (t) {
          if (this.isEmpty()) return !1;
          this.getCenter(ri),
            ai.subVectors(this.max, ri),
            Qe.subVectors(t.a, ri),
            Ke.subVectors(t.b, ri),
            $e.subVectors(t.c, ri),
            ti.subVectors(Ke, Qe),
            ei.subVectors($e, Ke),
            ii.subVectors(Qe, $e);
          var e = [
            0,
            -ti.z,
            ti.y,
            0,
            -ei.z,
            ei.y,
            0,
            -ii.z,
            ii.y,
            ti.z,
            0,
            -ti.x,
            ei.z,
            0,
            -ei.x,
            ii.z,
            0,
            -ii.x,
            -ti.y,
            ti.x,
            0,
            -ei.y,
            ei.x,
            0,
            -ii.y,
            ii.x,
            0
          ];
          return (
            !!Pi(e) &&
            !!Pi((e = [1, 0, 0, 0, 1, 0, 0, 0, 1])) &&
            (oi.crossVectors(ti, ei), Pi((e = [oi.x, oi.y, oi.z])))
          );
        }),
      clampPoint: function (t, e) {
        return (
          void 0 === e &&
            (console.warn('THREE.Box3: .clampPoint() target is now required'),
            (e = new je())),
          e.copy(t).clamp(this.min, this.max)
        );
      },
      distanceToPoint:
        ((Ze = new je()),
        function (t) {
          return Ze.copy(t).clamp(this.min, this.max).sub(t).length();
        }),
      getBoundingSphere:
        ((Je = new je()),
        function (t) {
          return (
            void 0 === t &&
              (console.warn('THREE.Box3: .getBoundingSphere() target is now required'),
              (t = new Oi())),
            this.getCenter(t.center),
            (t.radius = 0.5 * this.getSize(Je).length()),
            t
          );
        }),
      intersect: function (t) {
        return (
          this.min.max(t.min),
          this.max.min(t.max),
          this.isEmpty() && this.makeEmpty(),
          this
        );
      },
      union: function (t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      },
      applyMatrix4:
        ((Ye = [
          new je(),
          new je(),
          new je(),
          new je(),
          new je(),
          new je(),
          new je(),
          new je()
        ]),
        function (t) {
          return (
            this.isEmpty() ||
              (Ye[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
              Ye[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
              Ye[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
              Ye[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
              Ye[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
              Ye[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
              Ye[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
              Ye[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
              this.setFromPoints(Ye)),
            this
          );
        }),
      translate: function (t) {
        return this.min.add(t), this.max.add(t), this;
      },
      equals: function (t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      }
    }),
    Object.assign(Oi.prototype, {
      set: function (t, e) {
        return this.center.copy(t), (this.radius = e), this;
      },
      setFromPoints:
        ((di = new Ri()),
        function (t, e) {
          var i = this.center;
          void 0 !== e ? i.copy(e) : di.setFromPoints(t).getCenter(i);
          for (var n = 0, r = 0, a = t.length; r < a; r++)
            n = Math.max(n, i.distanceToSquared(t[r]));
          return (this.radius = Math.sqrt(n)), this;
        }),
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.center.copy(t.center), (this.radius = t.radius), this;
      },
      empty: function () {
        return this.radius <= 0;
      },
      containsPoint: function (t) {
        return t.distanceToSquared(this.center) <= this.radius * this.radius;
      },
      distanceToPoint: function (t) {
        return t.distanceTo(this.center) - this.radius;
      },
      intersectsSphere: function (t) {
        var e = this.radius + t.radius;
        return t.center.distanceToSquared(this.center) <= e * e;
      },
      intersectsBox: function (t) {
        return t.intersectsSphere(this);
      },
      intersectsPlane: function (t) {
        return Math.abs(t.distanceToPoint(this.center)) <= this.radius;
      },
      clampPoint: function (t, e) {
        var i = this.center.distanceToSquared(t);
        return (
          void 0 === e &&
            (console.warn('THREE.Sphere: .clampPoint() target is now required'),
            (e = new je())),
          e.copy(t),
          i > this.radius * this.radius &&
            (e.sub(this.center).normalize(),
            e.multiplyScalar(this.radius).add(this.center)),
          e
        );
      },
      getBoundingBox: function (t) {
        return (
          void 0 === t &&
            (console.warn('THREE.Sphere: .getBoundingBox() target is now required'),
            (t = new Ri())),
          t.set(this.center, this.center),
          t.expandByScalar(this.radius),
          t
        );
      },
      applyMatrix4: function (t) {
        return (
          this.center.applyMatrix4(t),
          (this.radius = this.radius * t.getMaxScaleOnAxis()),
          this
        );
      },
      translate: function (t) {
        return this.center.add(t), this;
      },
      equals: function (t) {
        return t.center.equals(this.center) && t.radius === this.radius;
      }
    }),
    Object.assign(Ii.prototype, {
      set: function (t, e) {
        return this.normal.copy(t), (this.constant = e), this;
      },
      setComponents: function (t, e, i, n) {
        return this.normal.set(t, e, i), (this.constant = n), this;
      },
      setFromNormalAndCoplanarPoint: function (t, e) {
        return this.normal.copy(t), (this.constant = -e.dot(this.normal)), this;
      },
      setFromCoplanarPoints:
        ((vi = new je()),
        (yi = new je()),
        function (t, e, i) {
          var n = vi.subVectors(i, e).cross(yi.subVectors(t, e)).normalize();
          return this.setFromNormalAndCoplanarPoint(n, t), this;
        }),
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.normal.copy(t.normal), (this.constant = t.constant), this;
      },
      normalize: function () {
        var t = 1 / this.normal.length();
        return this.normal.multiplyScalar(t), (this.constant *= t), this;
      },
      negate: function () {
        return (this.constant *= -1), this.normal.negate(), this;
      },
      distanceToPoint: function (t) {
        return this.normal.dot(t) + this.constant;
      },
      distanceToSphere: function (t) {
        return this.distanceToPoint(t.center) - t.radius;
      },
      projectPoint: function (t, e) {
        return (
          void 0 === e &&
            (console.warn('THREE.Plane: .projectPoint() target is now required'),
            (e = new je())),
          e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        );
      },
      intersectLine:
        ((gi = new je()),
        function (t, e) {
          void 0 === e &&
            (console.warn('THREE.Plane: .intersectLine() target is now required'),
            (e = new je()));
          var i = t.delta(gi),
            n = this.normal.dot(i);
          if (0 === n)
            return 0 === this.distanceToPoint(t.start) ? e.copy(t.start) : void 0;
          var r = -(t.start.dot(this.normal) + this.constant) / n;
          return r < 0 || 1 < r ? void 0 : e.copy(i).multiplyScalar(r).add(t.start);
        }),
      intersectsLine: function (t) {
        var e = this.distanceToPoint(t.start),
          i = this.distanceToPoint(t.end);
        return (e < 0 && 0 < i) || (i < 0 && 0 < e);
      },
      intersectsBox: function (t) {
        return t.intersectsPlane(this);
      },
      intersectsSphere: function (t) {
        return t.intersectsPlane(this);
      },
      coplanarPoint: function (t) {
        return (
          void 0 === t &&
            (console.warn('THREE.Plane: .coplanarPoint() target is now required'),
            (t = new je())),
          t.copy(this.normal).multiplyScalar(-this.constant)
        );
      },
      applyMatrix4:
        ((fi = new je()),
        (mi = new We()),
        function (t, e) {
          var i = e || mi.getNormalMatrix(t),
            n = this.coplanarPoint(fi).applyMatrix4(t),
            r = this.normal.applyMatrix3(i).normalize();
          return (this.constant = -n.dot(r)), this;
        }),
      translate: function (t) {
        return (this.constant -= t.dot(this.normal)), this;
      },
      equals: function (t) {
        return t.normal.equals(this.normal) && t.constant === this.constant;
      }
    }),
    Object.assign(Ni.prototype, {
      set: function (t, e, i, n, r, a) {
        var o = this.planes;
        return (
          o[0].copy(t),
          o[1].copy(e),
          o[2].copy(i),
          o[3].copy(n),
          o[4].copy(r),
          o[5].copy(a),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        for (var e = this.planes, i = 0; i < 6; i++) e[i].copy(t.planes[i]);
        return this;
      },
      setFromMatrix: function (t) {
        var e = this.planes,
          i = t.elements,
          n = i[0],
          r = i[1],
          a = i[2],
          o = i[3],
          s = i[4],
          c = i[5],
          h = i[6],
          l = i[7],
          u = i[8],
          p = i[9],
          d = i[10],
          f = i[11],
          m = i[12],
          g = i[13],
          v = i[14],
          y = i[15];
        return (
          e[0].setComponents(o - n, l - s, f - u, y - m).normalize(),
          e[1].setComponents(o + n, l + s, f + u, y + m).normalize(),
          e[2].setComponents(o + r, l + c, f + p, y + g).normalize(),
          e[3].setComponents(o - r, l - c, f - p, y - g).normalize(),
          e[4].setComponents(o - a, l - h, f - d, y - v).normalize(),
          e[5].setComponents(o + a, l + h, f + d, y + v).normalize(),
          this
        );
      },
      intersectsObject:
        ((_i = new Oi()),
        function (t) {
          var e = t.geometry;
          return (
            null === e.boundingSphere && e.computeBoundingSphere(),
            _i.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),
            this.intersectsSphere(_i)
          );
        }),
      intersectsSprite:
        ((bi = new Oi()),
        function (t) {
          return (
            bi.center.set(0, 0, 0),
            (bi.radius = 0.7071067811865476),
            bi.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(bi)
          );
        }),
      intersectsSphere: function (t) {
        for (var e = this.planes, i = t.center, n = -t.radius, r = 0; r < 6; r++) {
          if (e[r].distanceToPoint(i) < n) return !1;
        }
        return !0;
      },
      intersectsBox:
        ((xi = new je()),
        function (t) {
          for (var e = this.planes, i = 0; i < 6; i++) {
            var n = e[i];
            if (
              ((xi.x = 0 < n.normal.x ? t.max.x : t.min.x),
              (xi.y = 0 < n.normal.y ? t.max.y : t.min.y),
              (xi.z = 0 < n.normal.z ? t.max.z : t.min.z),
              n.distanceToPoint(xi) < 0)
            )
              return !1;
          }
          return !0;
        }),
      containsPoint: function (t) {
        for (var e = this.planes, i = 0; i < 6; i++)
          if (e[i].distanceToPoint(t) < 0) return !1;
        return !0;
      }
    });
  var Di,
    Ui,
    Bi,
    Fi = {
      alphamap_fragment:
        '#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n',
      alphamap_pars_fragment:
        '#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n',
      alphatest_fragment:
        '#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n',
      aomap_fragment:
        '#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n',
      aomap_pars_fragment:
        '#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif',
      begin_vertex: '\nvec3 transformed = vec3( position );\n',
      beginnormal_vertex: '\nvec3 objectNormal = vec3( normal );\n',
      bsdfs:
        'float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n',
      bumpmap_pars_fragment:
        '#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n',
      clipping_planes_fragment:
        '#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif\n',
      clipping_planes_pars_fragment:
        '#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n',
      clipping_planes_pars_vertex:
        '#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif\n',
      clipping_planes_vertex:
        '#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n',
      color_fragment: '#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif',
      color_pars_fragment: '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n',
      color_pars_vertex: '#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif',
      color_vertex: '#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif',
      common:
        '#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n',
      cube_uv_reflection_fragment:
        '#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n',
      defaultnormal_vertex:
        'vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n',
      displacementmap_pars_vertex:
        '#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n',
      displacementmap_vertex:
        '#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n',
      emissivemap_fragment:
        '#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n',
      emissivemap_pars_fragment:
        '#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n',
      encodings_fragment: '  gl_FragColor = linearToOutputTexel( gl_FragColor );\n',
      encodings_pars_fragment:
        '\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}\n',
      envmap_fragment:
        '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n',
      envmap_pars_fragment:
        '#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n',
      envmap_pars_vertex:
        '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n',
      envmap_physical_pars_fragment:
        '#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n',
      envmap_vertex:
        '#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n',
      fog_vertex: '#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif\n',
      fog_pars_vertex: '#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif\n',
      fog_fragment:
        '#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n',
      fog_pars_fragment:
        '#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n',
      gradientmap_pars_fragment:
        '#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n',
      lightmap_fragment:
        '#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n',
      lightmap_pars_fragment:
        '#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif',
      lights_lambert_vertex:
        'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n',
      lights_pars_begin:
        'uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n',
      lights_phong_fragment:
        'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n',
      lights_phong_pars_fragment:
        'varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n',
      lights_physical_fragment:
        'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n',
      lights_physical_pars_fragment:
        'struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos - halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n',
      lights_fragment_begin:
        '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif\n',
      lights_fragment_maps:
        '#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif\n',
      lights_fragment_end:
        '#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n',
      logdepthbuf_fragment:
        '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif',
      logdepthbuf_pars_fragment:
        '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif\n',
      logdepthbuf_pars_vertex:
        '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif\n',
      logdepthbuf_vertex:
        '#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif\n',
      map_fragment:
        '#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n',
      map_pars_fragment: '#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n',
      map_particle_fragment:
        '#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n',
      map_particle_pars_fragment:
        '#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif\n',
      metalnessmap_fragment:
        'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif\n',
      metalnessmap_pars_fragment:
        '#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif',
      morphnormal_vertex:
        '#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n',
      morphtarget_pars_vertex:
        '#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif',
      morphtarget_vertex:
        '#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n',
      normal_fragment_begin:
        '#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif\n',
      normal_fragment_maps:
        '#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n',
      normalmap_pars_fragment:
        '#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif\n',
      packing:
        'vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n',
      premultiplied_alpha_fragment:
        '#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n',
      project_vertex:
        'vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n',
      dithering_fragment:
        '#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif\n',
      dithering_pars_fragment:
        '#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif\n',
      roughnessmap_fragment:
        'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif\n',
      roughnessmap_pars_fragment:
        '#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif',
      shadowmap_pars_fragment:
        '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n',
      shadowmap_pars_vertex:
        '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n',
      shadowmap_vertex:
        '#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n',
      shadowmask_pars_fragment:
        'float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n',
      skinbase_vertex:
        '#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif',
      skinning_pars_vertex:
        '#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n',
      skinning_vertex:
        '#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif\n',
      skinnormal_vertex:
        '#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n',
      specularmap_fragment:
        'float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif',
      specularmap_pars_fragment:
        '#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif',
      tonemapping_fragment:
        '#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n',
      tonemapping_pars_fragment:
        '#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n',
      uv_pars_fragment:
        '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif',
      uv_pars_vertex:
        '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\n',
      uv_vertex:
        '#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif',
      uv2_pars_fragment:
        '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif',
      uv2_pars_vertex:
        '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif',
      uv2_vertex:
        '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif',
      worldpos_vertex:
        '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif\n',
      background_frag:
        'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n}\n',
      background_vert:
        'varying vec2 vUv;\nvoid main() {\n\tvUv = uv;\n\tgl_Position = vec4( position, 1.0 );\n\tgl_Position.z = 1.0;\n}\n',
      cube_frag:
        'uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n',
      cube_vert:
        'varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}\n',
      depth_frag:
        '#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n',
      depth_vert:
        '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n',
      distanceRGBA_frag:
        '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}\n',
      distanceRGBA_vert:
        '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}\n',
      equirect_frag:
        'uniform sampler2D tEquirect;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n',
      equirect_vert:
        'varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n',
      linedashed_frag:
        'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',
      linedashed_vert:
        'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n',
      meshbasic_frag:
        'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',
      meshbasic_vert:
        '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n',
      meshlambert_frag:
        'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n',
      meshlambert_vert:
        '#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',
      meshmatcap_frag:
        '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\tvec4 matcapColor = texture2D( matcap, uv );\n\tmatcapColor = matcapTexelToLinear( matcapColor );\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',
      meshmatcap_vert:
        '#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}\n',
      meshphong_frag:
        '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n',
      meshphong_vert:
        '#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',
      meshphysical_frag:
        '#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n',
      meshphysical_vert:
        '#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',
      normal_frag:
        '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n',
      normal_vert:
        '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n',
      points_frag:
        'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',
      points_vert:
        'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}\n',
      shadow_frag:
        'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}\n',
      shadow_vert:
        '#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n',
      sprite_frag:
        'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n',
      sprite_vert:
        'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n'
    },
    zi = {
      merge: function (t) {
        for (var e = {}, i = 0; i < t.length; i++) {
          var n = this.clone(t[i]);
          for (var r in n) e[r] = n[r];
        }
        return e;
      },
      clone: function (t) {
        var e = {};
        for (var i in t)
          for (var n in ((e[i] = {}), t[i])) {
            var r = t[i][n];
            r &&
            (r.isColor ||
              r.isMatrix3 ||
              r.isMatrix4 ||
              r.isVector2 ||
              r.isVector3 ||
              r.isVector4 ||
              r.isTexture)
              ? (e[i][n] = r.clone())
              : Array.isArray(r)
              ? (e[i][n] = r.slice())
              : (e[i][n] = r);
          }
        return e;
      }
    },
    Gi = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
    };
  function Hi(t, e, i) {
    return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i);
  }
  function Vi(t) {
    return t < 0.0031308 ? 12.92 * t : 1.055 * Math.pow(t, 0.41666) - 0.055;
  }
  function ki(t) {
    return t < 0.04045
      ? 0.0773993808 * t
      : Math.pow(0.9478672986 * t + 0.0521327014, 2.4);
  }
  function ji(t, e, i) {
    return (
      i < 0 && (i += 1),
      1 < i && --i,
      i < 1 / 6
        ? t + 6 * (e - t) * i
        : i < 0.5
        ? e
        : i < 2 / 3
        ? t + 6 * (e - t) * (2 / 3 - i)
        : t
    );
  }
  Object.assign(Hi.prototype, {
    isColor: !0,
    r: 1,
    g: 1,
    b: 1,
    set: function (t) {
      return (
        t && t.isColor
          ? this.copy(t)
          : 'number' == typeof t
          ? this.setHex(t)
          : 'string' == typeof t && this.setStyle(t),
        this
      );
    },
    setScalar: function (t) {
      return (this.r = t), (this.g = t), (this.b = t), this;
    },
    setHex: function (t) {
      return (
        (t = Math.floor(t)),
        (this.r = ((t >> 16) & 255) / 255),
        (this.g = ((t >> 8) & 255) / 255),
        (this.b = (255 & t) / 255),
        this
      );
    },
    setRGB: function (t, e, i) {
      return (this.r = t), (this.g = e), (this.b = i), this;
    },
    setHSL: function (t, e, i) {
      if (
        ((t = Ge.euclideanModulo(t, 1)),
        (e = Ge.clamp(e, 0, 1)),
        (i = Ge.clamp(i, 0, 1)),
        0 === e)
      )
        this.r = this.g = this.b = i;
      else {
        var n = i <= 0.5 ? i * (1 + e) : i + e - i * e,
          r = 2 * i - n;
        (this.r = ji(r, n, t + 1 / 3)),
          (this.g = ji(r, n, t)),
          (this.b = ji(r, n, t - 1 / 3));
      }
      return this;
    },
    setStyle: function (e) {
      function t(t) {
        void 0 !== t &&
          parseFloat(t) < 1 &&
          console.warn('THREE.Color: Alpha component of ' + e + ' will be ignored.');
      }
      var i;
      if ((i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e))) {
        var n,
          r = i[1],
          a = i[2];
        switch (r) {
          case 'rgb':
          case 'rgba':
            if (
              (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                a
              ))
            )
              return (
                (this.r = Math.min(255, parseInt(n[1], 10)) / 255),
                (this.g = Math.min(255, parseInt(n[2], 10)) / 255),
                (this.b = Math.min(255, parseInt(n[3], 10)) / 255),
                t(n[5]),
                this
              );
            if (
              (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                a
              ))
            )
              return (
                (this.r = Math.min(100, parseInt(n[1], 10)) / 100),
                (this.g = Math.min(100, parseInt(n[2], 10)) / 100),
                (this.b = Math.min(100, parseInt(n[3], 10)) / 100),
                t(n[5]),
                this
              );
            break;
          case 'hsl':
          case 'hsla':
            if (
              (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(
                a
              ))
            ) {
              var o = parseFloat(n[1]) / 360,
                s = parseInt(n[2], 10) / 100,
                c = parseInt(n[3], 10) / 100;
              return t(n[5]), this.setHSL(o, s, c);
            }
        }
      } else if ((i = /^\#([A-Fa-f0-9]+)$/.exec(e))) {
        var h,
          l = (h = i[1]).length;
        if (3 === l)
          return (
            (this.r = parseInt(h.charAt(0) + h.charAt(0), 16) / 255),
            (this.g = parseInt(h.charAt(1) + h.charAt(1), 16) / 255),
            (this.b = parseInt(h.charAt(2) + h.charAt(2), 16) / 255),
            this
          );
        if (6 === l)
          return (
            (this.r = parseInt(h.charAt(0) + h.charAt(1), 16) / 255),
            (this.g = parseInt(h.charAt(2) + h.charAt(3), 16) / 255),
            (this.b = parseInt(h.charAt(4) + h.charAt(5), 16) / 255),
            this
          );
      }
      e &&
        0 < e.length &&
        (void 0 !== (h = Gi[e])
          ? this.setHex(h)
          : console.warn('THREE.Color: Unknown color ' + e));
      return this;
    },
    clone: function () {
      return new this.constructor(this.r, this.g, this.b);
    },
    copy: function (t) {
      return (this.r = t.r), (this.g = t.g), (this.b = t.b), this;
    },
    copyGammaToLinear: function (t, e) {
      return (
        void 0 === e && (e = 2),
        (this.r = Math.pow(t.r, e)),
        (this.g = Math.pow(t.g, e)),
        (this.b = Math.pow(t.b, e)),
        this
      );
    },
    copyLinearToGamma: function (t, e) {
      void 0 === e && (e = 2);
      var i = 0 < e ? 1 / e : 1;
      return (
        (this.r = Math.pow(t.r, i)),
        (this.g = Math.pow(t.g, i)),
        (this.b = Math.pow(t.b, i)),
        this
      );
    },
    convertGammaToLinear: function (t) {
      return this.copyGammaToLinear(this, t), this;
    },
    convertLinearToGamma: function (t) {
      return this.copyLinearToGamma(this, t), this;
    },
    copySRGBToLinear: function (t) {
      return (this.r = ki(t.r)), (this.g = ki(t.g)), (this.b = ki(t.b)), this;
    },
    copyLinearToSRGB: function (t) {
      return (this.r = Vi(t.r)), (this.g = Vi(t.g)), (this.b = Vi(t.b)), this;
    },
    convertSRGBToLinear: function () {
      return this.copySRGBToLinear(this), this;
    },
    convertLinearToSRGB: function () {
      return this.copyLinearToSRGB(this), this;
    },
    getHex: function () {
      return ((255 * this.r) << 16) ^ ((255 * this.g) << 8) ^ ((255 * this.b) << 0);
    },
    getHexString: function () {
      return ('000000' + this.getHex().toString(16)).slice(-6);
    },
    getHSL: function (t) {
      void 0 === t &&
        (console.warn('THREE.Color: .getHSL() target is now required'),
        (t = { h: 0, s: 0, l: 0 }));
      var e,
        i,
        n = this.r,
        r = this.g,
        a = this.b,
        o = Math.max(n, r, a),
        s = Math.min(n, r, a),
        c = (s + o) / 2;
      if (s === o) i = e = 0;
      else {
        var h = o - s;
        switch (((i = c <= 0.5 ? h / (o + s) : h / (2 - o - s)), o)) {
          case n:
            e = (r - a) / h + (r < a ? 6 : 0);
            break;
          case r:
            e = (a - n) / h + 2;
            break;
          case a:
            e = (n - r) / h + 4;
        }
        e /= 6;
      }
      return (t.h = e), (t.s = i), (t.l = c), t;
    },
    getStyle: function () {
      return (
        'rgb(' +
        ((255 * this.r) | 0) +
        ',' +
        ((255 * this.g) | 0) +
        ',' +
        ((255 * this.b) | 0) +
        ')'
      );
    },
    offsetHSL:
      ((Bi = {}),
      function (t, e, i) {
        return (
          this.getHSL(Bi),
          (Bi.h += t),
          (Bi.s += e),
          (Bi.l += i),
          this.setHSL(Bi.h, Bi.s, Bi.l),
          this
        );
      }),
    add: function (t) {
      return (this.r += t.r), (this.g += t.g), (this.b += t.b), this;
    },
    addColors: function (t, e) {
      return (this.r = t.r + e.r), (this.g = t.g + e.g), (this.b = t.b + e.b), this;
    },
    addScalar: function (t) {
      return (this.r += t), (this.g += t), (this.b += t), this;
    },
    sub: function (t) {
      return (
        (this.r = Math.max(0, this.r - t.r)),
        (this.g = Math.max(0, this.g - t.g)),
        (this.b = Math.max(0, this.b - t.b)),
        this
      );
    },
    multiply: function (t) {
      return (this.r *= t.r), (this.g *= t.g), (this.b *= t.b), this;
    },
    multiplyScalar: function (t) {
      return (this.r *= t), (this.g *= t), (this.b *= t), this;
    },
    lerp: function (t, e) {
      return (
        (this.r += (t.r - this.r) * e),
        (this.g += (t.g - this.g) * e),
        (this.b += (t.b - this.b) * e),
        this
      );
    },
    lerpHSL:
      ((Di = { h: 0, s: 0, l: 0 }),
      (Ui = { h: 0, s: 0, l: 0 }),
      function (t, e) {
        this.getHSL(Di), t.getHSL(Ui);
        var i = Ge.lerp(Di.h, Ui.h, e),
          n = Ge.lerp(Di.s, Ui.s, e),
          r = Ge.lerp(Di.l, Ui.l, e);
        return this.setHSL(i, n, r), this;
      }),
    equals: function (t) {
      return t.r === this.r && t.g === this.g && t.b === this.b;
    },
    fromArray: function (t, e) {
      return (
        void 0 === e && (e = 0),
        (this.r = t[e]),
        (this.g = t[e + 1]),
        (this.b = t[e + 2]),
        this
      );
    },
    toArray: function (t, e) {
      return (
        void 0 === t && (t = []),
        void 0 === e && (e = 0),
        (t[e] = this.r),
        (t[e + 1] = this.g),
        (t[e + 2] = this.b),
        t
      );
    },
    toJSON: function () {
      return this.getHex();
    }
  });
  var Wi,
    Xi,
    qi = {
      common: {
        diffuse: { value: new Hi(15658734) },
        opacity: { value: 1 },
        map: { value: null },
        uvTransform: { value: new We() },
        alphaMap: { value: null }
      },
      specularmap: { specularMap: { value: null } },
      envmap: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        reflectivity: { value: 1 },
        refractionRatio: { value: 0.98 },
        maxMipLevel: { value: 0 }
      },
      aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } },
      lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } },
      emissivemap: { emissiveMap: { value: null } },
      bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } },
      normalmap: { normalMap: { value: null }, normalScale: { value: new He(1, 1) } },
      displacementmap: {
        displacementMap: { value: null },
        displacementScale: { value: 1 },
        displacementBias: { value: 0 }
      },
      roughnessmap: { roughnessMap: { value: null } },
      metalnessmap: { metalnessMap: { value: null } },
      gradientmap: { gradientMap: { value: null } },
      fog: {
        fogDensity: { value: 25e-5 },
        fogNear: { value: 1 },
        fogFar: { value: 2e3 },
        fogColor: { value: new Hi(16777215) }
      },
      lights: {
        ambientLightColor: { value: [] },
        directionalLights: {
          value: [],
          properties: {
            direction: {},
            color: {},
            shadow: {},
            shadowBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        directionalShadowMap: { value: [] },
        directionalShadowMatrix: { value: [] },
        spotLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            direction: {},
            distance: {},
            coneCos: {},
            penumbraCos: {},
            decay: {},
            shadow: {},
            shadowBias: {},
            shadowRadius: {},
            shadowMapSize: {}
          }
        },
        spotShadowMap: { value: [] },
        spotShadowMatrix: { value: [] },
        pointLights: {
          value: [],
          properties: {
            color: {},
            position: {},
            decay: {},
            distance: {},
            shadow: {},
            shadowBias: {},
            shadowRadius: {},
            shadowMapSize: {},
            shadowCameraNear: {},
            shadowCameraFar: {}
          }
        },
        pointShadowMap: { value: [] },
        pointShadowMatrix: { value: [] },
        hemisphereLights: {
          value: [],
          properties: { direction: {}, skyColor: {}, groundColor: {} }
        },
        rectAreaLights: {
          value: [],
          properties: { color: {}, position: {}, width: {}, height: {} }
        }
      },
      points: {
        diffuse: { value: new Hi(15658734) },
        opacity: { value: 1 },
        size: { value: 1 },
        scale: { value: 1 },
        map: { value: null },
        uvTransform: { value: new We() }
      },
      sprite: {
        diffuse: { value: new Hi(15658734) },
        opacity: { value: 1 },
        center: { value: new He(0.5, 0.5) },
        rotation: { value: 0 },
        map: { value: null },
        uvTransform: { value: new We() }
      }
    },
    Yi = {
      basic: {
        uniforms: zi.merge([
          qi.common,
          qi.specularmap,
          qi.envmap,
          qi.aomap,
          qi.lightmap,
          qi.fog
        ]),
        vertexShader: Fi.meshbasic_vert,
        fragmentShader: Fi.meshbasic_frag
      },
      lambert: {
        uniforms: zi.merge([
          qi.common,
          qi.specularmap,
          qi.envmap,
          qi.aomap,
          qi.lightmap,
          qi.emissivemap,
          qi.fog,
          qi.lights,
          { emissive: { value: new Hi(0) } }
        ]),
        vertexShader: Fi.meshlambert_vert,
        fragmentShader: Fi.meshlambert_frag
      },
      phong: {
        uniforms: zi.merge([
          qi.common,
          qi.specularmap,
          qi.envmap,
          qi.aomap,
          qi.lightmap,
          qi.emissivemap,
          qi.bumpmap,
          qi.normalmap,
          qi.displacementmap,
          qi.gradientmap,
          qi.fog,
          qi.lights,
          {
            emissive: { value: new Hi(0) },
            specular: { value: new Hi(1118481) },
            shininess: { value: 30 }
          }
        ]),
        vertexShader: Fi.meshphong_vert,
        fragmentShader: Fi.meshphong_frag
      },
      standard: {
        uniforms: zi.merge([
          qi.common,
          qi.envmap,
          qi.aomap,
          qi.lightmap,
          qi.emissivemap,
          qi.bumpmap,
          qi.normalmap,
          qi.displacementmap,
          qi.roughnessmap,
          qi.metalnessmap,
          qi.fog,
          qi.lights,
          {
            emissive: { value: new Hi(0) },
            roughness: { value: 0.5 },
            metalness: { value: 0.5 },
            envMapIntensity: { value: 1 }
          }
        ]),
        vertexShader: Fi.meshphysical_vert,
        fragmentShader: Fi.meshphysical_frag
      },
      matcap: {
        uniforms: zi.merge([
          qi.common,
          qi.bumpmap,
          qi.normalmap,
          qi.displacementmap,
          qi.fog,
          { matcap: { value: null } }
        ]),
        vertexShader: Fi.meshmatcap_vert,
        fragmentShader: Fi.meshmatcap_frag
      },
      points: {
        uniforms: zi.merge([qi.points, qi.fog]),
        vertexShader: Fi.points_vert,
        fragmentShader: Fi.points_frag
      },
      dashed: {
        uniforms: zi.merge([
          qi.common,
          qi.fog,
          { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }
        ]),
        vertexShader: Fi.linedashed_vert,
        fragmentShader: Fi.linedashed_frag
      },
      depth: {
        uniforms: zi.merge([qi.common, qi.displacementmap]),
        vertexShader: Fi.depth_vert,
        fragmentShader: Fi.depth_frag
      },
      normal: {
        uniforms: zi.merge([
          qi.common,
          qi.bumpmap,
          qi.normalmap,
          qi.displacementmap,
          { opacity: { value: 1 } }
        ]),
        vertexShader: Fi.normal_vert,
        fragmentShader: Fi.normal_frag
      },
      sprite: {
        uniforms: zi.merge([qi.sprite, qi.fog]),
        vertexShader: Fi.sprite_vert,
        fragmentShader: Fi.sprite_frag
      },
      background: {
        uniforms: { t2D: { value: null } },
        vertexShader: Fi.background_vert,
        fragmentShader: Fi.background_frag
      },
      cube: {
        uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } },
        vertexShader: Fi.cube_vert,
        fragmentShader: Fi.cube_frag
      },
      equirect: {
        uniforms: { tEquirect: { value: null } },
        vertexShader: Fi.equirect_vert,
        fragmentShader: Fi.equirect_frag
      },
      distanceRGBA: {
        uniforms: zi.merge([
          qi.common,
          qi.displacementmap,
          {
            referencePosition: { value: new je() },
            nearDistance: { value: 1 },
            farDistance: { value: 1e3 }
          }
        ]),
        vertexShader: Fi.distanceRGBA_vert,
        fragmentShader: Fi.distanceRGBA_frag
      },
      shadow: {
        uniforms: zi.merge([
          qi.lights,
          qi.fog,
          { color: { value: new Hi(0) }, opacity: { value: 1 } }
        ]),
        vertexShader: Fi.shadow_vert,
        fragmentShader: Fi.shadow_frag
      }
    };
  function Ji() {
    var i = null,
      n = !1,
      r = null;
    function a(t, e) {
      !1 !== n && (r(t, e), i.requestAnimationFrame(a));
    }
    return {
      start: function () {
        !0 !== n && null !== r && (i.requestAnimationFrame(a), (n = !0));
      },
      stop: function () {
        n = !1;
      },
      setAnimationLoop: function (t) {
        r = t;
      },
      setContext: function (t) {
        i = t;
      }
    };
  }
  function Zi(c) {
    var h = new WeakMap();
    return {
      get: function (t) {
        return t.isInterleavedBufferAttribute && (t = t.data), h.get(t);
      },
      remove: function (t) {
        t.isInterleavedBufferAttribute && (t = t.data);
        var e = h.get(t);
        e && (c.deleteBuffer(e.buffer), h.delete(t));
      },
      update: function (t, e) {
        t.isInterleavedBufferAttribute && (t = t.data);
        var i,
          n,
          r,
          a,
          o,
          s = h.get(t);
        void 0 === s
          ? h.set(
              t,
              (function (t, e) {
                var i = t.array,
                  n = t.dynamic ? c.DYNAMIC_DRAW : c.STATIC_DRAW,
                  r = c.createBuffer();
                c.bindBuffer(e, r), c.bufferData(e, i, n), t.onUploadCallback();
                var a = c.FLOAT;
                return (
                  i instanceof Float32Array
                    ? (a = c.FLOAT)
                    : i instanceof Float64Array
                    ? console.warn(
                        'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.'
                      )
                    : i instanceof Uint16Array
                    ? (a = c.UNSIGNED_SHORT)
                    : i instanceof Int16Array
                    ? (a = c.SHORT)
                    : i instanceof Uint32Array
                    ? (a = c.UNSIGNED_INT)
                    : i instanceof Int32Array
                    ? (a = c.INT)
                    : i instanceof Int8Array
                    ? (a = c.BYTE)
                    : i instanceof Uint8Array && (a = c.UNSIGNED_BYTE),
                  {
                    buffer: r,
                    type: a,
                    bytesPerElement: i.BYTES_PER_ELEMENT,
                    version: t.version
                  }
                );
              })(t, e)
            )
          : s.version < t.version &&
            ((i = s.buffer),
            (r = e),
            (a = (n = t).array),
            (o = n.updateRange),
            c.bindBuffer(r, i),
            !1 === n.dynamic
              ? c.bufferData(r, a, c.STATIC_DRAW)
              : -1 === o.count
              ? c.bufferSubData(r, 0, a)
              : 0 === o.count
              ? console.error(
                  'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.'
                )
              : (c.bufferSubData(
                  r,
                  o.offset * a.BYTES_PER_ELEMENT,
                  a.subarray(o.offset, o.offset + o.count)
                ),
                (o.count = -1)),
            (s.version = t.version));
      }
    };
  }
  function Qi(t, e, i, n, r, a) {
    (this.a = t),
      (this.b = e),
      (this.c = i),
      (this.normal = n && n.isVector3 ? n : new je()),
      (this.vertexNormals = Array.isArray(n) ? n : []),
      (this.color = r && r.isColor ? r : new Hi()),
      (this.vertexColors = Array.isArray(r) ? r : []),
      (this.materialIndex = void 0 !== a ? a : 0);
  }
  function Ki(t, e, i, n) {
    (this._x = t || 0),
      (this._y = e || 0),
      (this._z = i || 0),
      (this._order = n || Ki.DefaultOrder);
  }
  function $i() {
    this.mask = 1;
  }
  (Yi.physical = {
    uniforms: zi.merge([
      Yi.standard.uniforms,
      { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }
    ]),
    vertexShader: Fi.meshphysical_vert,
    fragmentShader: Fi.meshphysical_frag
  }),
    Object.assign(Qi.prototype, {
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        (this.a = t.a),
          (this.b = t.b),
          (this.c = t.c),
          this.normal.copy(t.normal),
          this.color.copy(t.color),
          (this.materialIndex = t.materialIndex);
        for (var e = 0, i = t.vertexNormals.length; e < i; e++)
          this.vertexNormals[e] = t.vertexNormals[e].clone();
        for (e = 0, i = t.vertexColors.length; e < i; e++)
          this.vertexColors[e] = t.vertexColors[e].clone();
        return this;
      }
    }),
    (Ki.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX']),
    (Ki.DefaultOrder = 'XYZ'),
    Object.defineProperties(Ki.prototype, {
      x: {
        get: function () {
          return this._x;
        },
        set: function (t) {
          (this._x = t), this.onChangeCallback();
        }
      },
      y: {
        get: function () {
          return this._y;
        },
        set: function (t) {
          (this._y = t), this.onChangeCallback();
        }
      },
      z: {
        get: function () {
          return this._z;
        },
        set: function (t) {
          (this._z = t), this.onChangeCallback();
        }
      },
      order: {
        get: function () {
          return this._order;
        },
        set: function (t) {
          (this._order = t), this.onChangeCallback();
        }
      }
    }),
    Object.assign(Ki.prototype, {
      isEuler: !0,
      set: function (t, e, i, n) {
        return (
          (this._x = t),
          (this._y = e),
          (this._z = i),
          (this._order = n || this._order),
          this.onChangeCallback(),
          this
        );
      },
      clone: function () {
        return new this.constructor(this._x, this._y, this._z, this._order);
      },
      copy: function (t) {
        return (
          (this._x = t._x),
          (this._y = t._y),
          (this._z = t._z),
          (this._order = t._order),
          this.onChangeCallback(),
          this
        );
      },
      setFromRotationMatrix: function (t, e, i) {
        var n = Ge.clamp,
          r = t.elements,
          a = r[0],
          o = r[4],
          s = r[8],
          c = r[1],
          h = r[5],
          l = r[9],
          u = r[2],
          p = r[6],
          d = r[10];
        return (
          'XYZ' === (e = e || this._order)
            ? ((this._y = Math.asin(n(s, -1, 1))),
              Math.abs(s) < 0.99999
                ? ((this._x = Math.atan2(-l, d)), (this._z = Math.atan2(-o, a)))
                : ((this._x = Math.atan2(p, h)), (this._z = 0)))
            : 'YXZ' === e
            ? ((this._x = Math.asin(-n(l, -1, 1))),
              Math.abs(l) < 0.99999
                ? ((this._y = Math.atan2(s, d)), (this._z = Math.atan2(c, h)))
                : ((this._y = Math.atan2(-u, a)), (this._z = 0)))
            : 'ZXY' === e
            ? ((this._x = Math.asin(n(p, -1, 1))),
              Math.abs(p) < 0.99999
                ? ((this._y = Math.atan2(-u, d)), (this._z = Math.atan2(-o, h)))
                : ((this._y = 0), (this._z = Math.atan2(c, a))))
            : 'ZYX' === e
            ? ((this._y = Math.asin(-n(u, -1, 1))),
              Math.abs(u) < 0.99999
                ? ((this._x = Math.atan2(p, d)), (this._z = Math.atan2(c, a)))
                : ((this._x = 0), (this._z = Math.atan2(-o, h))))
            : 'YZX' === e
            ? ((this._z = Math.asin(n(c, -1, 1))),
              Math.abs(c) < 0.99999
                ? ((this._x = Math.atan2(-l, h)), (this._y = Math.atan2(-u, a)))
                : ((this._x = 0), (this._y = Math.atan2(s, d))))
            : 'XZY' === e
            ? ((this._z = Math.asin(-n(o, -1, 1))),
              Math.abs(o) < 0.99999
                ? ((this._x = Math.atan2(p, h)), (this._y = Math.atan2(s, a)))
                : ((this._x = Math.atan2(-l, d)), (this._y = 0)))
            : console.warn(
                'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + e
              ),
          (this._order = e),
          !1 !== i && this.onChangeCallback(),
          this
        );
      },
      setFromQuaternion:
        ((Xi = new Ve()),
        function (t, e, i) {
          return Xi.makeRotationFromQuaternion(t), this.setFromRotationMatrix(Xi, e, i);
        }),
      setFromVector3: function (t, e) {
        return this.set(t.x, t.y, t.z, e || this._order);
      },
      reorder:
        ((Wi = new ke()),
        function (t) {
          return Wi.setFromEuler(this), this.setFromQuaternion(Wi, t);
        }),
      equals: function (t) {
        return (
          t._x === this._x &&
          t._y === this._y &&
          t._z === this._z &&
          t._order === this._order
        );
      },
      fromArray: function (t) {
        return (
          (this._x = t[0]),
          (this._y = t[1]),
          (this._z = t[2]),
          void 0 !== t[3] && (this._order = t[3]),
          this.onChangeCallback(),
          this
        );
      },
      toArray: function (t, e) {
        return (
          void 0 === t && (t = []),
          void 0 === e && (e = 0),
          (t[e] = this._x),
          (t[e + 1] = this._y),
          (t[e + 2] = this._z),
          (t[e + 3] = this._order),
          t
        );
      },
      toVector3: function (t) {
        return t ? t.set(this._x, this._y, this._z) : new je(this._x, this._y, this._z);
      },
      onChange: function (t) {
        return (this.onChangeCallback = t), this;
      },
      onChangeCallback: function () {}
    }),
    Object.assign($i.prototype, {
      set: function (t) {
        this.mask = (1 << t) | 0;
      },
      enable: function (t) {
        this.mask |= (1 << t) | 0;
      },
      toggle: function (t) {
        this.mask ^= (1 << t) | 0;
      },
      disable: function (t) {
        this.mask &= ~((1 << t) | 0);
      },
      test: function (t) {
        return 0 != (this.mask & t.mask);
      }
    });
  var tn,
    en,
    nn,
    rn,
    an,
    on,
    sn,
    cn,
    hn,
    ln,
    un,
    pn,
    dn,
    fn,
    mn,
    gn,
    vn,
    yn,
    xn = 0;
  function bn() {
    Object.defineProperty(this, 'id', { value: xn++ }),
      (this.uuid = Ge.generateUUID()),
      (this.name = ''),
      (this.type = 'Object3D'),
      (this.parent = null),
      (this.children = []),
      (this.up = bn.DefaultUp.clone());
    var t = new je(),
      e = new Ki(),
      i = new ke(),
      n = new je(1, 1, 1);
    e.onChange(function () {
      i.setFromEuler(e, !1);
    }),
      i.onChange(function () {
        e.setFromQuaternion(i, void 0, !1);
      }),
      Object.defineProperties(this, {
        position: { enumerable: !0, value: t },
        rotation: { enumerable: !0, value: e },
        quaternion: { enumerable: !0, value: i },
        scale: { enumerable: !0, value: n },
        modelViewMatrix: { value: new Ve() },
        normalMatrix: { value: new We() }
      }),
      (this.matrix = new Ve()),
      (this.matrixWorld = new Ve()),
      (this.matrixAutoUpdate = bn.DefaultMatrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = !1),
      (this.layers = new $i()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.userData = {});
  }
  (bn.DefaultUp = new je(0, 1, 0)),
    (bn.DefaultMatrixAutoUpdate = !0),
    (bn.prototype = Object.assign(Object.create(e.prototype), {
      constructor: bn,
      isObject3D: !0,
      onBeforeRender: function () {},
      onAfterRender: function () {},
      applyMatrix: function (t) {
        this.matrix.multiplyMatrices(t, this.matrix),
          this.matrix.decompose(this.position, this.quaternion, this.scale);
      },
      applyQuaternion: function (t) {
        return this.quaternion.premultiply(t), this;
      },
      setRotationFromAxisAngle: function (t, e) {
        this.quaternion.setFromAxisAngle(t, e);
      },
      setRotationFromEuler: function (t) {
        this.quaternion.setFromEuler(t, !0);
      },
      setRotationFromMatrix: function (t) {
        this.quaternion.setFromRotationMatrix(t);
      },
      setRotationFromQuaternion: function (t) {
        this.quaternion.copy(t);
      },
      rotateOnAxis:
        ((yn = new ke()),
        function (t, e) {
          return yn.setFromAxisAngle(t, e), this.quaternion.multiply(yn), this;
        }),
      rotateOnWorldAxis:
        ((vn = new ke()),
        function (t, e) {
          return vn.setFromAxisAngle(t, e), this.quaternion.premultiply(vn), this;
        }),
      rotateX:
        ((gn = new je(1, 0, 0)),
        function (t) {
          return this.rotateOnAxis(gn, t);
        }),
      rotateY:
        ((mn = new je(0, 1, 0)),
        function (t) {
          return this.rotateOnAxis(mn, t);
        }),
      rotateZ:
        ((fn = new je(0, 0, 1)),
        function (t) {
          return this.rotateOnAxis(fn, t);
        }),
      translateOnAxis:
        ((dn = new je()),
        function (t, e) {
          return (
            dn.copy(t).applyQuaternion(this.quaternion),
            this.position.add(dn.multiplyScalar(e)),
            this
          );
        }),
      translateX:
        ((pn = new je(1, 0, 0)),
        function (t) {
          return this.translateOnAxis(pn, t);
        }),
      translateY:
        ((un = new je(0, 1, 0)),
        function (t) {
          return this.translateOnAxis(un, t);
        }),
      translateZ:
        ((ln = new je(0, 0, 1)),
        function (t) {
          return this.translateOnAxis(ln, t);
        }),
      localToWorld: function (t) {
        return t.applyMatrix4(this.matrixWorld);
      },
      worldToLocal:
        ((hn = new Ve()),
        function (t) {
          return t.applyMatrix4(hn.getInverse(this.matrixWorld));
        }),
      lookAt:
        ((an = new ke()),
        (on = new Ve()),
        (sn = new je()),
        (cn = new je()),
        function (t, e, i) {
          t.isVector3 ? sn.copy(t) : sn.set(t, e, i);
          var n = this.parent;
          this.updateWorldMatrix(!0, !1),
            cn.setFromMatrixPosition(this.matrixWorld),
            this.isCamera ? on.lookAt(cn, sn, this.up) : on.lookAt(sn, cn, this.up),
            this.quaternion.setFromRotationMatrix(on),
            n &&
              (on.extractRotation(n.matrixWorld),
              an.setFromRotationMatrix(on),
              this.quaternion.premultiply(an.inverse()));
        }),
      add: function (t) {
        if (1 < arguments.length) {
          for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
          return this;
        }
        return (
          t === this
            ? console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                t
              )
            : t && t.isObject3D
            ? (null !== t.parent && t.parent.remove(t),
              (t.parent = this),
              t.dispatchEvent({ type: 'added' }),
              this.children.push(t))
            : console.error(
                'THREE.Object3D.add: object not an instance of THREE.Object3D.',
                t
              ),
          this
        );
      },
      remove: function (t) {
        if (1 < arguments.length) {
          for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
          return this;
        }
        var i = this.children.indexOf(t);
        return (
          -1 !== i &&
            ((t.parent = null),
            t.dispatchEvent({ type: 'removed' }),
            this.children.splice(i, 1)),
          this
        );
      },
      getObjectById: function (t) {
        return this.getObjectByProperty('id', t);
      },
      getObjectByName: function (t) {
        return this.getObjectByProperty('name', t);
      },
      getObjectByProperty: function (t, e) {
        if (this[t] === e) return this;
        for (var i = 0, n = this.children.length; i < n; i++) {
          var r = this.children[i].getObjectByProperty(t, e);
          if (void 0 !== r) return r;
        }
      },
      getWorldPosition: function (t) {
        return (
          void 0 === t &&
            (console.warn('THREE.Object3D: .getWorldPosition() target is now required'),
            (t = new je())),
          this.updateMatrixWorld(!0),
          t.setFromMatrixPosition(this.matrixWorld)
        );
      },
      getWorldQuaternion:
        ((nn = new je()),
        (rn = new je()),
        function (t) {
          return (
            void 0 === t &&
              (console.warn(
                'THREE.Object3D: .getWorldQuaternion() target is now required'
              ),
              (t = new ke())),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(nn, t, rn),
            t
          );
        }),
      getWorldScale:
        ((tn = new je()),
        (en = new ke()),
        function (t) {
          return (
            void 0 === t &&
              (console.warn('THREE.Object3D: .getWorldScale() target is now required'),
              (t = new je())),
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(tn, en, t),
            t
          );
        }),
      getWorldDirection: function (t) {
        void 0 === t &&
          (console.warn('THREE.Object3D: .getWorldDirection() target is now required'),
          (t = new je())),
          this.updateMatrixWorld(!0);
        var e = this.matrixWorld.elements;
        return t.set(e[8], e[9], e[10]).normalize();
      },
      raycast: function () {},
      traverse: function (t) {
        t(this);
        for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t);
      },
      traverseVisible: function (t) {
        if (!1 !== this.visible) {
          t(this);
          for (var e = this.children, i = 0, n = e.length; i < n; i++)
            e[i].traverseVisible(t);
        }
      },
      traverseAncestors: function (t) {
        var e = this.parent;
        null !== e && (t(e), e.traverseAncestors(t));
      },
      updateMatrix: function () {
        this.matrix.compose(this.position, this.quaternion, this.scale),
          (this.matrixWorldNeedsUpdate = !0);
      },
      updateMatrixWorld: function (t) {
        this.matrixAutoUpdate && this.updateMatrix(),
          (this.matrixWorldNeedsUpdate || t) &&
            (null === this.parent
              ? this.matrixWorld.copy(this.matrix)
              : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            (t = !(this.matrixWorldNeedsUpdate = !1)));
        for (var e = this.children, i = 0, n = e.length; i < n; i++)
          e[i].updateMatrixWorld(t);
      },
      updateWorldMatrix: function (t, e) {
        var i = this.parent;
        if (
          (!0 === t && null !== i && i.updateWorldMatrix(!0, !1),
          this.matrixAutoUpdate && this.updateMatrix(),
          null === this.parent
            ? this.matrixWorld.copy(this.matrix)
            : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
          !0 === e)
        )
          for (var n = this.children, r = 0, a = n.length; r < a; r++)
            n[r].updateWorldMatrix(!1, !0);
      },
      toJSON: function (i) {
        var t = void 0 === i || 'string' == typeof i,
          e = {};
        t &&
          ((i = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }),
          (e.metadata = { version: 4.5, type: 'Object', generator: 'Object3D.toJSON' }));
        var n = {};
        function r(t, e) {
          return void 0 === t[e.uuid] && (t[e.uuid] = e.toJSON(i)), e.uuid;
        }
        if (
          ((n.uuid = this.uuid),
          (n.type = this.type),
          '' !== this.name && (n.name = this.name),
          !0 === this.castShadow && (n.castShadow = !0),
          !0 === this.receiveShadow && (n.receiveShadow = !0),
          !1 === this.visible && (n.visible = !1),
          !1 === this.frustumCulled && (n.frustumCulled = !1),
          0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
          '{}' !== JSON.stringify(this.userData) && (n.userData = this.userData),
          (n.layers = this.layers.mask),
          (n.matrix = this.matrix.toArray()),
          !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
          this.isMesh || this.isLine || this.isPoints)
        ) {
          n.geometry = r(i.geometries, this.geometry);
          var a = this.geometry.parameters;
          if (void 0 !== a && void 0 !== a.shapes) {
            var o = a.shapes;
            if (Array.isArray(o))
              for (var s = 0, c = o.length; s < c; s++) {
                var h = o[s];
                r(i.shapes, h);
              }
            else r(i.shapes, o);
          }
        }
        if (void 0 !== this.material)
          if (Array.isArray(this.material)) {
            var l = [];
            for (s = 0, c = this.material.length; s < c; s++)
              l.push(r(i.materials, this.material[s]));
            n.material = l;
          } else n.material = r(i.materials, this.material);
        if (0 < this.children.length) {
          n.children = [];
          for (s = 0; s < this.children.length; s++)
            n.children.push(this.children[s].toJSON(i).object);
        }
        if (t) {
          var u = m(i.geometries),
            p = m(i.materials),
            d = m(i.textures),
            f = m(i.images);
          o = m(i.shapes);
          0 < u.length && (e.geometries = u),
            0 < p.length && (e.materials = p),
            0 < d.length && (e.textures = d),
            0 < f.length && (e.images = f),
            0 < o.length && (e.shapes = o);
        }
        return (e.object = n), e;
        function m(t) {
          var e = [];
          for (var i in t) {
            var n = t[i];
            delete n.metadata, e.push(n);
          }
          return e;
        }
      },
      clone: function (t) {
        return new this.constructor().copy(this, t);
      },
      copy: function (t, e) {
        if (
          (void 0 === e && (e = !0),
          (this.name = t.name),
          this.up.copy(t.up),
          this.position.copy(t.position),
          this.quaternion.copy(t.quaternion),
          this.scale.copy(t.scale),
          this.matrix.copy(t.matrix),
          this.matrixWorld.copy(t.matrixWorld),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          (this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate),
          (this.layers.mask = t.layers.mask),
          (this.visible = t.visible),
          (this.castShadow = t.castShadow),
          (this.receiveShadow = t.receiveShadow),
          (this.frustumCulled = t.frustumCulled),
          (this.renderOrder = t.renderOrder),
          (this.userData = JSON.parse(JSON.stringify(t.userData))),
          !0 === e)
        )
          for (var i = 0; i < t.children.length; i++) {
            var n = t.children[i];
            this.add(n.clone());
          }
        return this;
      }
    }));
  var _n,
    wn,
    Mn,
    En,
    Tn,
    Sn,
    An,
    Ln = 0;
  function Rn() {
    Object.defineProperty(this, 'id', { value: (Ln += 2) }),
      (this.uuid = Ge.generateUUID()),
      (this.name = ''),
      (this.type = 'Geometry'),
      (this.vertices = []),
      (this.colors = []),
      (this.faces = []),
      (this.faceVertexUvs = [[]]),
      (this.morphTargets = []),
      (this.morphNormals = []),
      (this.skinWeights = []),
      (this.skinIndices = []),
      (this.lineDistances = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.elementsNeedUpdate = !1),
      (this.verticesNeedUpdate = !1),
      (this.uvsNeedUpdate = !1),
      (this.normalsNeedUpdate = !1),
      (this.colorsNeedUpdate = !1),
      (this.lineDistancesNeedUpdate = !1),
      (this.groupsNeedUpdate = !1);
  }
  function Pn(t, e, i) {
    if (Array.isArray(t))
      throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
    (this.name = ''),
      (this.array = t),
      (this.itemSize = e),
      (this.count = void 0 !== t ? t.length / e : 0),
      (this.normalized = !0 === i),
      (this.dynamic = !1),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0);
  }
  function Cn(t, e, i) {
    Pn.call(this, new Int8Array(t), e, i);
  }
  function On(t, e, i) {
    Pn.call(this, new Uint8Array(t), e, i);
  }
  function In(t, e, i) {
    Pn.call(this, new Uint8ClampedArray(t), e, i);
  }
  function Nn(t, e, i) {
    Pn.call(this, new Int16Array(t), e, i);
  }
  function Dn(t, e, i) {
    Pn.call(this, new Uint16Array(t), e, i);
  }
  function Un(t, e, i) {
    Pn.call(this, new Int32Array(t), e, i);
  }
  function Bn(t, e, i) {
    Pn.call(this, new Uint32Array(t), e, i);
  }
  function Fn(t, e, i) {
    Pn.call(this, new Float32Array(t), e, i);
  }
  function zn(t, e, i) {
    Pn.call(this, new Float64Array(t), e, i);
  }
  function Gn() {
    (this.vertices = []),
      (this.normals = []),
      (this.colors = []),
      (this.uvs = []),
      (this.uvs2 = []),
      (this.groups = []),
      (this.morphTargets = {}),
      (this.skinWeights = []),
      (this.skinIndices = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.verticesNeedUpdate = !1),
      (this.normalsNeedUpdate = !1),
      (this.colorsNeedUpdate = !1),
      (this.uvsNeedUpdate = !1),
      (this.groupsNeedUpdate = !1);
  }
  function Hn(t) {
    if (0 === t.length) return -1 / 0;
    for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
    return e;
  }
  (Rn.prototype = Object.assign(Object.create(e.prototype), {
    constructor: Rn,
    isGeometry: !0,
    applyMatrix: function (t) {
      for (
        var e = new We().getNormalMatrix(t), i = 0, n = this.vertices.length;
        i < n;
        i++
      ) {
        this.vertices[i].applyMatrix4(t);
      }
      for (i = 0, n = this.faces.length; i < n; i++) {
        var r = this.faces[i];
        r.normal.applyMatrix3(e).normalize();
        for (var a = 0, o = r.vertexNormals.length; a < o; a++)
          r.vertexNormals[a].applyMatrix3(e).normalize();
      }
      return (
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        (this.verticesNeedUpdate = !0),
        (this.normalsNeedUpdate = !0),
        this
      );
    },
    rotateX:
      ((An = new Ve()),
      function (t) {
        return An.makeRotationX(t), this.applyMatrix(An), this;
      }),
    rotateY:
      ((Sn = new Ve()),
      function (t) {
        return Sn.makeRotationY(t), this.applyMatrix(Sn), this;
      }),
    rotateZ:
      ((Tn = new Ve()),
      function (t) {
        return Tn.makeRotationZ(t), this.applyMatrix(Tn), this;
      }),
    translate:
      ((En = new Ve()),
      function (t, e, i) {
        return En.makeTranslation(t, e, i), this.applyMatrix(En), this;
      }),
    scale:
      ((Mn = new Ve()),
      function (t, e, i) {
        return Mn.makeScale(t, e, i), this.applyMatrix(Mn), this;
      }),
    lookAt:
      ((wn = new bn()),
      function (t) {
        wn.lookAt(t), wn.updateMatrix(), this.applyMatrix(wn.matrix);
      }),
    fromBufferGeometry: function (t) {
      var a = this,
        e = null !== t.index ? t.index.array : void 0,
        i = t.attributes,
        n = i.position.array,
        o = void 0 !== i.normal ? i.normal.array : void 0,
        s = void 0 !== i.color ? i.color.array : void 0,
        c = void 0 !== i.uv ? i.uv.array : void 0,
        h = void 0 !== i.uv2 ? i.uv2.array : void 0;
      void 0 !== h && (this.faceVertexUvs[1] = []);
      for (var l = [], u = [], p = [], r = 0, d = 0; r < n.length; r += 3, d += 2)
        a.vertices.push(new je(n[r], n[r + 1], n[r + 2])),
          void 0 !== o && l.push(new je(o[r], o[r + 1], o[r + 2])),
          void 0 !== s && a.colors.push(new Hi(s[r], s[r + 1], s[r + 2])),
          void 0 !== c && u.push(new He(c[d], c[d + 1])),
          void 0 !== h && p.push(new He(h[d], h[d + 1]));
      function f(t, e, i, n) {
        var r = new Qi(
          t,
          e,
          i,
          void 0 !== o ? [l[t].clone(), l[e].clone(), l[i].clone()] : [],
          void 0 !== s
            ? [a.colors[t].clone(), a.colors[e].clone(), a.colors[i].clone()]
            : [],
          n
        );
        a.faces.push(r),
          void 0 !== c &&
            a.faceVertexUvs[0].push([u[t].clone(), u[e].clone(), u[i].clone()]),
          void 0 !== h &&
            a.faceVertexUvs[1].push([p[t].clone(), p[e].clone(), p[i].clone()]);
      }
      var m = t.groups;
      if (0 < m.length)
        for (r = 0; r < m.length; r++)
          for (var g = m[r], v = g.start, y = ((d = v), v + g.count); d < y; d += 3)
            void 0 !== e
              ? f(e[d], e[d + 1], e[d + 2], g.materialIndex)
              : f(d, d + 1, d + 2, g.materialIndex);
      else if (void 0 !== e)
        for (r = 0; r < e.length; r += 3) f(e[r], e[r + 1], e[r + 2]);
      else for (r = 0; r < n.length / 3; r += 3) f(r, r + 1, r + 2);
      return (
        this.computeFaceNormals(),
        null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
        null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
        this
      );
    },
    center:
      ((_n = new je()),
      function () {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(_n).negate(),
          this.translate(_n.x, _n.y, _n.z),
          this
        );
      }),
    normalize: function () {
      this.computeBoundingSphere();
      var t = this.boundingSphere.center,
        e = this.boundingSphere.radius,
        i = 0 === e ? 1 : 1 / e,
        n = new Ve();
      return (
        n.set(i, 0, 0, -i * t.x, 0, i, 0, -i * t.y, 0, 0, i, -i * t.z, 0, 0, 0, 1),
        this.applyMatrix(n),
        this
      );
    },
    computeFaceNormals: function () {
      for (var t = new je(), e = new je(), i = 0, n = this.faces.length; i < n; i++) {
        var r = this.faces[i],
          a = this.vertices[r.a],
          o = this.vertices[r.b],
          s = this.vertices[r.c];
        t.subVectors(s, o),
          e.subVectors(a, o),
          t.cross(e),
          t.normalize(),
          r.normal.copy(t);
      }
    },
    computeVertexNormals: function (t) {
      var e, i, n, r, a, o;
      for (
        void 0 === t && (t = !0),
          o = new Array(this.vertices.length),
          e = 0,
          i = this.vertices.length;
        e < i;
        e++
      )
        o[e] = new je();
      if (t) {
        var s,
          c,
          h,
          l = new je(),
          u = new je();
        for (n = 0, r = this.faces.length; n < r; n++)
          (a = this.faces[n]),
            (s = this.vertices[a.a]),
            (c = this.vertices[a.b]),
            (h = this.vertices[a.c]),
            l.subVectors(h, c),
            u.subVectors(s, c),
            l.cross(u),
            o[a.a].add(l),
            o[a.b].add(l),
            o[a.c].add(l);
      } else
        for (this.computeFaceNormals(), n = 0, r = this.faces.length; n < r; n++)
          o[(a = this.faces[n]).a].add(a.normal),
            o[a.b].add(a.normal),
            o[a.c].add(a.normal);
      for (e = 0, i = this.vertices.length; e < i; e++) o[e].normalize();
      for (n = 0, r = this.faces.length; n < r; n++) {
        var p = (a = this.faces[n]).vertexNormals;
        3 === p.length
          ? (p[0].copy(o[a.a]), p[1].copy(o[a.b]), p[2].copy(o[a.c]))
          : ((p[0] = o[a.a].clone()), (p[1] = o[a.b].clone()), (p[2] = o[a.c].clone()));
      }
      0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeFlatVertexNormals: function () {
      var t, e, i;
      for (this.computeFaceNormals(), t = 0, e = this.faces.length; t < e; t++) {
        var n = (i = this.faces[t]).vertexNormals;
        3 === n.length
          ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal))
          : ((n[0] = i.normal.clone()),
            (n[1] = i.normal.clone()),
            (n[2] = i.normal.clone()));
      }
      0 < this.faces.length && (this.normalsNeedUpdate = !0);
    },
    computeMorphNormals: function () {
      var t, e, i, n, r;
      for (i = 0, n = this.faces.length; i < n; i++)
        for (
          (r = this.faces[i]).__originalFaceNormal
            ? r.__originalFaceNormal.copy(r.normal)
            : (r.__originalFaceNormal = r.normal.clone()),
            r.__originalVertexNormals || (r.__originalVertexNormals = []),
            t = 0,
            e = r.vertexNormals.length;
          t < e;
          t++
        )
          r.__originalVertexNormals[t]
            ? r.__originalVertexNormals[t].copy(r.vertexNormals[t])
            : (r.__originalVertexNormals[t] = r.vertexNormals[t].clone());
      var a = new Rn();
      for (a.faces = this.faces, t = 0, e = this.morphTargets.length; t < e; t++) {
        if (!this.morphNormals[t]) {
          (this.morphNormals[t] = {}),
            (this.morphNormals[t].faceNormals = []),
            (this.morphNormals[t].vertexNormals = []);
          var o = this.morphNormals[t].faceNormals,
            s = this.morphNormals[t].vertexNormals;
          for (i = 0, n = this.faces.length; i < n; i++)
            (c = new je()),
              (h = { a: new je(), b: new je(), c: new je() }),
              o.push(c),
              s.push(h);
        }
        var c,
          h,
          l = this.morphNormals[t];
        for (
          a.vertices = this.morphTargets[t].vertices,
            a.computeFaceNormals(),
            a.computeVertexNormals(),
            i = 0,
            n = this.faces.length;
          i < n;
          i++
        )
          (r = this.faces[i]),
            (c = l.faceNormals[i]),
            (h = l.vertexNormals[i]),
            c.copy(r.normal),
            h.a.copy(r.vertexNormals[0]),
            h.b.copy(r.vertexNormals[1]),
            h.c.copy(r.vertexNormals[2]);
      }
      for (i = 0, n = this.faces.length; i < n; i++)
        ((r = this.faces[i]).normal = r.__originalFaceNormal),
          (r.vertexNormals = r.__originalVertexNormals);
    },
    computeBoundingBox: function () {
      null === this.boundingBox && (this.boundingBox = new Ri()),
        this.boundingBox.setFromPoints(this.vertices);
    },
    computeBoundingSphere: function () {
      null === this.boundingSphere && (this.boundingSphere = new Oi()),
        this.boundingSphere.setFromPoints(this.vertices);
    },
    merge: function (t, e, i) {
      if (t && t.isGeometry) {
        var n,
          r = this.vertices.length,
          a = this.vertices,
          o = t.vertices,
          s = this.faces,
          c = t.faces,
          h = this.faceVertexUvs[0],
          l = t.faceVertexUvs[0],
          u = this.colors,
          p = t.colors;
        void 0 === i && (i = 0), void 0 !== e && (n = new We().getNormalMatrix(e));
        for (var d = 0, f = o.length; d < f; d++) {
          var m = o[d].clone();
          void 0 !== e && m.applyMatrix4(e), a.push(m);
        }
        for (d = 0, f = p.length; d < f; d++) u.push(p[d].clone());
        for (d = 0, f = c.length; d < f; d++) {
          var g,
            v,
            y,
            x = c[d],
            b = x.vertexNormals,
            _ = x.vertexColors;
          (g = new Qi(x.a + r, x.b + r, x.c + r)).normal.copy(x.normal),
            void 0 !== n && g.normal.applyMatrix3(n).normalize();
          for (var w = 0, M = b.length; w < M; w++)
            (v = b[w].clone()),
              void 0 !== n && v.applyMatrix3(n).normalize(),
              g.vertexNormals.push(v);
          g.color.copy(x.color);
          for (w = 0, M = _.length; w < M; w++)
            (y = _[w]), g.vertexColors.push(y.clone());
          (g.materialIndex = x.materialIndex + i), s.push(g);
        }
        for (d = 0, f = l.length; d < f; d++) {
          var E = l[d],
            T = [];
          if (void 0 !== E) {
            for (w = 0, M = E.length; w < M; w++) T.push(E[w].clone());
            h.push(T);
          }
        }
      } else
        console.error(
          'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.',
          t
        );
    },
    mergeMesh: function (t) {
      t && t.isMesh
        ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix))
        : console.error(
            'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.',
            t
          );
    },
    mergeVertices: function () {
      var t,
        e,
        i,
        n,
        r,
        a,
        o,
        s,
        c = {},
        h = [],
        l = [],
        u = Math.pow(10, 4);
      for (i = 0, n = this.vertices.length; i < n; i++)
        (t = this.vertices[i]),
          void 0 ===
          c[
            (e =
              Math.round(t.x * u) + '_' + Math.round(t.y * u) + '_' + Math.round(t.z * u))
          ]
            ? ((c[e] = i), h.push(this.vertices[i]), (l[i] = h.length - 1))
            : (l[i] = l[c[e]]);
      var p = [];
      for (i = 0, n = this.faces.length; i < n; i++) {
        ((r = this.faces[i]).a = l[r.a]),
          (r.b = l[r.b]),
          (r.c = l[r.c]),
          (a = [r.a, r.b, r.c]);
        for (var d = 0; d < 3; d++)
          if (a[d] === a[(d + 1) % 3]) {
            p.push(i);
            break;
          }
      }
      for (i = p.length - 1; 0 <= i; i--) {
        var f = p[i];
        for (this.faces.splice(f, 1), o = 0, s = this.faceVertexUvs.length; o < s; o++)
          this.faceVertexUvs[o].splice(f, 1);
      }
      var m = this.vertices.length - h.length;
      return (this.vertices = h), m;
    },
    setFromPoints: function (t) {
      this.vertices = [];
      for (var e = 0, i = t.length; e < i; e++) {
        var n = t[e];
        this.vertices.push(new je(n.x, n.y, n.z || 0));
      }
      return this;
    },
    sortFacesByMaterialIndex: function () {
      for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
      t.sort(function (t, e) {
        return t.materialIndex - e.materialIndex;
      });
      var n,
        r,
        a = this.faceVertexUvs[0],
        o = this.faceVertexUvs[1];
      a && a.length === e && (n = []), o && o.length === e && (r = []);
      for (i = 0; i < e; i++) {
        var s = t[i]._id;
        n && n.push(a[s]), r && r.push(o[s]);
      }
      n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r);
    },
    toJSON: function () {
      var t = {
        metadata: { version: 4.5, type: 'Geometry', generator: 'Geometry.toJSON' }
      };
      if (
        ((t.uuid = this.uuid),
        (t.type = this.type),
        '' !== this.name && (t.name = this.name),
        void 0 !== this.parameters)
      ) {
        var e = this.parameters;
        for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
        return t;
      }
      for (var n = [], r = 0; r < this.vertices.length; r++) {
        var a = this.vertices[r];
        n.push(a.x, a.y, a.z);
      }
      var o = [],
        s = [],
        c = {},
        h = [],
        l = {},
        u = [],
        p = {};
      for (r = 0; r < this.faces.length; r++) {
        var d = this.faces[r],
          f = void 0 !== this.faceVertexUvs[0][r],
          m = 0 < d.normal.length(),
          g = 0 < d.vertexNormals.length,
          v = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
          y = 0 < d.vertexColors.length,
          x = 0;
        if (
          ((x = M(x, 0, 0)),
          (x = M(x, 1, !0)),
          (x = M(x, 2, !1)),
          (x = M(x, 3, f)),
          (x = M(x, 4, m)),
          (x = M(x, 5, g)),
          (x = M(x, 6, v)),
          (x = M(x, 7, y)),
          o.push(x),
          o.push(d.a, d.b, d.c),
          o.push(d.materialIndex),
          f)
        ) {
          var b = this.faceVertexUvs[0][r];
          o.push(S(b[0]), S(b[1]), S(b[2]));
        }
        if ((m && o.push(E(d.normal)), g)) {
          var _ = d.vertexNormals;
          o.push(E(_[0]), E(_[1]), E(_[2]));
        }
        if ((v && o.push(T(d.color)), y)) {
          var w = d.vertexColors;
          o.push(T(w[0]), T(w[1]), T(w[2]));
        }
      }
      function M(t, e, i) {
        return i ? t | (1 << e) : t & ~(1 << e);
      }
      function E(t) {
        var e = t.x.toString() + t.y.toString() + t.z.toString();
        return void 0 !== c[e] || ((c[e] = s.length / 3), s.push(t.x, t.y, t.z)), c[e];
      }
      function T(t) {
        var e = t.r.toString() + t.g.toString() + t.b.toString();
        return void 0 !== l[e] || ((l[e] = h.length), h.push(t.getHex())), l[e];
      }
      function S(t) {
        var e = t.x.toString() + t.y.toString();
        return void 0 !== p[e] || ((p[e] = u.length / 2), u.push(t.x, t.y)), p[e];
      }
      return (
        (t.data = {}),
        (t.data.vertices = n),
        (t.data.normals = s),
        0 < h.length && (t.data.colors = h),
        0 < u.length && (t.data.uvs = [u]),
        (t.data.faces = o),
        t
      );
    },
    clone: function () {
      return new Rn().copy(this);
    },
    copy: function (t) {
      var e, i, n, r, a, o;
      (this.vertices = []),
        (this.colors = []),
        (this.faces = []),
        (this.faceVertexUvs = [[]]),
        (this.morphTargets = []),
        (this.morphNormals = []),
        (this.skinWeights = []),
        (this.skinIndices = []),
        (this.lineDistances = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.name = t.name);
      var s = t.vertices;
      for (e = 0, i = s.length; e < i; e++) this.vertices.push(s[e].clone());
      var c = t.colors;
      for (e = 0, i = c.length; e < i; e++) this.colors.push(c[e].clone());
      var h = t.faces;
      for (e = 0, i = h.length; e < i; e++) this.faces.push(h[e].clone());
      for (e = 0, i = t.faceVertexUvs.length; e < i; e++) {
        var l = t.faceVertexUvs[e];
        for (
          void 0 === this.faceVertexUvs[e] && (this.faceVertexUvs[e] = []),
            n = 0,
            r = l.length;
          n < r;
          n++
        ) {
          var u = l[n],
            p = [];
          for (a = 0, o = u.length; a < o; a++) {
            var d = u[a];
            p.push(d.clone());
          }
          this.faceVertexUvs[e].push(p);
        }
      }
      var f = t.morphTargets;
      for (e = 0, i = f.length; e < i; e++) {
        var m = {};
        if (((m.name = f[e].name), void 0 !== f[e].vertices))
          for (m.vertices = [], n = 0, r = f[e].vertices.length; n < r; n++)
            m.vertices.push(f[e].vertices[n].clone());
        if (void 0 !== f[e].normals)
          for (m.normals = [], n = 0, r = f[e].normals.length; n < r; n++)
            m.normals.push(f[e].normals[n].clone());
        this.morphTargets.push(m);
      }
      var g = t.morphNormals;
      for (e = 0, i = g.length; e < i; e++) {
        var v = {};
        if (void 0 !== g[e].vertexNormals)
          for (v.vertexNormals = [], n = 0, r = g[e].vertexNormals.length; n < r; n++) {
            var y = g[e].vertexNormals[n],
              x = {};
            (x.a = y.a.clone()),
              (x.b = y.b.clone()),
              (x.c = y.c.clone()),
              v.vertexNormals.push(x);
          }
        if (void 0 !== g[e].faceNormals)
          for (v.faceNormals = [], n = 0, r = g[e].faceNormals.length; n < r; n++)
            v.faceNormals.push(g[e].faceNormals[n].clone());
        this.morphNormals.push(v);
      }
      var b = t.skinWeights;
      for (e = 0, i = b.length; e < i; e++) this.skinWeights.push(b[e].clone());
      var _ = t.skinIndices;
      for (e = 0, i = _.length; e < i; e++) this.skinIndices.push(_[e].clone());
      var w = t.lineDistances;
      for (e = 0, i = w.length; e < i; e++) this.lineDistances.push(w[e]);
      var M = t.boundingBox;
      null !== M && (this.boundingBox = M.clone());
      var E = t.boundingSphere;
      return (
        null !== E && (this.boundingSphere = E.clone()),
        (this.elementsNeedUpdate = t.elementsNeedUpdate),
        (this.verticesNeedUpdate = t.verticesNeedUpdate),
        (this.uvsNeedUpdate = t.uvsNeedUpdate),
        (this.normalsNeedUpdate = t.normalsNeedUpdate),
        (this.colorsNeedUpdate = t.colorsNeedUpdate),
        (this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate),
        (this.groupsNeedUpdate = t.groupsNeedUpdate),
        this
      );
    },
    dispose: function () {
      this.dispatchEvent({ type: 'dispose' });
    }
  })),
    Object.defineProperty(Pn.prototype, 'needsUpdate', {
      set: function (t) {
        !0 === t && this.version++;
      }
    }),
    Object.assign(Pn.prototype, {
      isBufferAttribute: !0,
      onUploadCallback: function () {},
      setArray: function (t) {
        if (Array.isArray(t))
          throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        return (
          (this.count = void 0 !== t ? t.length / this.itemSize : 0),
          (this.array = t),
          this
        );
      },
      setDynamic: function (t) {
        return (this.dynamic = t), this;
      },
      copy: function (t) {
        return (
          (this.name = t.name),
          (this.array = new t.array.constructor(t.array)),
          (this.itemSize = t.itemSize),
          (this.count = t.count),
          (this.normalized = t.normalized),
          (this.dynamic = t.dynamic),
          this
        );
      },
      copyAt: function (t, e, i) {
        (t *= this.itemSize), (i *= e.itemSize);
        for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
        return this;
      },
      copyArray: function (t) {
        return this.array.set(t), this;
      },
      copyColorsArray: function (t) {
        for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
          var a = t[n];
          void 0 === a &&
            (console.warn(
              'THREE.BufferAttribute.copyColorsArray(): color is undefined',
              n
            ),
            (a = new Hi())),
            (e[i++] = a.r),
            (e[i++] = a.g),
            (e[i++] = a.b);
        }
        return this;
      },
      copyVector2sArray: function (t) {
        for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
          var a = t[n];
          void 0 === a &&
            (console.warn(
              'THREE.BufferAttribute.copyVector2sArray(): vector is undefined',
              n
            ),
            (a = new He())),
            (e[i++] = a.x),
            (e[i++] = a.y);
        }
        return this;
      },
      copyVector3sArray: function (t) {
        for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
          var a = t[n];
          void 0 === a &&
            (console.warn(
              'THREE.BufferAttribute.copyVector3sArray(): vector is undefined',
              n
            ),
            (a = new je())),
            (e[i++] = a.x),
            (e[i++] = a.y),
            (e[i++] = a.z);
        }
        return this;
      },
      copyVector4sArray: function (t) {
        for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
          var a = t[n];
          void 0 === a &&
            (console.warn(
              'THREE.BufferAttribute.copyVector4sArray(): vector is undefined',
              n
            ),
            (a = new Ti())),
            (e[i++] = a.x),
            (e[i++] = a.y),
            (e[i++] = a.z),
            (e[i++] = a.w);
        }
        return this;
      },
      set: function (t, e) {
        return void 0 === e && (e = 0), this.array.set(t, e), this;
      },
      getX: function (t) {
        return this.array[t * this.itemSize];
      },
      setX: function (t, e) {
        return (this.array[t * this.itemSize] = e), this;
      },
      getY: function (t) {
        return this.array[t * this.itemSize + 1];
      },
      setY: function (t, e) {
        return (this.array[t * this.itemSize + 1] = e), this;
      },
      getZ: function (t) {
        return this.array[t * this.itemSize + 2];
      },
      setZ: function (t, e) {
        return (this.array[t * this.itemSize + 2] = e), this;
      },
      getW: function (t) {
        return this.array[t * this.itemSize + 3];
      },
      setW: function (t, e) {
        return (this.array[t * this.itemSize + 3] = e), this;
      },
      setXY: function (t, e, i) {
        return (
          (t *= this.itemSize), (this.array[t + 0] = e), (this.array[t + 1] = i), this
        );
      },
      setXYZ: function (t, e, i, n) {
        return (
          (t *= this.itemSize),
          (this.array[t + 0] = e),
          (this.array[t + 1] = i),
          (this.array[t + 2] = n),
          this
        );
      },
      setXYZW: function (t, e, i, n, r) {
        return (
          (t *= this.itemSize),
          (this.array[t + 0] = e),
          (this.array[t + 1] = i),
          (this.array[t + 2] = n),
          (this.array[t + 3] = r),
          this
        );
      },
      onUpload: function (t) {
        return (this.onUploadCallback = t), this;
      },
      clone: function () {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
    }),
    ((Cn.prototype = Object.create(Pn.prototype)).constructor = Cn),
    ((On.prototype = Object.create(Pn.prototype)).constructor = On),
    ((In.prototype = Object.create(Pn.prototype)).constructor = In),
    ((Nn.prototype = Object.create(Pn.prototype)).constructor = Nn),
    ((Dn.prototype = Object.create(Pn.prototype)).constructor = Dn),
    ((Un.prototype = Object.create(Pn.prototype)).constructor = Un),
    ((Bn.prototype = Object.create(Pn.prototype)).constructor = Bn),
    ((Fn.prototype = Object.create(Pn.prototype)).constructor = Fn),
    ((zn.prototype = Object.create(Pn.prototype)).constructor = zn),
    Object.assign(Gn.prototype, {
      computeGroups: function (t) {
        for (var e, i = [], n = void 0, r = t.faces, a = 0; a < r.length; a++) {
          var o = r[a];
          o.materialIndex !== n &&
            ((n = o.materialIndex),
            void 0 !== e && ((e.count = 3 * a - e.start), i.push(e)),
            (e = { start: 3 * a, materialIndex: n }));
        }
        void 0 !== e && ((e.count = 3 * a - e.start), i.push(e)), (this.groups = i);
      },
      fromGeometry: function (t) {
        var e,
          i = t.faces,
          n = t.vertices,
          r = t.faceVertexUvs,
          a = r[0] && 0 < r[0].length,
          o = r[1] && 0 < r[1].length,
          s = t.morphTargets,
          c = s.length;
        if (0 < c) {
          e = [];
          for (var h = 0; h < c; h++) e[h] = { name: s[h].name, data: [] };
          this.morphTargets.position = e;
        }
        var l,
          u = t.morphNormals,
          p = u.length;
        if (0 < p) {
          l = [];
          for (h = 0; h < p; h++) l[h] = { name: u[h].name, data: [] };
          this.morphTargets.normal = l;
        }
        var d = t.skinIndices,
          f = t.skinWeights,
          m = d.length === n.length,
          g = f.length === n.length;
        0 < n.length &&
          0 === i.length &&
          console.error('THREE.DirectGeometry: Faceless geometries are not supported.');
        for (h = 0; h < i.length; h++) {
          var v = i[h];
          this.vertices.push(n[v.a], n[v.b], n[v.c]);
          var y = v.vertexNormals;
          if (3 === y.length) this.normals.push(y[0], y[1], y[2]);
          else {
            var x = v.normal;
            this.normals.push(x, x, x);
          }
          var b,
            _ = v.vertexColors;
          if (3 === _.length) this.colors.push(_[0], _[1], _[2]);
          else {
            var w = v.color;
            this.colors.push(w, w, w);
          }
          if (!0 === a)
            void 0 !== (b = r[0][h])
              ? this.uvs.push(b[0], b[1], b[2])
              : (console.warn(
                  'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ',
                  h
                ),
                this.uvs.push(new He(), new He(), new He()));
          if (!0 === o)
            void 0 !== (b = r[1][h])
              ? this.uvs2.push(b[0], b[1], b[2])
              : (console.warn(
                  'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ',
                  h
                ),
                this.uvs2.push(new He(), new He(), new He()));
          for (var M = 0; M < c; M++) {
            var E = s[M].vertices;
            e[M].data.push(E[v.a], E[v.b], E[v.c]);
          }
          for (M = 0; M < p; M++) {
            var T = u[M].vertexNormals[h];
            l[M].data.push(T.a, T.b, T.c);
          }
          m && this.skinIndices.push(d[v.a], d[v.b], d[v.c]),
            g && this.skinWeights.push(f[v.a], f[v.b], f[v.c]);
        }
        return (
          this.computeGroups(t),
          (this.verticesNeedUpdate = t.verticesNeedUpdate),
          (this.normalsNeedUpdate = t.normalsNeedUpdate),
          (this.colorsNeedUpdate = t.colorsNeedUpdate),
          (this.uvsNeedUpdate = t.uvsNeedUpdate),
          (this.groupsNeedUpdate = t.groupsNeedUpdate),
          this
        );
      }
    });
  var Vn,
    kn,
    jn,
    Wn,
    Xn,
    qn,
    Yn,
    Jn,
    Zn,
    Qn,
    Kn = 1;
  function $n() {
    Object.defineProperty(this, 'id', { value: (Kn += 2) }),
      (this.uuid = Ge.generateUUID()),
      (this.name = ''),
      (this.type = 'BufferGeometry'),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  function tr(t, e, i, n, r, a) {
    Rn.call(this),
      (this.type = 'BoxGeometry'),
      (this.parameters = {
        width: t,
        height: e,
        depth: i,
        widthSegments: n,
        heightSegments: r,
        depthSegments: a
      }),
      this.fromBufferGeometry(new er(t, e, i, n, r, a)),
      this.mergeVertices();
  }
  function er(t, e, i, n, r, a) {
    $n.call(this),
      (this.type = 'BoxBufferGeometry'),
      (this.parameters = {
        width: t,
        height: e,
        depth: i,
        widthSegments: n,
        heightSegments: r,
        depthSegments: a
      });
    var R = this;
    (t = t || 1),
      (e = e || 1),
      (i = i || 1),
      (n = Math.floor(n) || 1),
      (r = Math.floor(r) || 1),
      (a = Math.floor(a) || 1);
    var P = [],
      C = [],
      O = [],
      I = [],
      N = 0,
      D = 0;
    function o(t, e, i, n, r, a, o, s, c, h, l) {
      var u,
        p,
        d = a / c,
        f = o / h,
        m = a / 2,
        g = o / 2,
        v = s / 2,
        y = c + 1,
        x = h + 1,
        b = 0,
        _ = 0,
        w = new je();
      for (p = 0; p < x; p++) {
        var M = p * f - g;
        for (u = 0; u < y; u++) {
          var E = u * d - m;
          (w[t] = E * n),
            (w[e] = M * r),
            (w[i] = v),
            C.push(w.x, w.y, w.z),
            (w[t] = 0),
            (w[e] = 0),
            (w[i] = 0 < s ? 1 : -1),
            O.push(w.x, w.y, w.z),
            I.push(u / c),
            I.push(1 - p / h),
            (b += 1);
        }
      }
      for (p = 0; p < h; p++)
        for (u = 0; u < c; u++) {
          var T = N + u + y * p,
            S = N + u + y * (p + 1),
            A = N + (u + 1) + y * (p + 1),
            L = N + (u + 1) + y * p;
          P.push(T, S, L), P.push(S, A, L), (_ += 6);
        }
      R.addGroup(D, _, l), (D += _), (N += b);
    }
    o('z', 'y', 'x', -1, -1, i, e, t, a, r, 0),
      o('z', 'y', 'x', 1, -1, i, e, -t, a, r, 1),
      o('x', 'z', 'y', 1, 1, t, i, e, n, a, 2),
      o('x', 'z', 'y', 1, -1, t, i, -e, n, a, 3),
      o('x', 'y', 'z', 1, -1, t, e, i, n, r, 4),
      o('x', 'y', 'z', -1, -1, t, e, -i, n, r, 5),
      this.setIndex(P),
      this.addAttribute('position', new Fn(C, 3)),
      this.addAttribute('normal', new Fn(O, 3)),
      this.addAttribute('uv', new Fn(I, 2));
  }
  function ir(t, e, i, n) {
    Rn.call(this),
      (this.type = 'PlaneGeometry'),
      (this.parameters = { width: t, height: e, widthSegments: i, heightSegments: n }),
      this.fromBufferGeometry(new nr(t, e, i, n)),
      this.mergeVertices();
  }
  function nr(t, e, i, n) {
    $n.call(this),
      (this.type = 'PlaneBufferGeometry'),
      (this.parameters = { width: t, height: e, widthSegments: i, heightSegments: n });
    var r,
      a,
      o = (t = t || 1) / 2,
      s = (e = e || 1) / 2,
      c = Math.floor(i) || 1,
      h = Math.floor(n) || 1,
      l = c + 1,
      u = h + 1,
      p = t / c,
      d = e / h,
      f = [],
      m = [],
      g = [],
      v = [];
    for (a = 0; a < u; a++) {
      var y = a * d - s;
      for (r = 0; r < l; r++) {
        var x = r * p - o;
        m.push(x, -y, 0), g.push(0, 0, 1), v.push(r / c), v.push(1 - a / h);
      }
    }
    for (a = 0; a < h; a++)
      for (r = 0; r < c; r++) {
        var b = r + l * a,
          _ = r + l * (a + 1),
          w = r + 1 + l * (a + 1),
          M = r + 1 + l * a;
        f.push(b, _, M), f.push(_, w, M);
      }
    this.setIndex(f),
      this.addAttribute('position', new Fn(m, 3)),
      this.addAttribute('normal', new Fn(g, 3)),
      this.addAttribute('uv', new Fn(v, 2));
  }
  ($n.prototype = Object.assign(Object.create(e.prototype), {
    constructor: $n,
    isBufferGeometry: !0,
    getIndex: function () {
      return this.index;
    },
    setIndex: function (t) {
      Array.isArray(t)
        ? (this.index = new (65535 < Hn(t) ? Bn : Dn)(t, 1))
        : (this.index = t);
    },
    addAttribute: function (t, e) {
      return (e && e.isBufferAttribute) || (e && e.isInterleavedBufferAttribute)
        ? ('index' === t
            ? (console.warn(
                'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.'
              ),
              this.setIndex(e))
            : (this.attributes[t] = e),
          this)
        : (console.warn(
            'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).'
          ),
          this.addAttribute(t, new Pn(e, arguments[2])));
    },
    getAttribute: function (t) {
      return this.attributes[t];
    },
    removeAttribute: function (t) {
      return delete this.attributes[t], this;
    },
    addGroup: function (t, e, i) {
      this.groups.push({ start: t, count: e, materialIndex: void 0 !== i ? i : 0 });
    },
    clearGroups: function () {
      this.groups = [];
    },
    setDrawRange: function (t, e) {
      (this.drawRange.start = t), (this.drawRange.count = e);
    },
    applyMatrix: function (t) {
      var e = this.attributes.position;
      void 0 !== e && (t.applyToBufferAttribute(e), (e.needsUpdate = !0));
      var i = this.attributes.normal;
      void 0 !== i &&
        (new We().getNormalMatrix(t).applyToBufferAttribute(i), (i.needsUpdate = !0));
      return (
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
      );
    },
    rotateX:
      ((Qn = new Ve()),
      function (t) {
        return Qn.makeRotationX(t), this.applyMatrix(Qn), this;
      }),
    rotateY:
      ((Zn = new Ve()),
      function (t) {
        return Zn.makeRotationY(t), this.applyMatrix(Zn), this;
      }),
    rotateZ:
      ((Jn = new Ve()),
      function (t) {
        return Jn.makeRotationZ(t), this.applyMatrix(Jn), this;
      }),
    translate:
      ((Yn = new Ve()),
      function (t, e, i) {
        return Yn.makeTranslation(t, e, i), this.applyMatrix(Yn), this;
      }),
    scale:
      ((qn = new Ve()),
      function (t, e, i) {
        return qn.makeScale(t, e, i), this.applyMatrix(qn), this;
      }),
    lookAt:
      ((Xn = new bn()),
      function (t) {
        Xn.lookAt(t), Xn.updateMatrix(), this.applyMatrix(Xn.matrix);
      }),
    center:
      ((Wn = new je()),
      function () {
        return (
          this.computeBoundingBox(),
          this.boundingBox.getCenter(Wn).negate(),
          this.translate(Wn.x, Wn.y, Wn.z),
          this
        );
      }),
    setFromObject: function (t) {
      var e = t.geometry;
      if (t.isPoints || t.isLine) {
        var i = new Fn(3 * e.vertices.length, 3),
          n = new Fn(3 * e.colors.length, 3);
        if (
          (this.addAttribute('position', i.copyVector3sArray(e.vertices)),
          this.addAttribute('color', n.copyColorsArray(e.colors)),
          e.lineDistances && e.lineDistances.length === e.vertices.length)
        ) {
          var r = new Fn(e.lineDistances.length, 1);
          this.addAttribute('lineDistance', r.copyArray(e.lineDistances));
        }
        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
          null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone());
      } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
      return this;
    },
    setFromPoints: function (t) {
      for (var e = [], i = 0, n = t.length; i < n; i++) {
        var r = t[i];
        e.push(r.x, r.y, r.z || 0);
      }
      return this.addAttribute('position', new Fn(e, 3)), this;
    },
    updateFromObject: function (t) {
      var e,
        i = t.geometry;
      if (t.isMesh) {
        var n = i.__directGeometry;
        if (
          (!0 === i.elementsNeedUpdate && ((n = void 0), (i.elementsNeedUpdate = !1)),
          void 0 === n)
        )
          return this.fromGeometry(i);
        (n.verticesNeedUpdate = i.verticesNeedUpdate),
          (n.normalsNeedUpdate = i.normalsNeedUpdate),
          (n.colorsNeedUpdate = i.colorsNeedUpdate),
          (n.uvsNeedUpdate = i.uvsNeedUpdate),
          (n.groupsNeedUpdate = i.groupsNeedUpdate),
          (i.verticesNeedUpdate = !1),
          (i.normalsNeedUpdate = !1),
          (i.colorsNeedUpdate = !1),
          (i.uvsNeedUpdate = !1),
          (i.groupsNeedUpdate = !1),
          (i = n);
      }
      return (
        !0 === i.verticesNeedUpdate &&
          (void 0 !== (e = this.attributes.position) &&
            (e.copyVector3sArray(i.vertices), (e.needsUpdate = !0)),
          (i.verticesNeedUpdate = !1)),
        !0 === i.normalsNeedUpdate &&
          (void 0 !== (e = this.attributes.normal) &&
            (e.copyVector3sArray(i.normals), (e.needsUpdate = !0)),
          (i.normalsNeedUpdate = !1)),
        !0 === i.colorsNeedUpdate &&
          (void 0 !== (e = this.attributes.color) &&
            (e.copyColorsArray(i.colors), (e.needsUpdate = !0)),
          (i.colorsNeedUpdate = !1)),
        i.uvsNeedUpdate &&
          (void 0 !== (e = this.attributes.uv) &&
            (e.copyVector2sArray(i.uvs), (e.needsUpdate = !0)),
          (i.uvsNeedUpdate = !1)),
        i.lineDistancesNeedUpdate &&
          (void 0 !== (e = this.attributes.lineDistance) &&
            (e.copyArray(i.lineDistances), (e.needsUpdate = !0)),
          (i.lineDistancesNeedUpdate = !1)),
        i.groupsNeedUpdate &&
          (i.computeGroups(t.geometry),
          (this.groups = i.groups),
          (i.groupsNeedUpdate = !1)),
        this
      );
    },
    fromGeometry: function (t) {
      return (
        (t.__directGeometry = new Gn().fromGeometry(t)),
        this.fromDirectGeometry(t.__directGeometry)
      );
    },
    fromDirectGeometry: function (t) {
      var e = new Float32Array(3 * t.vertices.length);
      if (
        (this.addAttribute('position', new Pn(e, 3).copyVector3sArray(t.vertices)),
        0 < t.normals.length)
      ) {
        var i = new Float32Array(3 * t.normals.length);
        this.addAttribute('normal', new Pn(i, 3).copyVector3sArray(t.normals));
      }
      if (0 < t.colors.length) {
        var n = new Float32Array(3 * t.colors.length);
        this.addAttribute('color', new Pn(n, 3).copyColorsArray(t.colors));
      }
      if (0 < t.uvs.length) {
        var r = new Float32Array(2 * t.uvs.length);
        this.addAttribute('uv', new Pn(r, 2).copyVector2sArray(t.uvs));
      }
      if (0 < t.uvs2.length) {
        var a = new Float32Array(2 * t.uvs2.length);
        this.addAttribute('uv2', new Pn(a, 2).copyVector2sArray(t.uvs2));
      }
      for (var o in ((this.groups = t.groups), t.morphTargets)) {
        for (var s = [], c = t.morphTargets[o], h = 0, l = c.length; h < l; h++) {
          var u = c[h],
            p = new Fn(3 * u.data.length, 3);
          (p.name = u.name), s.push(p.copyVector3sArray(u.data));
        }
        this.morphAttributes[o] = s;
      }
      if (0 < t.skinIndices.length) {
        var d = new Fn(4 * t.skinIndices.length, 4);
        this.addAttribute('skinIndex', d.copyVector4sArray(t.skinIndices));
      }
      if (0 < t.skinWeights.length) {
        var f = new Fn(4 * t.skinWeights.length, 4);
        this.addAttribute('skinWeight', f.copyVector4sArray(t.skinWeights));
      }
      return (
        null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
        null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()),
        this
      );
    },
    computeBoundingBox: function () {
      null === this.boundingBox && (this.boundingBox = new Ri());
      var t = this.attributes.position;
      void 0 !== t
        ? this.boundingBox.setFromBufferAttribute(t)
        : this.boundingBox.makeEmpty(),
        (isNaN(this.boundingBox.min.x) ||
          isNaN(this.boundingBox.min.y) ||
          isNaN(this.boundingBox.min.z)) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
            this
          );
    },
    computeBoundingSphere:
      ((kn = new Ri()),
      (jn = new je()),
      function () {
        null === this.boundingSphere && (this.boundingSphere = new Oi());
        var t = this.attributes.position;
        if (t) {
          var e = this.boundingSphere.center;
          kn.setFromBufferAttribute(t), kn.getCenter(e);
          for (var i = 0, n = 0, r = t.count; n < r; n++)
            (jn.x = t.getX(n)),
              (jn.y = t.getY(n)),
              (jn.z = t.getZ(n)),
              (i = Math.max(i, e.distanceToSquared(jn)));
          (this.boundingSphere.radius = Math.sqrt(i)),
            isNaN(this.boundingSphere.radius) &&
              console.error(
                'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                this
              );
        }
      }),
    computeFaceNormals: function () {},
    computeVertexNormals: function () {
      var t = this.index,
        e = this.attributes;
      if (e.position) {
        var i = e.position.array;
        if (void 0 === e.normal)
          this.addAttribute('normal', new Pn(new Float32Array(i.length), 3));
        else for (var n = e.normal.array, r = 0, a = n.length; r < a; r++) n[r] = 0;
        var o,
          s,
          c,
          h = e.normal.array,
          l = new je(),
          u = new je(),
          p = new je(),
          d = new je(),
          f = new je();
        if (t) {
          var m = t.array;
          for (r = 0, a = t.count; r < a; r += 3)
            (o = 3 * m[r + 0]),
              (s = 3 * m[r + 1]),
              (c = 3 * m[r + 2]),
              l.fromArray(i, o),
              u.fromArray(i, s),
              p.fromArray(i, c),
              d.subVectors(p, u),
              f.subVectors(l, u),
              d.cross(f),
              (h[o] += d.x),
              (h[1 + o] += d.y),
              (h[2 + o] += d.z),
              (h[s] += d.x),
              (h[1 + s] += d.y),
              (h[2 + s] += d.z),
              (h[c] += d.x),
              (h[1 + c] += d.y),
              (h[2 + c] += d.z);
        } else
          for (r = 0, a = i.length; r < a; r += 9)
            l.fromArray(i, r),
              u.fromArray(i, r + 3),
              p.fromArray(i, r + 6),
              d.subVectors(p, u),
              f.subVectors(l, u),
              d.cross(f),
              (h[r] = d.x),
              (h[r + 1] = d.y),
              (h[r + 2] = d.z),
              (h[r + 3] = d.x),
              (h[r + 4] = d.y),
              (h[r + 5] = d.z),
              (h[r + 6] = d.x),
              (h[r + 7] = d.y),
              (h[r + 8] = d.z);
        this.normalizeNormals(), (e.normal.needsUpdate = !0);
      }
    },
    merge: function (t, e) {
      if (t && t.isBufferGeometry) {
        void 0 === e &&
          ((e = 0),
          console.warn(
            'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
          ));
        var i = this.attributes;
        for (var n in i)
          if (void 0 !== t.attributes[n])
            for (
              var r = i[n].array,
                a = t.attributes[n],
                o = a.array,
                s = 0,
                c = a.itemSize * e;
              s < o.length;
              s++, c++
            )
              r[c] = o[s];
        return this;
      }
      console.error(
        'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',
        t
      );
    },
    normalizeNormals:
      ((Vn = new je()),
      function () {
        for (var t = this.attributes.normal, e = 0, i = t.count; e < i; e++)
          (Vn.x = t.getX(e)),
            (Vn.y = t.getY(e)),
            (Vn.z = t.getZ(e)),
            Vn.normalize(),
            t.setXYZ(e, Vn.x, Vn.y, Vn.z);
      }),
    toNonIndexed: function () {
      if (null === this.index)
        return (
          console.warn(
            'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.'
          ),
          this
        );
      var t = new $n(),
        e = this.index.array,
        i = this.attributes;
      for (var n in i) {
        for (
          var r = i[n],
            a = r.array,
            o = r.itemSize,
            s = new a.constructor(e.length * o),
            c = 0,
            h = 0,
            l = 0,
            u = e.length;
          l < u;
          l++
        ) {
          c = e[l] * o;
          for (var p = 0; p < o; p++) s[h++] = a[c++];
        }
        t.addAttribute(n, new Pn(s, o));
      }
      var d = this.groups;
      for (l = 0, u = d.length; l < u; l++) {
        var f = d[l];
        t.addGroup(f.start, f.count, f.materialIndex);
      }
      return t;
    },
    toJSON: function () {
      var t = {
        metadata: {
          version: 4.5,
          type: 'BufferGeometry',
          generator: 'BufferGeometry.toJSON'
        }
      };
      if (
        ((t.uuid = this.uuid),
        (t.type = this.type),
        '' !== this.name && (t.name = this.name),
        0 < Object.keys(this.userData).length && (t.userData = this.userData),
        void 0 !== this.parameters)
      ) {
        var e = this.parameters;
        for (var i in e) void 0 !== e[i] && (t[i] = e[i]);
        return t;
      }
      t.data = { attributes: {} };
      var n = this.index;
      if (null !== n) {
        var r = Array.prototype.slice.call(n.array);
        t.data.index = { type: n.array.constructor.name, array: r };
      }
      var a = this.attributes;
      for (var i in a) {
        var o = a[i];
        r = Array.prototype.slice.call(o.array);
        t.data.attributes[i] = {
          itemSize: o.itemSize,
          type: o.array.constructor.name,
          array: r,
          normalized: o.normalized
        };
      }
      var s = this.groups;
      0 < s.length && (t.data.groups = JSON.parse(JSON.stringify(s)));
      var c = this.boundingSphere;
      return (
        null !== c &&
          (t.data.boundingSphere = { center: c.center.toArray(), radius: c.radius }),
        t
      );
    },
    clone: function () {
      return new $n().copy(this);
    },
    copy: function (t) {
      var e, i, n;
      (this.index = null),
        (this.attributes = {}),
        (this.morphAttributes = {}),
        (this.groups = []),
        (this.boundingBox = null),
        (this.boundingSphere = null),
        (this.name = t.name);
      var r = t.index;
      null !== r && this.setIndex(r.clone());
      var a = t.attributes;
      for (e in a) {
        var o = a[e];
        this.addAttribute(e, o.clone());
      }
      var s = t.morphAttributes;
      for (e in s) {
        var c = [],
          h = s[e];
        for (i = 0, n = h.length; i < n; i++) c.push(h[i].clone());
        this.morphAttributes[e] = c;
      }
      var l = t.groups;
      for (i = 0, n = l.length; i < n; i++) {
        var u = l[i];
        this.addGroup(u.start, u.count, u.materialIndex);
      }
      var p = t.boundingBox;
      null !== p && (this.boundingBox = p.clone());
      var d = t.boundingSphere;
      return (
        null !== d && (this.boundingSphere = d.clone()),
        (this.drawRange.start = t.drawRange.start),
        (this.drawRange.count = t.drawRange.count),
        (this.userData = t.userData),
        this
      );
    },
    dispose: function () {
      this.dispatchEvent({ type: 'dispose' });
    }
  })),
    ((tr.prototype = Object.create(Rn.prototype)).constructor = tr),
    ((er.prototype = Object.create($n.prototype)).constructor = er),
    ((ir.prototype = Object.create(Rn.prototype)).constructor = ir),
    ((nr.prototype = Object.create($n.prototype)).constructor = nr);
  var rr,
    ar,
    or,
    sr,
    cr,
    hr,
    lr,
    ur,
    pr,
    dr,
    fr,
    mr,
    gr,
    vr,
    yr,
    xr,
    br,
    _r,
    wr,
    Mr,
    Er,
    Tr,
    Sr,
    Ar,
    Lr,
    Rr,
    Pr,
    Cr,
    Or,
    Ir,
    Nr,
    Dr,
    Ur,
    Br,
    Fr,
    zr,
    Gr,
    Hr,
    Vr,
    kr = 0;
  function jr() {
    Object.defineProperty(this, 'id', { value: kr++ }),
      (this.uuid = Ge.generateUUID()),
      (this.name = ''),
      (this.type = 'Material'),
      (this.fog = !0),
      (this.lights = !0),
      (this.blending = Q),
      (this.side = D),
      (this.flatShading = !1),
      (this.vertexColors = M),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = I),
      (this.blendDst = N),
      (this.blendEquation = it),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = ot),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaTest = 0),
      (this.premultipliedAlpha = !1),
      (this.overdraw = 0),
      (this.visible = !0),
      (this.userData = {}),
      (this.needsUpdate = !0);
  }
  function Wr(t) {
    jr.call(this),
      (this.type = 'ShaderMaterial'),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.vertexShader =
        'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'),
      (this.fragmentShader =
        'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1
      }),
      (this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      void 0 !== t &&
        (void 0 !== t.attributes &&
          console.error(
            'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.'
          ),
        this.setValues(t));
  }
  function Xr(t, e) {
    (this.origin = void 0 !== t ? t : new je()),
      (this.direction = void 0 !== e ? e : new je());
  }
  function qr(t, e, i) {
    (this.a = void 0 !== t ? t : new je()),
      (this.b = void 0 !== e ? e : new je()),
      (this.c = void 0 !== i ? i : new je());
  }
  function Yr(t) {
    jr.call(this),
      (this.type = 'MeshBasicMaterial'),
      (this.color = new Hi(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = k),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.lights = !1),
      this.setValues(t);
  }
  function Jr(t, e) {
    bn.call(this),
      (this.type = 'Mesh'),
      (this.geometry = void 0 !== t ? t : new $n()),
      (this.material = void 0 !== e ? e : new Yr({ color: 16777215 * Math.random() })),
      (this.drawMode = Le),
      this.updateMorphTargets();
  }
  function Zr(t, e, i, n, r, a, o, s) {
    if (
      null ===
      (e.side === wt
        ? n.intersectTriangle(o, a, r, !0, s)
        : n.intersectTriangle(r, a, o, e.side !== J, s))
    )
      return null;
    Vr.copy(s), Vr.applyMatrix4(t.matrixWorld);
    var c = i.ray.origin.distanceTo(Vr);
    return c < i.near || c > i.far ? null : { distance: c, point: Vr.clone(), object: t };
  }
  function Qr(t, e, i, n, r, a, o, s, c) {
    Or.fromBufferAttribute(r, o),
      Ir.fromBufferAttribute(r, s),
      Nr.fromBufferAttribute(r, c);
    var h = Zr(t, e, i, n, Or, Ir, Nr, Hr);
    if (h) {
      a &&
        (Fr.fromBufferAttribute(a, o),
        zr.fromBufferAttribute(a, s),
        Gr.fromBufferAttribute(a, c),
        (h.uv = qr.getUV(Hr, Or, Ir, Nr, Fr, zr, Gr, new He())));
      var l = new Qi(o, s, c);
      qr.getNormal(Or, Ir, Nr, l.normal), (h.face = l);
    }
    return h;
  }
  function Kr(a, i, o, n) {
    var s,
      c,
      h = new Hi(0),
      l = 0;
    function u(t, e) {
      i.buffers.color.setClear(t.r, t.g, t.b, e, n);
    }
    return {
      getClearColor: function () {
        return h;
      },
      setClearColor: function (t, e) {
        h.set(t), u(h, (l = void 0 !== e ? e : 1));
      },
      getClearAlpha: function () {
        return l;
      },
      setClearAlpha: function (t) {
        u(h, (l = t));
      },
      render: function (t, e, i, n) {
        var r = e.background;
        null === r ? u(h, l) : r && r.isColor && (u(r, 1), (n = !0)),
          (a.autoClear || n) &&
            a.clear(a.autoClearColor, a.autoClearDepth, a.autoClearStencil),
          r && r.isCubeTexture
            ? (void 0 === c &&
                ((c = new Jr(
                  new er(1, 1, 1),
                  new Wr({
                    uniforms: zi.clone(Yi.cube.uniforms),
                    vertexShader: Yi.cube.vertexShader,
                    fragmentShader: Yi.cube.fragmentShader,
                    side: wt,
                    depthTest: !0,
                    depthWrite: !1,
                    fog: !1
                  })
                )).geometry.removeAttribute('normal'),
                c.geometry.removeAttribute('uv'),
                (c.onBeforeRender = function (t, e, i) {
                  this.matrixWorld.copyPosition(i.matrixWorld);
                }),
                o.update(c)),
              (c.material.uniforms.tCube.value = r),
              t.push(c, c.geometry, c.material, 0, null))
            : r &&
              r.isTexture &&
              (void 0 === s &&
                ((s = new Jr(
                  new nr(2, 2),
                  new Wr({
                    uniforms: zi.clone(Yi.background.uniforms),
                    vertexShader: Yi.background.vertexShader,
                    fragmentShader: Yi.background.fragmentShader,
                    side: D,
                    depthTest: !0,
                    depthWrite: !1,
                    fog: !1
                  })
                )).geometry.removeAttribute('normal'),
                o.update(s)),
              (s.material.uniforms.t2D.value = r),
              t.push(s, s.geometry, s.material, 0, null));
      }
    };
  }
  function $r(r, a, o, s) {
    var c;
    (this.setMode = function (t) {
      c = t;
    }),
      (this.render = function (t, e) {
        r.drawArrays(c, t, e), o.update(e, c);
      }),
      (this.renderInstances = function (t, e, i) {
        var n;
        if (s.isWebGL2) n = r;
        else if (null === (n = a.get('ANGLE_instanced_arrays')))
          return void console.error(
            'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
          );
        n[s.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE'](
          c,
          e,
          i,
          t.maxInstancedCount
        ),
          o.update(i, c, t.maxInstancedCount);
      });
  }
  function ta(e, i, t) {
    var n;
    function r(t) {
      if ('highp' === t) {
        if (
          0 < e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision &&
          0 < e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision
        )
          return 'highp';
        t = 'mediump';
      }
      return 'mediump' === t &&
        0 < e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision &&
        0 < e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision
        ? 'mediump'
        : 'lowp';
    }
    var a =
        'undefined' != typeof WebGL2RenderingContext &&
        e instanceof WebGL2RenderingContext,
      o = void 0 !== t.precision ? t.precision : 'highp',
      s = r(o);
    s !== o &&
      (console.warn('THREE.WebGLRenderer:', o, 'not supported, using', s, 'instead.'),
      (o = s));
    var c = !0 === t.logarithmicDepthBuffer,
      h = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
      l = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      u = e.getParameter(e.MAX_TEXTURE_SIZE),
      p = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
      d = e.getParameter(e.MAX_VERTEX_ATTRIBS),
      f = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
      m = e.getParameter(e.MAX_VARYING_VECTORS),
      g = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
      v = 0 < l,
      y = a || !!i.get('OES_texture_float');
    return {
      isWebGL2: a,
      getMaxAnisotropy: function () {
        if (void 0 !== n) return n;
        var t = i.get('EXT_texture_filter_anisotropic');
        return (n = null !== t ? e.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0);
      },
      getMaxPrecision: r,
      precision: o,
      logarithmicDepthBuffer: c,
      maxTextures: h,
      maxVertexTextures: l,
      maxTextureSize: u,
      maxCubemapSize: p,
      maxAttributes: d,
      maxVertexUniforms: f,
      maxVaryings: m,
      maxFragmentUniforms: g,
      vertexTextures: v,
      floatFragmentTextures: y,
      floatVertexTextures: v && y
    };
  }
  function ea() {
    var l = this,
      u = null,
      p = 0,
      d = !1,
      f = !1,
      m = new Ii(),
      g = new We(),
      v = { value: null, needsUpdate: !1 };
    function y() {
      v.value !== u && ((v.value = u), (v.needsUpdate = 0 < p)),
        (l.numPlanes = p),
        (l.numIntersection = 0);
    }
    function x(t, e, i, n) {
      var r = null !== t ? t.length : 0,
        a = null;
      if (0 !== r) {
        if (((a = v.value), !0 !== n || null === a)) {
          var o = i + 4 * r,
            s = e.matrixWorldInverse;
          g.getNormalMatrix(s), (null === a || a.length < o) && (a = new Float32Array(o));
          for (var c = 0, h = i; c !== r; ++c, h += 4)
            m.copy(t[c]).applyMatrix4(s, g),
              m.normal.toArray(a, h),
              (a[h + 3] = m.constant);
        }
        (v.value = a), (v.needsUpdate = !0);
      }
      return (l.numPlanes = r), a;
    }
    (this.uniform = v),
      (this.numPlanes = 0),
      (this.numIntersection = 0),
      (this.init = function (t, e, i) {
        var n = 0 !== t.length || e || 0 !== p || d;
        return (d = e), (u = x(t, i, 0)), (p = t.length), n;
      }),
      (this.beginShadows = function () {
        (f = !0), x(null);
      }),
      (this.endShadows = function () {
        (f = !1), y();
      }),
      (this.setState = function (t, e, i, n, r, a) {
        if (!d || null === t || 0 === t.length || (f && !i)) f ? x(null) : y();
        else {
          var o = f ? 0 : p,
            s = 4 * o,
            c = r.clippingState || null;
          (v.value = c), (c = x(t, n, s, a));
          for (var h = 0; h !== s; ++h) c[h] = u[h];
          (r.clippingState = c),
            (this.numIntersection = e ? this.numPlanes : 0),
            (this.numPlanes += o);
        }
      });
  }
  function ia(i) {
    var n = {};
    return {
      get: function (t) {
        if (void 0 !== n[t]) return n[t];
        var e;
        switch (t) {
          case 'WEBGL_depth_texture':
            e =
              i.getExtension('WEBGL_depth_texture') ||
              i.getExtension('MOZ_WEBGL_depth_texture') ||
              i.getExtension('WEBKIT_WEBGL_depth_texture');
            break;
          case 'EXT_texture_filter_anisotropic':
            e =
              i.getExtension('EXT_texture_filter_anisotropic') ||
              i.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
              i.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
            break;
          case 'WEBGL_compressed_texture_s3tc':
            e =
              i.getExtension('WEBGL_compressed_texture_s3tc') ||
              i.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
              i.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');
            break;
          case 'WEBGL_compressed_texture_pvrtc':
            e =
              i.getExtension('WEBGL_compressed_texture_pvrtc') ||
              i.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');
            break;
          default:
            e = i.getExtension(t);
        }
        return (
          null === e &&
            console.warn('THREE.WebGLRenderer: ' + t + ' extension not supported.'),
          (n[t] = e)
        );
      }
    };
  }
  function na(u, p, a) {
    var o = {},
      d = {};
    function s(t) {
      var e = t.target,
        i = o[e.id];
      for (var n in (null !== i.index && p.remove(i.index), i.attributes))
        p.remove(i.attributes[n]);
      e.removeEventListener('dispose', s), delete o[e.id];
      var r = d[i.id];
      r && (p.remove(r), delete d[i.id]), a.memory.geometries--;
    }
    return {
      get: function (t, e) {
        var i = o[e.id];
        return (
          i ||
          (e.addEventListener('dispose', s),
          e.isBufferGeometry
            ? (i = e)
            : e.isGeometry &&
              (void 0 === e._bufferGeometry &&
                (e._bufferGeometry = new $n().setFromObject(t)),
              (i = e._bufferGeometry)),
          (o[e.id] = i),
          a.memory.geometries++,
          i)
        );
      },
      update: function (t) {
        var e = t.index,
          i = t.attributes;
        for (var n in (null !== e && p.update(e, u.ELEMENT_ARRAY_BUFFER), i))
          p.update(i[n], u.ARRAY_BUFFER);
        var r = t.morphAttributes;
        for (var n in r)
          for (var a = r[n], o = 0, s = a.length; o < s; o++)
            p.update(a[o], u.ARRAY_BUFFER);
      },
      getWireframeAttribute: function (t) {
        var e = d[t.id];
        if (e) return e;
        var i,
          n = [],
          r = t.index,
          a = t.attributes;
        if (null !== r)
          for (var o = 0, s = (i = r.array).length; o < s; o += 3) {
            var c = i[o + 0],
              h = i[o + 1],
              l = i[o + 2];
            n.push(c, h, h, l, l, c);
          }
        else
          for (o = 0, s = (i = a.position.array).length / 3 - 1; o < s; o += 3) {
            (c = o + 0), (h = o + 1), (l = o + 2);
            n.push(c, h, h, l, l, c);
          }
        return (
          (e = new (65535 < Hn(n) ? Bn : Dn)(n, 1)),
          p.update(e, u.ELEMENT_ARRAY_BUFFER),
          (d[t.id] = e)
        );
      }
    };
  }
  function ra(r, a, o, s) {
    var c, h, l;
    (this.setMode = function (t) {
      c = t;
    }),
      (this.setIndex = function (t) {
        (h = t.type), (l = t.bytesPerElement);
      }),
      (this.render = function (t, e) {
        r.drawElements(c, e, h, t * l), o.update(e, c);
      }),
      (this.renderInstances = function (t, e, i) {
        var n;
        if (s.isWebGL2) n = r;
        else if (null === (n = a.get('ANGLE_instanced_arrays')))
          return void console.error(
            'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
          );
        n[s.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE'](
          c,
          i,
          h,
          e * l,
          t.maxInstancedCount
        ),
          o.update(i, c, t.maxInstancedCount);
      });
  }
  function aa(n) {
    var r = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
    return {
      memory: { geometries: 0, textures: 0 },
      render: r,
      programs: null,
      autoReset: !0,
      reset: function () {
        r.frame++, (r.calls = 0), (r.triangles = 0), (r.points = 0), (r.lines = 0);
      },
      update: function (t, e, i) {
        switch (((i = i || 1), r.calls++, e)) {
          case n.TRIANGLES:
            r.triangles += i * (t / 3);
            break;
          case n.TRIANGLE_STRIP:
          case n.TRIANGLE_FAN:
            r.triangles += i * (t - 2);
            break;
          case n.LINES:
            r.lines += i * (t / 2);
            break;
          case n.LINE_STRIP:
            r.lines += i * (t - 1);
            break;
          case n.LINE_LOOP:
            r.lines += i * t;
            break;
          case n.POINTS:
            r.points += i * t;
            break;
          default:
            console.error('THREE.WebGLInfo: Unknown draw mode:', e);
        }
      }
    };
  }
  function oa(t, e) {
    return Math.abs(e[1]) - Math.abs(t[1]);
  }
  function sa(d) {
    var f = {},
      m = new Float32Array(8);
    return {
      update: function (t, e, i, n) {
        var r = t.morphTargetInfluences,
          a = r.length,
          o = f[e.id];
        if (void 0 === o) {
          o = [];
          for (var s = 0; s < a; s++) o[s] = [s, 0];
          f[e.id] = o;
        }
        var c = i.morphTargets && e.morphAttributes.position,
          h = i.morphNormals && e.morphAttributes.normal;
        for (s = 0; s < a; s++) {
          0 !== (l = o[s])[1] &&
            (c && e.removeAttribute('morphTarget' + s),
            h && e.removeAttribute('morphNormal' + s));
        }
        for (s = 0; s < a; s++) {
          ((l = o[s])[0] = s), (l[1] = r[s]);
        }
        for (o.sort(oa), s = 0; s < 8; s++) {
          var l;
          if ((l = o[s])) {
            var u = l[0],
              p = l[1];
            if (p) {
              c && e.addAttribute('morphTarget' + s, c[u]),
                h && e.addAttribute('morphNormal' + s, h[u]),
                (m[s] = p);
              continue;
            }
          }
          m[s] = 0;
        }
        n.getUniforms().setValue(d, 'morphTargetInfluences', m);
      }
    };
  }
  function ca(r, a) {
    var o = {};
    return {
      update: function (t) {
        var e = a.render.frame,
          i = t.geometry,
          n = r.get(t, i);
        return (
          o[n.id] !== e &&
            (i.isGeometry && n.updateFromObject(t), r.update(n), (o[n.id] = e)),
          n
        );
      },
      dispose: function () {
        o = {};
      }
    };
  }
  function ha(t, e, i, n, r, a, o, s, c, h) {
    Ei.call(
      this,
      (t = void 0 !== t ? t : []),
      (e = void 0 !== e ? e : mt),
      i,
      n,
      r,
      a,
      o,
      s,
      c,
      h
    ),
      (this.flipY = !1);
  }
  function la(t, e, i, n) {
    Ei.call(this, null),
      (this.image = { data: t, width: e, height: i, depth: n }),
      (this.magFilter = At),
      (this.minFilter = At),
      (this.generateMipmaps = !1),
      (this.flipY = !1);
  }
  (jr.prototype = Object.assign(Object.create(e.prototype), {
    constructor: jr,
    isMaterial: !0,
    onBeforeCompile: function () {},
    setValues: function (t) {
      if (void 0 !== t)
        for (var e in t) {
          var i = t[e];
          if (void 0 !== i)
            if ('shading' !== e) {
              var n = this[e];
              void 0 !== n
                ? n && n.isColor
                  ? n.set(i)
                  : n && n.isVector3 && i && i.isVector3
                  ? n.copy(i)
                  : (this[e] = 'overdraw' === e ? Number(i) : i)
                : console.warn(
                    'THREE.' +
                      this.type +
                      ": '" +
                      e +
                      "' is not a property of this material."
                  );
            } else
              console.warn(
                'THREE.' +
                  this.type +
                  ': .shading has been removed. Use the boolean .flatShading instead.'
              ),
                (this.flatShading = 1 === i);
          else console.warn("THREE.Material: '" + e + "' parameter is undefined.");
        }
    },
    toJSON: function (t) {
      var e = void 0 === t || 'string' == typeof t;
      e && (t = { textures: {}, images: {} });
      var i = {
        metadata: { version: 4.5, type: 'Material', generator: 'Material.toJSON' }
      };
      function n(t) {
        var e = [];
        for (var i in t) {
          var n = t[i];
          delete n.metadata, e.push(n);
        }
        return e;
      }
      if (
        ((i.uuid = this.uuid),
        (i.type = this.type),
        '' !== this.name && (i.name = this.name),
        this.color && this.color.isColor && (i.color = this.color.getHex()),
        void 0 !== this.roughness && (i.roughness = this.roughness),
        void 0 !== this.metalness && (i.metalness = this.metalness),
        this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()),
        1 !== this.emissiveIntensity && (i.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (i.specular = this.specular.getHex()),
        void 0 !== this.shininess && (i.shininess = this.shininess),
        void 0 !== this.clearCoat && (i.clearCoat = this.clearCoat),
        void 0 !== this.clearCoatRoughness &&
          (i.clearCoatRoughness = this.clearCoatRoughness),
        this.map && this.map.isTexture && (i.map = this.map.toJSON(t).uuid),
        this.alphaMap &&
          this.alphaMap.isTexture &&
          (i.alphaMap = this.alphaMap.toJSON(t).uuid),
        this.lightMap &&
          this.lightMap.isTexture &&
          (i.lightMap = this.lightMap.toJSON(t).uuid),
        this.aoMap &&
          this.aoMap.isTexture &&
          ((i.aoMap = this.aoMap.toJSON(t).uuid),
          (i.aoMapIntensity = this.aoMapIntensity)),
        this.bumpMap &&
          this.bumpMap.isTexture &&
          ((i.bumpMap = this.bumpMap.toJSON(t).uuid), (i.bumpScale = this.bumpScale)),
        this.normalMap &&
          this.normalMap.isTexture &&
          ((i.normalMap = this.normalMap.toJSON(t).uuid),
          (i.normalMapType = this.normalMapType),
          (i.normalScale = this.normalScale.toArray())),
        this.displacementMap &&
          this.displacementMap.isTexture &&
          ((i.displacementMap = this.displacementMap.toJSON(t).uuid),
          (i.displacementScale = this.displacementScale),
          (i.displacementBias = this.displacementBias)),
        this.roughnessMap &&
          this.roughnessMap.isTexture &&
          (i.roughnessMap = this.roughnessMap.toJSON(t).uuid),
        this.metalnessMap &&
          this.metalnessMap.isTexture &&
          (i.metalnessMap = this.metalnessMap.toJSON(t).uuid),
        this.emissiveMap &&
          this.emissiveMap.isTexture &&
          (i.emissiveMap = this.emissiveMap.toJSON(t).uuid),
        this.specularMap &&
          this.specularMap.isTexture &&
          (i.specularMap = this.specularMap.toJSON(t).uuid),
        this.envMap &&
          this.envMap.isTexture &&
          ((i.envMap = this.envMap.toJSON(t).uuid),
          (i.reflectivity = this.reflectivity),
          void 0 !== this.combine && (i.combine = this.combine),
          void 0 !== this.envMapIntensity && (i.envMapIntensity = this.envMapIntensity)),
        this.gradientMap &&
          this.gradientMap.isTexture &&
          (i.gradientMap = this.gradientMap.toJSON(t).uuid),
        void 0 !== this.size && (i.size = this.size),
        void 0 !== this.sizeAttenuation && (i.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Q && (i.blending = this.blending),
        !0 === this.flatShading && (i.flatShading = this.flatShading),
        this.side !== D && (i.side = this.side),
        this.vertexColors !== M && (i.vertexColors = this.vertexColors),
        this.opacity < 1 && (i.opacity = this.opacity),
        !0 === this.transparent && (i.transparent = this.transparent),
        (i.depthFunc = this.depthFunc),
        (i.depthTest = this.depthTest),
        (i.depthWrite = this.depthWrite),
        0 !== this.rotation && (i.rotation = this.rotation),
        !0 === this.polygonOffset && (i.polygonOffset = !0),
        0 !== this.polygonOffsetFactor &&
          (i.polygonOffsetFactor = this.polygonOffsetFactor),
        0 !== this.polygonOffsetUnits && (i.polygonOffsetUnits = this.polygonOffsetUnits),
        1 !== this.linewidth && (i.linewidth = this.linewidth),
        void 0 !== this.dashSize && (i.dashSize = this.dashSize),
        void 0 !== this.gapSize && (i.gapSize = this.gapSize),
        void 0 !== this.scale && (i.scale = this.scale),
        !0 === this.dithering && (i.dithering = !0),
        0 < this.alphaTest && (i.alphaTest = this.alphaTest),
        !0 === this.premultipliedAlpha &&
          (i.premultipliedAlpha = this.premultipliedAlpha),
        !0 === this.wireframe && (i.wireframe = this.wireframe),
        1 < this.wireframeLinewidth && (i.wireframeLinewidth = this.wireframeLinewidth),
        'round' !== this.wireframeLinecap && (i.wireframeLinecap = this.wireframeLinecap),
        'round' !== this.wireframeLinejoin &&
          (i.wireframeLinejoin = this.wireframeLinejoin),
        !0 === this.morphTargets && (i.morphTargets = !0),
        !0 === this.skinning && (i.skinning = !0),
        !1 === this.visible && (i.visible = !1),
        '{}' !== JSON.stringify(this.userData) && (i.userData = this.userData),
        e)
      ) {
        var r = n(t.textures),
          a = n(t.images);
        0 < r.length && (i.textures = r), 0 < a.length && (i.images = a);
      }
      return i;
    },
    clone: function () {
      return new this.constructor().copy(this);
    },
    copy: function (t) {
      (this.name = t.name),
        (this.fog = t.fog),
        (this.lights = t.lights),
        (this.blending = t.blending),
        (this.side = t.side),
        (this.flatShading = t.flatShading),
        (this.vertexColors = t.vertexColors),
        (this.opacity = t.opacity),
        (this.transparent = t.transparent),
        (this.blendSrc = t.blendSrc),
        (this.blendDst = t.blendDst),
        (this.blendEquation = t.blendEquation),
        (this.blendSrcAlpha = t.blendSrcAlpha),
        (this.blendDstAlpha = t.blendDstAlpha),
        (this.blendEquationAlpha = t.blendEquationAlpha),
        (this.depthFunc = t.depthFunc),
        (this.depthTest = t.depthTest),
        (this.depthWrite = t.depthWrite),
        (this.colorWrite = t.colorWrite),
        (this.precision = t.precision),
        (this.polygonOffset = t.polygonOffset),
        (this.polygonOffsetFactor = t.polygonOffsetFactor),
        (this.polygonOffsetUnits = t.polygonOffsetUnits),
        (this.dithering = t.dithering),
        (this.alphaTest = t.alphaTest),
        (this.premultipliedAlpha = t.premultipliedAlpha),
        (this.overdraw = t.overdraw),
        (this.visible = t.visible),
        (this.userData = JSON.parse(JSON.stringify(t.userData))),
        (this.clipShadows = t.clipShadows),
        (this.clipIntersection = t.clipIntersection);
      var e = t.clippingPlanes,
        i = null;
      if (null !== e) {
        var n = e.length;
        i = new Array(n);
        for (var r = 0; r !== n; ++r) i[r] = e[r].clone();
      }
      return (this.clippingPlanes = i), (this.shadowSide = t.shadowSide), this;
    },
    dispose: function () {
      this.dispatchEvent({ type: 'dispose' });
    }
  })),
    (((Wr.prototype = Object.create(
      jr.prototype
    )).constructor = Wr).prototype.isShaderMaterial = !0),
    (Wr.prototype.copy = function (t) {
      return (
        jr.prototype.copy.call(this, t),
        (this.fragmentShader = t.fragmentShader),
        (this.vertexShader = t.vertexShader),
        (this.uniforms = zi.clone(t.uniforms)),
        (this.defines = Object.assign({}, t.defines)),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.lights = t.lights),
        (this.clipping = t.clipping),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        (this.extensions = t.extensions),
        this
      );
    }),
    (Wr.prototype.toJSON = function (t) {
      var e = jr.prototype.toJSON.call(this, t);
      for (var i in ((e.uniforms = {}), this.uniforms)) {
        var n = this.uniforms[i].value;
        n.isTexture
          ? (e.uniforms[i] = { type: 't', value: n.toJSON(t).uuid })
          : n.isColor
          ? (e.uniforms[i] = { type: 'c', value: n.getHex() })
          : n.isVector2
          ? (e.uniforms[i] = { type: 'v2', value: n.toArray() })
          : n.isVector3
          ? (e.uniforms[i] = { type: 'v3', value: n.toArray() })
          : n.isVector4
          ? (e.uniforms[i] = { type: 'v4', value: n.toArray() })
          : n.isMatrix4
          ? (e.uniforms[i] = { type: 'm4', value: n.toArray() })
          : (e.uniforms[i] = { value: n });
      }
      return (
        0 < Object.keys(this.defines).length && (e.defines = this.defines),
        (e.vertexShader = this.vertexShader),
        (e.fragmentShader = this.fragmentShader),
        e
      );
    }),
    Object.assign(Xr.prototype, {
      set: function (t, e) {
        return this.origin.copy(t), this.direction.copy(e), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.origin.copy(t.origin), this.direction.copy(t.direction), this;
      },
      at: function (t, e) {
        return (
          void 0 === e &&
            (console.warn('THREE.Ray: .at() target is now required'), (e = new je())),
          e.copy(this.direction).multiplyScalar(t).add(this.origin)
        );
      },
      lookAt: function (t) {
        return this.direction.copy(t).sub(this.origin).normalize(), this;
      },
      recast:
        ((fr = new je()),
        function (t) {
          return this.origin.copy(this.at(t, fr)), this;
        }),
      closestPointToPoint: function (t, e) {
        void 0 === e &&
          (console.warn('THREE.Ray: .closestPointToPoint() target is now required'),
          (e = new je())),
          e.subVectors(t, this.origin);
        var i = e.dot(this.direction);
        return i < 0
          ? e.copy(this.origin)
          : e.copy(this.direction).multiplyScalar(i).add(this.origin);
      },
      distanceToPoint: function (t) {
        return Math.sqrt(this.distanceSqToPoint(t));
      },
      distanceSqToPoint:
        ((dr = new je()),
        function (t) {
          var e = dr.subVectors(t, this.origin).dot(this.direction);
          return e < 0
            ? this.origin.distanceToSquared(t)
            : (dr.copy(this.direction).multiplyScalar(e).add(this.origin),
              dr.distanceToSquared(t));
        }),
      distanceSqToSegment:
        ((lr = new je()),
        (ur = new je()),
        (pr = new je()),
        function (t, e, i, n) {
          lr.copy(t).add(e).multiplyScalar(0.5),
            ur.copy(e).sub(t).normalize(),
            pr.copy(this.origin).sub(lr);
          var r,
            a,
            o,
            s,
            c = 0.5 * t.distanceTo(e),
            h = -this.direction.dot(ur),
            l = pr.dot(this.direction),
            u = -pr.dot(ur),
            p = pr.lengthSq(),
            d = Math.abs(1 - h * h);
          if (0 < d)
            if (((a = h * l - u), (s = c * d), 0 <= (r = h * u - l)))
              if (-s <= a)
                if (a <= s) {
                  var f = 1 / d;
                  o = (r *= f) * (r + h * (a *= f) + 2 * l) + a * (h * r + a + 2 * u) + p;
                } else
                  (a = c),
                    (o = -(r = Math.max(0, -(h * a + l))) * r + a * (a + 2 * u) + p);
              else
                (a = -c),
                  (o = -(r = Math.max(0, -(h * a + l))) * r + a * (a + 2 * u) + p);
            else
              o =
                a <= -s
                  ? -(r = Math.max(0, -(-h * c + l))) * r +
                    (a = 0 < r ? -c : Math.min(Math.max(-c, -u), c)) * (a + 2 * u) +
                    p
                  : a <= s
                  ? ((r = 0), (a = Math.min(Math.max(-c, -u), c)) * (a + 2 * u) + p)
                  : -(r = Math.max(0, -(h * c + l))) * r +
                    (a = 0 < r ? c : Math.min(Math.max(-c, -u), c)) * (a + 2 * u) +
                    p;
          else
            (a = 0 < h ? -c : c),
              (o = -(r = Math.max(0, -(h * a + l))) * r + a * (a + 2 * u) + p);
          return (
            i && i.copy(this.direction).multiplyScalar(r).add(this.origin),
            n && n.copy(ur).multiplyScalar(a).add(lr),
            o
          );
        }),
      intersectSphere:
        ((hr = new je()),
        function (t, e) {
          hr.subVectors(t.center, this.origin);
          var i = hr.dot(this.direction),
            n = hr.dot(hr) - i * i,
            r = t.radius * t.radius;
          if (r < n) return null;
          var a = Math.sqrt(r - n),
            o = i - a,
            s = i + a;
          return o < 0 && s < 0 ? null : o < 0 ? this.at(s, e) : this.at(o, e);
        }),
      intersectsSphere: function (t) {
        return this.distanceSqToPoint(t.center) <= t.radius * t.radius;
      },
      distanceToPlane: function (t) {
        var e = t.normal.dot(this.direction);
        if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
        var i = -(this.origin.dot(t.normal) + t.constant) / e;
        return 0 <= i ? i : null;
      },
      intersectPlane: function (t, e) {
        var i = this.distanceToPlane(t);
        return null === i ? null : this.at(i, e);
      },
      intersectsPlane: function (t) {
        var e = t.distanceToPoint(this.origin);
        return 0 === e || t.normal.dot(this.direction) * e < 0;
      },
      intersectBox: function (t, e) {
        var i,
          n,
          r,
          a,
          o,
          s,
          c = 1 / this.direction.x,
          h = 1 / this.direction.y,
          l = 1 / this.direction.z,
          u = this.origin;
        return (
          (n =
            0 <= c
              ? ((i = (t.min.x - u.x) * c), (t.max.x - u.x) * c)
              : ((i = (t.max.x - u.x) * c), (t.min.x - u.x) * c)),
          (a =
            0 <= h
              ? ((r = (t.min.y - u.y) * h), (t.max.y - u.y) * h)
              : ((r = (t.max.y - u.y) * h), (t.min.y - u.y) * h)) < i || n < r
            ? null
            : ((i < r || i != i) && (i = r),
              (a < n || n != n) && (n = a),
              (s =
                0 <= l
                  ? ((o = (t.min.z - u.z) * l), (t.max.z - u.z) * l)
                  : ((o = (t.max.z - u.z) * l), (t.min.z - u.z) * l)) < i || n < o
                ? null
                : ((i < o || i != i) && (i = o),
                  (s < n || n != n) && (n = s),
                  n < 0 ? null : this.at(0 <= i ? i : n, e)))
        );
      },
      intersectsBox:
        ((cr = new je()),
        function (t) {
          return null !== this.intersectBox(t, cr);
        }),
      intersectTriangle:
        ((rr = new je()),
        (ar = new je()),
        (or = new je()),
        (sr = new je()),
        function (t, e, i, n, r) {
          ar.subVectors(e, t), or.subVectors(i, t), sr.crossVectors(ar, or);
          var a,
            o = this.direction.dot(sr);
          if (0 < o) {
            if (n) return null;
            a = 1;
          } else {
            if (!(o < 0)) return null;
            (a = -1), (o = -o);
          }
          rr.subVectors(this.origin, t);
          var s = a * this.direction.dot(or.crossVectors(rr, or));
          if (s < 0) return null;
          var c = a * this.direction.dot(ar.cross(rr));
          if (c < 0) return null;
          if (o < s + c) return null;
          var h = -a * rr.dot(sr);
          return h < 0 ? null : this.at(h / o, r);
        }),
      applyMatrix4: function (t) {
        return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this;
      },
      equals: function (t) {
        return t.origin.equals(this.origin) && t.direction.equals(this.direction);
      }
    }),
    Object.assign(qr, {
      getNormal:
        ((br = new je()),
        function (t, e, i, n) {
          void 0 === n &&
            (console.warn('THREE.Triangle: .getNormal() target is now required'),
            (n = new je())),
            n.subVectors(i, e),
            br.subVectors(t, e),
            n.cross(br);
          var r = n.lengthSq();
          return 0 < r ? n.multiplyScalar(1 / Math.sqrt(r)) : n.set(0, 0, 0);
        }),
      getBarycoord:
        ((vr = new je()),
        (yr = new je()),
        (xr = new je()),
        function (t, e, i, n, r) {
          vr.subVectors(n, e), yr.subVectors(i, e), xr.subVectors(t, e);
          var a = vr.dot(vr),
            o = vr.dot(yr),
            s = vr.dot(xr),
            c = yr.dot(yr),
            h = yr.dot(xr),
            l = a * c - o * o;
          if (
            (void 0 === r &&
              (console.warn('THREE.Triangle: .getBarycoord() target is now required'),
              (r = new je())),
            0 == l)
          )
            return r.set(-2, -1, -1);
          var u = 1 / l,
            p = (c * s - o * h) * u,
            d = (a * h - o * s) * u;
          return r.set(1 - p - d, d, p);
        }),
      containsPoint:
        ((gr = new je()),
        function (t, e, i, n) {
          return (
            qr.getBarycoord(t, e, i, n, gr), 0 <= gr.x && 0 <= gr.y && gr.x + gr.y <= 1
          );
        }),
      getUV:
        ((mr = new je()),
        function (t, e, i, n, r, a, o, s) {
          return (
            this.getBarycoord(t, e, i, n, mr),
            s.set(0, 0),
            s.addScaledVector(r, mr.x),
            s.addScaledVector(a, mr.y),
            s.addScaledVector(o, mr.z),
            s
          );
        })
    }),
    Object.assign(qr.prototype, {
      set: function (t, e, i) {
        return this.a.copy(t), this.b.copy(e), this.c.copy(i), this;
      },
      setFromPointsAndIndices: function (t, e, i, n) {
        return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this;
      },
      getArea:
        ((Ar = new je()),
        (Lr = new je()),
        function () {
          return (
            Ar.subVectors(this.c, this.b),
            Lr.subVectors(this.a, this.b),
            0.5 * Ar.cross(Lr).length()
          );
        }),
      getMidpoint: function (t) {
        return (
          void 0 === t &&
            (console.warn('THREE.Triangle: .getMidpoint() target is now required'),
            (t = new je())),
          t
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3)
        );
      },
      getNormal: function (t) {
        return qr.getNormal(this.a, this.b, this.c, t);
      },
      getPlane: function (t) {
        return (
          void 0 === t &&
            (console.warn('THREE.Triangle: .getPlane() target is now required'),
            (t = new je())),
          t.setFromCoplanarPoints(this.a, this.b, this.c)
        );
      },
      getBarycoord: function (t, e) {
        return qr.getBarycoord(t, this.a, this.b, this.c, e);
      },
      containsPoint: function (t) {
        return qr.containsPoint(t, this.a, this.b, this.c);
      },
      getUV: function (t, e, i, n, r) {
        return qr.getUV(t, this.a, this.b, this.c, e, i, n, r);
      },
      intersectsBox: function (t) {
        return t.intersectsTriangle(this);
      },
      closestPointToPoint:
        ((_r = new je()),
        (wr = new je()),
        (Mr = new je()),
        (Er = new je()),
        (Tr = new je()),
        (Sr = new je()),
        function (t, e) {
          void 0 === e &&
            (console.warn(
              'THREE.Triangle: .closestPointToPoint() target is now required'
            ),
            (e = new je()));
          var i,
            n,
            r = this.a,
            a = this.b,
            o = this.c;
          _r.subVectors(a, r), wr.subVectors(o, r), Er.subVectors(t, r);
          var s = _r.dot(Er),
            c = wr.dot(Er);
          if (s <= 0 && c <= 0) return e.copy(r);
          Tr.subVectors(t, a);
          var h = _r.dot(Tr),
            l = wr.dot(Tr);
          if (0 <= h && l <= h) return e.copy(a);
          var u = s * l - h * c;
          if (u <= 0 && 0 <= s && h <= 0)
            return (i = s / (s - h)), e.copy(r).addScaledVector(_r, i);
          Sr.subVectors(t, o);
          var p = _r.dot(Sr),
            d = wr.dot(Sr);
          if (0 <= d && p <= d) return e.copy(o);
          var f = p * c - s * d;
          if (f <= 0 && 0 <= c && d <= 0)
            return (n = c / (c - d)), e.copy(r).addScaledVector(wr, n);
          var m = h * d - p * l;
          if (m <= 0 && 0 <= l - h && 0 <= p - d)
            return (
              Mr.subVectors(o, a),
              (n = (l - h) / (l - h + (p - d))),
              e.copy(a).addScaledVector(Mr, n)
            );
          var g = 1 / (m + f + u);
          return (
            (i = f * g),
            (n = u * g),
            e.copy(r).addScaledVector(_r, i).addScaledVector(wr, n)
          );
        }),
      equals: function (t) {
        return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c);
      }
    }),
    (((Yr.prototype = Object.create(
      jr.prototype
    )).constructor = Yr).prototype.isMeshBasicMaterial = !0),
    (Yr.prototype.copy = function (t) {
      return (
        jr.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        this
      );
    }),
    (Jr.prototype = Object.assign(Object.create(bn.prototype), {
      constructor: Jr,
      isMesh: !0,
      setDrawMode: function (t) {
        this.drawMode = t;
      },
      copy: function (t) {
        return (
          bn.prototype.copy.call(this, t),
          (this.drawMode = t.drawMode),
          void 0 !== t.morphTargetInfluences &&
            (this.morphTargetInfluences = t.morphTargetInfluences.slice()),
          void 0 !== t.morphTargetDictionary &&
            (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)),
          this
        );
      },
      updateMorphTargets: function () {
        var t,
          e,
          i,
          n = this.geometry;
        if (n.isBufferGeometry) {
          var r = n.morphAttributes,
            a = Object.keys(r);
          if (0 < a.length) {
            var o = r[a[0]];
            if (void 0 !== o)
              for (
                this.morphTargetInfluences = [],
                  this.morphTargetDictionary = {},
                  t = 0,
                  e = o.length;
                t < e;
                t++
              )
                (i = o[t].name || String(t)),
                  this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[i] = t);
          }
        } else {
          var s = n.morphTargets;
          if (void 0 !== s && 0 < s.length)
            for (
              this.morphTargetInfluences = [],
                this.morphTargetDictionary = {},
                t = 0,
                e = s.length;
              t < e;
              t++
            )
              (i = s[t].name || String(t)),
                this.morphTargetInfluences.push(0),
                (this.morphTargetDictionary[i] = t);
        }
      },
      raycast:
        ((Rr = new Ve()),
        (Pr = new Xr()),
        (Cr = new Oi()),
        (Or = new je()),
        (Ir = new je()),
        (Nr = new je()),
        (Dr = new je()),
        (Ur = new je()),
        (Br = new je()),
        (Fr = new He()),
        (zr = new He()),
        (Gr = new He()),
        (Hr = new je()),
        (Vr = new je()),
        function (t, e) {
          var i,
            n = this.geometry,
            r = this.material,
            a = this.matrixWorld;
          if (
            void 0 !== r &&
            (null === n.boundingSphere && n.computeBoundingSphere(),
            Cr.copy(n.boundingSphere),
            Cr.applyMatrix4(a),
            !1 !== t.ray.intersectsSphere(Cr) &&
              (Rr.getInverse(a),
              Pr.copy(t.ray).applyMatrix4(Rr),
              null === n.boundingBox || !1 !== Pr.intersectsBox(n.boundingBox)))
          )
            if (n.isBufferGeometry) {
              var o,
                s,
                c,
                h,
                l,
                u,
                p,
                d,
                f,
                m = n.index,
                g = n.attributes.position,
                v = n.attributes.uv,
                y = n.groups,
                x = n.drawRange;
              if (null !== m)
                if (Array.isArray(r))
                  for (h = 0, u = y.length; h < u; h++)
                    for (
                      f = r[(d = y[h]).materialIndex],
                        l = Math.max(d.start, x.start),
                        p = Math.min(d.start + d.count, x.start + x.count);
                      l < p;
                      l += 3
                    )
                      (o = m.getX(l)),
                        (s = m.getX(l + 1)),
                        (c = m.getX(l + 2)),
                        (i = Qr(this, f, t, Pr, g, v, o, s, c)) &&
                          ((i.faceIndex = Math.floor(l / 3)), e.push(i));
                else
                  for (
                    h = Math.max(0, x.start), u = Math.min(m.count, x.start + x.count);
                    h < u;
                    h += 3
                  )
                    (o = m.getX(h)),
                      (s = m.getX(h + 1)),
                      (c = m.getX(h + 2)),
                      (i = Qr(this, r, t, Pr, g, v, o, s, c)) &&
                        ((i.faceIndex = Math.floor(h / 3)), e.push(i));
              else if (void 0 !== g)
                if (Array.isArray(r))
                  for (h = 0, u = y.length; h < u; h++)
                    for (
                      f = r[(d = y[h]).materialIndex],
                        l = Math.max(d.start, x.start),
                        p = Math.min(d.start + d.count, x.start + x.count);
                      l < p;
                      l += 3
                    )
                      (i = Qr(this, f, t, Pr, g, v, (o = l), (s = l + 1), (c = l + 2))) &&
                        ((i.faceIndex = Math.floor(l / 3)), e.push(i));
                else
                  for (
                    h = Math.max(0, x.start), u = Math.min(g.count, x.start + x.count);
                    h < u;
                    h += 3
                  )
                    (i = Qr(this, r, t, Pr, g, v, (o = h), (s = h + 1), (c = h + 2))) &&
                      ((i.faceIndex = Math.floor(h / 3)), e.push(i));
            } else if (n.isGeometry) {
              var b,
                _,
                w,
                M,
                E = Array.isArray(r),
                T = n.vertices,
                S = n.faces,
                A = n.faceVertexUvs[0];
              0 < A.length && (M = A);
              for (var L = 0, R = S.length; L < R; L++) {
                var P = S[L],
                  C = E ? r[P.materialIndex] : r;
                if (void 0 !== C) {
                  if (((b = T[P.a]), (_ = T[P.b]), (w = T[P.c]), !0 === C.morphTargets)) {
                    var O = n.morphTargets,
                      I = this.morphTargetInfluences;
                    Or.set(0, 0, 0), Ir.set(0, 0, 0), Nr.set(0, 0, 0);
                    for (var N = 0, D = O.length; N < D; N++) {
                      var U = I[N];
                      if (0 !== U) {
                        var B = O[N].vertices;
                        Or.addScaledVector(Dr.subVectors(B[P.a], b), U),
                          Ir.addScaledVector(Ur.subVectors(B[P.b], _), U),
                          Nr.addScaledVector(Br.subVectors(B[P.c], w), U);
                      }
                    }
                    Or.add(b), Ir.add(_), Nr.add(w), (b = Or), (_ = Ir), (w = Nr);
                  }
                  if ((i = Zr(this, C, t, Pr, b, _, w, Hr))) {
                    if (M && M[L]) {
                      var F = M[L];
                      Fr.copy(F[0]),
                        zr.copy(F[1]),
                        Gr.copy(F[2]),
                        (i.uv = qr.getUV(Hr, b, _, w, Fr, zr, Gr, new He()));
                    }
                    (i.face = P), (i.faceIndex = L), e.push(i);
                  }
                }
              }
            }
        }),
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      }
    })),
    (((ha.prototype = Object.create(
      Ei.prototype
    )).constructor = ha).prototype.isCubeTexture = !0),
    Object.defineProperty(ha.prototype, 'images', {
      get: function () {
        return this.image;
      },
      set: function (t) {
        this.image = t;
      }
    }),
    (((la.prototype = Object.create(
      Ei.prototype
    )).constructor = la).prototype.isDataTexture3D = !0);
  var ua = new Ei(),
    pa = new la(),
    da = new ha();
  function fa() {
    (this.seq = []), (this.map = {});
  }
  var ma = [],
    ga = [],
    va = new Float32Array(16),
    ya = new Float32Array(9),
    xa = new Float32Array(4);
  function ba(t, e, i) {
    var n = t[0];
    if (n <= 0 || 0 < n) return t;
    var r = e * i,
      a = ma[r];
    if ((void 0 === a && ((a = new Float32Array(r)), (ma[r] = a)), 0 !== e)) {
      n.toArray(a, 0);
      for (var o = 1, s = 0; o !== e; ++o) (s += i), t[o].toArray(a, s);
    }
    return a;
  }
  function _a(t, e) {
    if (t.length !== e.length) return !1;
    for (var i = 0, n = t.length; i < n; i++) if (t[i] !== e[i]) return !1;
    return !0;
  }
  function wa(t, e) {
    for (var i = 0, n = e.length; i < n; i++) t[i] = e[i];
  }
  function Ma(t, e) {
    var i = ga[e];
    void 0 === i && ((i = new Int32Array(e)), (ga[e] = i));
    for (var n = 0; n !== e; ++n) i[n] = t.allocTextureUnit();
    return i;
  }
  function Ea(t, e) {
    var i = this.cache;
    i[0] !== e && (t.uniform1f(this.addr, e), (i[0] = e));
  }
  function Ta(t, e) {
    var i = this.cache;
    i[0] !== e && (t.uniform1i(this.addr, e), (i[0] = e));
  }
  function Sa(t, e) {
    var i = this.cache;
    if (void 0 !== e.x)
      (i[0] === e.x && i[1] === e.y) ||
        (t.uniform2f(this.addr, e.x, e.y), (i[0] = e.x), (i[1] = e.y));
    else {
      if (_a(i, e)) return;
      t.uniform2fv(this.addr, e), wa(i, e);
    }
  }
  function Aa(t, e) {
    var i = this.cache;
    if (void 0 !== e.x)
      (i[0] === e.x && i[1] === e.y && i[2] === e.z) ||
        (t.uniform3f(this.addr, e.x, e.y, e.z), (i[0] = e.x), (i[1] = e.y), (i[2] = e.z));
    else if (void 0 !== e.r)
      (i[0] === e.r && i[1] === e.g && i[2] === e.b) ||
        (t.uniform3f(this.addr, e.r, e.g, e.b), (i[0] = e.r), (i[1] = e.g), (i[2] = e.b));
    else {
      if (_a(i, e)) return;
      t.uniform3fv(this.addr, e), wa(i, e);
    }
  }
  function La(t, e) {
    var i = this.cache;
    if (void 0 !== e.x)
      (i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w) ||
        (t.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        (i[0] = e.x),
        (i[1] = e.y),
        (i[2] = e.z),
        (i[3] = e.w));
    else {
      if (_a(i, e)) return;
      t.uniform4fv(this.addr, e), wa(i, e);
    }
  }
  function Ra(t, e) {
    var i = this.cache,
      n = e.elements;
    if (void 0 === n) {
      if (_a(i, e)) return;
      t.uniformMatrix2fv(this.addr, !1, e), wa(i, e);
    } else {
      if (_a(i, n)) return;
      xa.set(n), t.uniformMatrix2fv(this.addr, !1, xa), wa(i, n);
    }
  }
  function Pa(t, e) {
    var i = this.cache,
      n = e.elements;
    if (void 0 === n) {
      if (_a(i, e)) return;
      t.uniformMatrix3fv(this.addr, !1, e), wa(i, e);
    } else {
      if (_a(i, n)) return;
      ya.set(n), t.uniformMatrix3fv(this.addr, !1, ya), wa(i, n);
    }
  }
  function Ca(t, e) {
    var i = this.cache,
      n = e.elements;
    if (void 0 === n) {
      if (_a(i, e)) return;
      t.uniformMatrix4fv(this.addr, !1, e), wa(i, e);
    } else {
      if (_a(i, n)) return;
      va.set(n), t.uniformMatrix4fv(this.addr, !1, va), wa(i, n);
    }
  }
  function Oa(t, e, i) {
    var n = this.cache,
      r = i.allocTextureUnit();
    n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)), i.setTexture2D(e || ua, r);
  }
  function Ia(t, e, i) {
    var n = this.cache,
      r = i.allocTextureUnit();
    n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)), i.setTexture3D(e || pa, r);
  }
  function Na(t, e, i) {
    var n = this.cache,
      r = i.allocTextureUnit();
    n[0] !== r && (t.uniform1i(this.addr, r), (n[0] = r)), i.setTextureCube(e || da, r);
  }
  function Da(t, e) {
    var i = this.cache;
    _a(i, e) || (t.uniform2iv(this.addr, e), wa(i, e));
  }
  function Ua(t, e) {
    var i = this.cache;
    _a(i, e) || (t.uniform3iv(this.addr, e), wa(i, e));
  }
  function Ba(t, e) {
    var i = this.cache;
    _a(i, e) || (t.uniform4iv(this.addr, e), wa(i, e));
  }
  function Fa(t, e) {
    var i = this.cache;
    _a(i, e) || (t.uniform1fv(this.addr, e), wa(i, e));
  }
  function za(t, e) {
    var i = this.cache;
    _a(i, e) || (t.uniform1iv(this.addr, e), wa(i, e));
  }
  function Ga(t, e) {
    var i = this.cache,
      n = ba(e, this.size, 2);
    _a(i, n) || (t.uniform2fv(this.addr, n), this.updateCache(n));
  }
  function Ha(t, e) {
    var i = this.cache,
      n = ba(e, this.size, 3);
    _a(i, n) || (t.uniform3fv(this.addr, n), this.updateCache(n));
  }
  function Va(t, e) {
    var i = this.cache,
      n = ba(e, this.size, 4);
    _a(i, n) || (t.uniform4fv(this.addr, n), this.updateCache(n));
  }
  function ka(t, e) {
    var i = this.cache,
      n = ba(e, this.size, 4);
    _a(i, n) || (t.uniformMatrix2fv(this.addr, !1, n), this.updateCache(n));
  }
  function ja(t, e) {
    var i = this.cache,
      n = ba(e, this.size, 9);
    _a(i, n) || (t.uniformMatrix3fv(this.addr, !1, n), this.updateCache(n));
  }
  function Wa(t, e) {
    var i = this.cache,
      n = ba(e, this.size, 16);
    _a(i, n) || (t.uniformMatrix4fv(this.addr, !1, n), this.updateCache(n));
  }
  function Xa(t, e, i) {
    var n = this.cache,
      r = e.length,
      a = Ma(i, r);
    !1 === _a(n, a) && (t.uniform1iv(this.addr, a), wa(n, a));
    for (var o = 0; o !== r; ++o) i.setTexture2D(e[o] || ua, a[o]);
  }
  function qa(t, e, i) {
    var n = this.cache,
      r = e.length,
      a = Ma(i, r);
    !1 === _a(n, a) && (t.uniform1iv(this.addr, a), wa(n, a));
    for (var o = 0; o !== r; ++o) i.setTextureCube(e[o] || da, a[o]);
  }
  function Ya(t, e, i) {
    (this.id = t),
      (this.addr = i),
      (this.cache = []),
      (this.setValue = (function (t) {
        switch (t) {
          case 5126:
            return Ea;
          case 35664:
            return Sa;
          case 35665:
            return Aa;
          case 35666:
            return La;
          case 35674:
            return Ra;
          case 35675:
            return Pa;
          case 35676:
            return Ca;
          case 35678:
          case 36198:
            return Oa;
          case 35679:
            return Ia;
          case 35680:
            return Na;
          case 5124:
          case 35670:
            return Ta;
          case 35667:
          case 35671:
            return Da;
          case 35668:
          case 35672:
            return Ua;
          case 35669:
          case 35673:
            return Ba;
        }
      })(e.type));
  }
  function Ja(t, e, i) {
    (this.id = t),
      (this.addr = i),
      (this.cache = []),
      (this.size = e.size),
      (this.setValue = (function (t) {
        switch (t) {
          case 5126:
            return Fa;
          case 35664:
            return Ga;
          case 35665:
            return Ha;
          case 35666:
            return Va;
          case 35674:
            return ka;
          case 35675:
            return ja;
          case 35676:
            return Wa;
          case 35678:
            return Xa;
          case 35680:
            return qa;
          case 5124:
          case 35670:
            return za;
          case 35667:
          case 35671:
            return Da;
          case 35668:
          case 35672:
            return Ua;
          case 35669:
          case 35673:
            return Ba;
        }
      })(e.type));
  }
  function Za(t) {
    (this.id = t), fa.call(this);
  }
  (Ja.prototype.updateCache = function (t) {
    var e = this.cache;
    t instanceof Float32Array &&
      e.length !== t.length &&
      (this.cache = new Float32Array(t.length)),
      wa(e, t);
  }),
    (Za.prototype.setValue = function (t, e, i) {
      for (var n = this.seq, r = 0, a = n.length; r !== a; ++r) {
        var o = n[r];
        o.setValue(t, e[o.id], i);
      }
    });
  var Qa = /([\w\d_]+)(\])?(\[|\.)?/g;
  function Ka(t, e) {
    t.seq.push(e), (t.map[e.id] = e);
  }
  function $a(t, e, i) {
    var n = t.name,
      r = n.length;
    for (Qa.lastIndex = 0; ; ) {
      var a = Qa.exec(n),
        o = Qa.lastIndex,
        s = a[1],
        c = ']' === a[2],
        h = a[3];
      if ((c && (s |= 0), void 0 === h || ('[' === h && o + 2 === r))) {
        Ka(i, new (void 0 === h ? Ya : Ja)(s, t, e));
        break;
      }
      var l = i.map[s];
      void 0 === l && Ka(i, (l = new Za(s))), (i = l);
    }
  }
  function to(t, e, i) {
    fa.call(this), (this.renderer = i);
    for (var n = t.getProgramParameter(e, t.ACTIVE_UNIFORMS), r = 0; r < n; ++r) {
      var a = t.getActiveUniform(e, r);
      $a(a, t.getUniformLocation(e, a.name), this);
    }
  }
  function eo(t, e, i) {
    var n = t.createShader(e);
    return (
      t.shaderSource(n, i),
      t.compileShader(n),
      !1 === t.getShaderParameter(n, t.COMPILE_STATUS) &&
        console.error("THREE.WebGLShader: Shader couldn't compile."),
      '' !== t.getShaderInfoLog(n) &&
        console.warn(
          'THREE.WebGLShader: gl.getShaderInfoLog()',
          e === t.VERTEX_SHADER ? 'vertex' : 'fragment',
          t.getShaderInfoLog(n),
          (function (t) {
            for (var e = t.split('\n'), i = 0; i < e.length; i++)
              e[i] = i + 1 + ': ' + e[i];
            return e.join('\n');
          })(i)
        ),
      n
    );
  }
  (to.prototype.setValue = function (t, e, i) {
    var n = this.map[e];
    void 0 !== n && n.setValue(t, i, this.renderer);
  }),
    (to.prototype.setOptional = function (t, e, i) {
      var n = e[i];
      void 0 !== n && this.setValue(t, i, n);
    }),
    (to.upload = function (t, e, i, n) {
      for (var r = 0, a = e.length; r !== a; ++r) {
        var o = e[r],
          s = i[o.id];
        !1 !== s.needsUpdate && o.setValue(t, s.value, n);
      }
    }),
    (to.seqWithValue = function (t, e) {
      for (var i = [], n = 0, r = t.length; n !== r; ++n) {
        var a = t[n];
        a.id in e && i.push(a);
      }
      return i;
    });
  var io = 0;
  function no(t) {
    switch (t) {
      case Re:
        return ['Linear', '( value )'];
      case Pe:
        return ['sRGB', '( value )'];
      case Oe:
        return ['RGBE', '( value )'];
      case Ie:
        return ['RGBM', '( value, 7.0 )'];
      case Ne:
        return ['RGBM', '( value, 16.0 )'];
      case De:
        return ['RGBD', '( value, 256.0 )'];
      case Ce:
        return ['Gamma', '( value, float( GAMMA_FACTOR ) )'];
      default:
        throw new Error('unsupported encoding: ' + t);
    }
  }
  function ro(t, e) {
    var i = no(e);
    return 'vec4 ' + t + '( vec4 value ) { return ' + i[0] + 'ToLinear' + i[1] + '; }';
  }
  function ao(t) {
    return '' !== t;
  }
  function oo(t, e) {
    return t
      .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
      .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
      .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
      .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
      .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights);
  }
  function so(t, e) {
    return t
      .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
      .replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection);
  }
  function co(t) {
    return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, function (t, e) {
      var i = Fi[e];
      if (void 0 === i) throw new Error('Can not resolve #include <' + e + '>');
      return co(i);
    });
  }
  function ho(t) {
    return t.replace(
      /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
      function (t, e, i, n) {
        for (var r = '', a = parseInt(e); a < parseInt(i); a++)
          r += n.replace(/\[ i \]/g, '[ ' + a + ' ]');
        return r;
      }
    );
  }
  function lo(t, e, i, n, r, a, o) {
    var s = t.context,
      c = n.defines,
      h = r.vertexShader,
      l = r.fragmentShader,
      u = 'SHADOWMAP_TYPE_BASIC';
    a.shadowMapType === G
      ? (u = 'SHADOWMAP_TYPE_PCF')
      : a.shadowMapType === H && (u = 'SHADOWMAP_TYPE_PCF_SOFT');
    var p = 'ENVMAP_TYPE_CUBE',
      d = 'ENVMAP_MODE_REFLECTION',
      f = 'ENVMAP_BLENDING_MULTIPLY';
    if (a.envMap) {
      switch (n.envMap.mapping) {
        case mt:
        case gt:
          p = 'ENVMAP_TYPE_CUBE';
          break;
        case bt:
        case _t:
          p = 'ENVMAP_TYPE_CUBE_UV';
          break;
        case vt:
        case yt:
          p = 'ENVMAP_TYPE_EQUIREC';
          break;
        case xt:
          p = 'ENVMAP_TYPE_SPHERE';
      }
      switch (n.envMap.mapping) {
        case gt:
        case yt:
          d = 'ENVMAP_MODE_REFRACTION';
      }
      switch (n.combine) {
        case k:
          f = 'ENVMAP_BLENDING_MULTIPLY';
          break;
        case j:
          f = 'ENVMAP_BLENDING_MIX';
          break;
        case W:
          f = 'ENVMAP_BLENDING_ADD';
      }
    }
    var m,
      g,
      v,
      y,
      x,
      b,
      _,
      w,
      M = 0 < t.gammaFactor ? t.gammaFactor : 1,
      E = o.isWebGL2
        ? ''
        : ((m = n.extensions),
          (g = a),
          (v = e),
          [
            (m = m || {}).derivatives ||
            g.envMapCubeUV ||
            g.bumpMap ||
            (g.normalMap && !g.objectSpaceNormalMap) ||
            g.flatShading
              ? '#extension GL_OES_standard_derivatives : enable'
              : '',
            (m.fragDepth || g.logarithmicDepthBuffer) && v.get('EXT_frag_depth')
              ? '#extension GL_EXT_frag_depth : enable'
              : '',
            m.drawBuffers && v.get('WEBGL_draw_buffers')
              ? '#extension GL_EXT_draw_buffers : require'
              : '',
            (m.shaderTextureLOD || g.envMap) && v.get('EXT_shader_texture_lod')
              ? '#extension GL_EXT_shader_texture_lod : enable'
              : ''
          ]
            .filter(ao)
            .join('\n')),
      T = (function (t) {
        var e = [];
        for (var i in t) {
          var n = t[i];
          !1 !== n && e.push('#define ' + i + ' ' + n);
        }
        return e.join('\n');
      })(c),
      S = s.createProgram();
    if (
      (n.isRawShaderMaterial
        ? (0 < (y = [T].filter(ao).join('\n')).length && (y += '\n'),
          0 < (x = [E, T].filter(ao).join('\n')).length && (x += '\n'))
        : ((y = [
            'precision ' + a.precision + ' float;',
            'precision ' + a.precision + ' int;',
            '#define SHADER_NAME ' + r.name,
            T,
            a.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
            '#define GAMMA_FACTOR ' + M,
            '#define MAX_BONES ' + a.maxBones,
            a.useFog && a.fog ? '#define USE_FOG' : '',
            a.useFog && a.fogExp ? '#define FOG_EXP2' : '',
            a.map ? '#define USE_MAP' : '',
            a.envMap ? '#define USE_ENVMAP' : '',
            a.envMap ? '#define ' + d : '',
            a.lightMap ? '#define USE_LIGHTMAP' : '',
            a.aoMap ? '#define USE_AOMAP' : '',
            a.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            a.bumpMap ? '#define USE_BUMPMAP' : '',
            a.normalMap ? '#define USE_NORMALMAP' : '',
            a.normalMap && a.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            a.displacementMap && a.supportsVertexTextures
              ? '#define USE_DISPLACEMENTMAP'
              : '',
            a.specularMap ? '#define USE_SPECULARMAP' : '',
            a.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            a.metalnessMap ? '#define USE_METALNESSMAP' : '',
            a.alphaMap ? '#define USE_ALPHAMAP' : '',
            a.vertexColors ? '#define USE_COLOR' : '',
            a.flatShading ? '#define FLAT_SHADED' : '',
            a.skinning ? '#define USE_SKINNING' : '',
            a.useVertexTexture ? '#define BONE_TEXTURE' : '',
            a.morphTargets ? '#define USE_MORPHTARGETS' : '',
            a.morphNormals && !1 === a.flatShading ? '#define USE_MORPHNORMALS' : '',
            a.doubleSided ? '#define DOUBLE_SIDED' : '',
            a.flipSided ? '#define FLIP_SIDED' : '',
            a.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            a.shadowMapEnabled ? '#define ' + u : '',
            a.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
            a.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            a.logarithmicDepthBuffer && (o.isWebGL2 || e.get('EXT_frag_depth'))
              ? '#define USE_LOGDEPTHBUF_EXT'
              : '',
            'uniform mat4 modelMatrix;',
            'uniform mat4 modelViewMatrix;',
            'uniform mat4 projectionMatrix;',
            'uniform mat4 viewMatrix;',
            'uniform mat3 normalMatrix;',
            'uniform vec3 cameraPosition;',
            'attribute vec3 position;',
            'attribute vec3 normal;',
            'attribute vec2 uv;',
            '#ifdef USE_COLOR',
            '    attribute vec3 color;',
            '#endif',
            '#ifdef USE_MORPHTARGETS',
            '    attribute vec3 morphTarget0;',
            '    attribute vec3 morphTarget1;',
            '    attribute vec3 morphTarget2;',
            '    attribute vec3 morphTarget3;',
            '    #ifdef USE_MORPHNORMALS',
            '        attribute vec3 morphNormal0;',
            '        attribute vec3 morphNormal1;',
            '        attribute vec3 morphNormal2;',
            '        attribute vec3 morphNormal3;',
            '    #else',
            '        attribute vec3 morphTarget4;',
            '        attribute vec3 morphTarget5;',
            '        attribute vec3 morphTarget6;',
            '        attribute vec3 morphTarget7;',
            '    #endif',
            '#endif',
            '#ifdef USE_SKINNING',
            '    attribute vec4 skinIndex;',
            '    attribute vec4 skinWeight;',
            '#endif',
            '\n'
          ]
            .filter(ao)
            .join('\n')),
          (x = [
            E,
            'precision ' + a.precision + ' float;',
            'precision ' + a.precision + ' int;',
            '#define SHADER_NAME ' + r.name,
            T,
            a.alphaTest
              ? '#define ALPHATEST ' + a.alphaTest + (a.alphaTest % 1 ? '' : '.0')
              : '',
            '#define GAMMA_FACTOR ' + M,
            a.useFog && a.fog ? '#define USE_FOG' : '',
            a.useFog && a.fogExp ? '#define FOG_EXP2' : '',
            a.map ? '#define USE_MAP' : '',
            a.envMap ? '#define USE_ENVMAP' : '',
            a.envMap ? '#define ' + p : '',
            a.envMap ? '#define ' + d : '',
            a.envMap ? '#define ' + f : '',
            a.lightMap ? '#define USE_LIGHTMAP' : '',
            a.aoMap ? '#define USE_AOMAP' : '',
            a.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
            a.bumpMap ? '#define USE_BUMPMAP' : '',
            a.normalMap ? '#define USE_NORMALMAP' : '',
            a.normalMap && a.objectSpaceNormalMap ? '#define OBJECTSPACE_NORMALMAP' : '',
            a.specularMap ? '#define USE_SPECULARMAP' : '',
            a.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
            a.metalnessMap ? '#define USE_METALNESSMAP' : '',
            a.alphaMap ? '#define USE_ALPHAMAP' : '',
            a.vertexColors ? '#define USE_COLOR' : '',
            a.gradientMap ? '#define USE_GRADIENTMAP' : '',
            a.flatShading ? '#define FLAT_SHADED' : '',
            a.doubleSided ? '#define DOUBLE_SIDED' : '',
            a.flipSided ? '#define FLIP_SIDED' : '',
            a.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
            a.shadowMapEnabled ? '#define ' + u : '',
            a.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
            a.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
            a.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
            a.logarithmicDepthBuffer && (o.isWebGL2 || e.get('EXT_frag_depth'))
              ? '#define USE_LOGDEPTHBUF_EXT'
              : '',
            a.envMap && (o.isWebGL2 || e.get('EXT_shader_texture_lod'))
              ? '#define TEXTURE_LOD_EXT'
              : '',
            'uniform mat4 viewMatrix;',
            'uniform vec3 cameraPosition;',
            a.toneMapping !== ut ? '#define TONE_MAPPING' : '',
            a.toneMapping !== ut ? Fi.tonemapping_pars_fragment : '',
            a.toneMapping !== ut
              ? (function (t, e) {
                  var i;
                  switch (e) {
                    case Mt:
                      i = 'Linear';
                      break;
                    case pt:
                      i = 'Reinhard';
                      break;
                    case dt:
                      i = 'Uncharted2';
                      break;
                    case ft:
                      i = 'OptimizedCineon';
                      break;
                    default:
                      throw new Error('unsupported toneMapping: ' + e);
                  }
                  return (
                    'vec3 ' +
                    t +
                    '( vec3 color ) { return ' +
                    i +
                    'ToneMapping( color ); }'
                  );
                })('toneMapping', a.toneMapping)
              : '',
            a.dithering ? '#define DITHERING' : '',
            a.outputEncoding ||
            a.mapEncoding ||
            a.matcapEncoding ||
            a.envMapEncoding ||
            a.emissiveMapEncoding
              ? Fi.encodings_pars_fragment
              : '',
            a.mapEncoding ? ro('mapTexelToLinear', a.mapEncoding) : '',
            a.matcapEncoding ? ro('matcapTexelToLinear', a.matcapEncoding) : '',
            a.envMapEncoding ? ro('envMapTexelToLinear', a.envMapEncoding) : '',
            a.emissiveMapEncoding
              ? ro('emissiveMapTexelToLinear', a.emissiveMapEncoding)
              : '',
            a.outputEncoding
              ? ((b = 'linearToOutputTexel'),
                (_ = a.outputEncoding),
                (w = no(_)),
                'vec4 ' + b + '( vec4 value ) { return LinearTo' + w[0] + w[1] + '; }')
              : '',
            a.depthPacking ? '#define DEPTH_PACKING ' + n.depthPacking : '',
            '\n'
          ]
            .filter(ao)
            .join('\n'))),
      (h = so((h = oo((h = co(h)), a)), a)),
      (l = so((l = oo((l = co(l)), a)), a)),
      (h = ho(h)),
      (l = ho(l)),
      o.isWebGL2 && !n.isRawShaderMaterial)
    ) {
      var A = !1,
        L = /^\s*#version\s+300\s+es\s*\n/;
      n.isShaderMaterial &&
        null !== h.match(L) &&
        null !== l.match(L) &&
        ((A = !0), (h = h.replace(L, '')), (l = l.replace(L, ''))),
        (y =
          [
            '#version 300 es\n',
            '#define attribute in',
            '#define varying out',
            '#define texture2D texture'
          ].join('\n') +
          '\n' +
          y),
        (x =
          [
            '#version 300 es\n',
            '#define varying in',
            A ? '' : 'out highp vec4 pc_fragColor;',
            A ? '' : '#define gl_FragColor pc_fragColor',
            '#define gl_FragDepthEXT gl_FragDepth',
            '#define texture2D texture',
            '#define textureCube texture',
            '#define texture2DProj textureProj',
            '#define texture2DLodEXT textureLod',
            '#define texture2DProjLodEXT textureProjLod',
            '#define textureCubeLodEXT textureLod',
            '#define texture2DGradEXT textureGrad',
            '#define texture2DProjGradEXT textureProjGrad',
            '#define textureCubeGradEXT textureGrad'
          ].join('\n') +
          '\n' +
          x);
    }
    var R = y + h,
      P = x + l,
      C = eo(s, s.VERTEX_SHADER, R),
      O = eo(s, s.FRAGMENT_SHADER, P);
    s.attachShader(S, C),
      s.attachShader(S, O),
      void 0 !== n.index0AttributeName
        ? s.bindAttribLocation(S, 0, n.index0AttributeName)
        : !0 === a.morphTargets && s.bindAttribLocation(S, 0, 'position'),
      s.linkProgram(S);
    var I,
      N,
      D = s.getProgramInfoLog(S).trim(),
      U = s.getShaderInfoLog(C).trim(),
      B = s.getShaderInfoLog(O).trim(),
      F = !0,
      z = !0;
    return (
      !1 === s.getProgramParameter(S, s.LINK_STATUS)
        ? ((F = !1),
          console.error(
            'THREE.WebGLProgram: shader error: ',
            s.getError(),
            'gl.VALIDATE_STATUS',
            s.getProgramParameter(S, s.VALIDATE_STATUS),
            'gl.getProgramInfoLog',
            D,
            U,
            B
          ))
        : '' !== D
        ? console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()', D)
        : ('' !== U && '' !== B) || (z = !1),
      z &&
        (this.diagnostics = {
          runnable: F,
          material: n,
          programLog: D,
          vertexShader: { log: U, prefix: y },
          fragmentShader: { log: B, prefix: x }
        }),
      s.deleteShader(C),
      s.deleteShader(O),
      (this.getUniforms = function () {
        return void 0 === I && (I = new to(s, S, t)), I;
      }),
      (this.getAttributes = function () {
        return (
          void 0 === N &&
            (N = (function (t, e) {
              for (
                var i = {}, n = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES), r = 0;
                r < n;
                r++
              ) {
                var a = t.getActiveAttrib(e, r).name;
                i[a] = t.getAttribLocation(e, a);
              }
              return i;
            })(s, S)),
          N
        );
      }),
      (this.destroy = function () {
        s.deleteProgram(S), (this.program = void 0);
      }),
      Object.defineProperties(this, {
        uniforms: {
          get: function () {
            return (
              console.warn('THREE.WebGLProgram: .uniforms is now .getUniforms().'),
              this.getUniforms()
            );
          }
        },
        attributes: {
          get: function () {
            return (
              console.warn('THREE.WebGLProgram: .attributes is now .getAttributes().'),
              this.getAttributes()
            );
          }
        }
      }),
      (this.name = r.name),
      (this.id = io++),
      (this.code = i),
      (this.usedTimes = 1),
      (this.program = S),
      (this.vertexShader = C),
      (this.fragmentShader = O),
      this
    );
  }
  function uo(u, c, p) {
    var h = [],
      d = {
        MeshDepthMaterial: 'depth',
        MeshDistanceMaterial: 'distanceRGBA',
        MeshNormalMaterial: 'normal',
        MeshBasicMaterial: 'basic',
        MeshLambertMaterial: 'lambert',
        MeshPhongMaterial: 'phong',
        MeshToonMaterial: 'phong',
        MeshStandardMaterial: 'physical',
        MeshPhysicalMaterial: 'physical',
        MeshMatcapMaterial: 'matcap',
        LineBasicMaterial: 'basic',
        LineDashedMaterial: 'dashed',
        PointsMaterial: 'points',
        ShadowMaterial: 'shadow',
        SpriteMaterial: 'sprite'
      },
      a = [
        'precision',
        'supportsVertexTextures',
        'map',
        'mapEncoding',
        'matcapEncoding',
        'envMap',
        'envMapMode',
        'envMapEncoding',
        'lightMap',
        'aoMap',
        'emissiveMap',
        'emissiveMapEncoding',
        'bumpMap',
        'normalMap',
        'objectSpaceNormalMap',
        'displacementMap',
        'specularMap',
        'roughnessMap',
        'metalnessMap',
        'gradientMap',
        'alphaMap',
        'combine',
        'vertexColors',
        'fog',
        'useFog',
        'fogExp',
        'flatShading',
        'sizeAttenuation',
        'logarithmicDepthBuffer',
        'skinning',
        'maxBones',
        'useVertexTexture',
        'morphTargets',
        'morphNormals',
        'maxMorphTargets',
        'maxMorphNormals',
        'premultipliedAlpha',
        'numDirLights',
        'numPointLights',
        'numSpotLights',
        'numHemiLights',
        'numRectAreaLights',
        'shadowMapEnabled',
        'shadowMapType',
        'toneMapping',
        'physicallyCorrectLights',
        'alphaTest',
        'doubleSided',
        'flipSided',
        'numClippingPlanes',
        'numClipIntersection',
        'depthPacking',
        'dithering'
      ];
    function f(t, e) {
      var i;
      return (
        t
          ? t.isTexture
            ? (i = t.encoding)
            : t.isWebGLRenderTarget &&
              (console.warn(
                "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."
              ),
              (i = t.texture.encoding))
          : (i = Re),
        i === Re && e && (i = Ce),
        i
      );
    }
    (this.getParameters = function (t, e, i, n, r, a, o) {
      var s = d[t.type],
        c = o.isSkinnedMesh
          ? (function (t) {
              var e = t.skeleton.bones;
              if (p.floatVertexTextures) return 1024;
              var i = p.maxVertexUniforms,
                n = Math.floor((i - 20) / 4),
                r = Math.min(n, e.length);
              return r < e.length
                ? (console.warn(
                    'THREE.WebGLRenderer: Skeleton has ' +
                      e.length +
                      ' bones. This GPU supports ' +
                      r +
                      '.'
                  ),
                  0)
                : r;
            })(o)
          : 0,
        h = p.precision;
      null !== t.precision &&
        (h = p.getMaxPrecision(t.precision)) !== t.precision &&
        console.warn(
          'THREE.WebGLProgram.getParameters:',
          t.precision,
          'not supported, using',
          h,
          'instead.'
        );
      var l = u.getRenderTarget();
      return {
        shaderID: s,
        precision: h,
        supportsVertexTextures: p.vertexTextures,
        outputEncoding: f(l ? l.texture : null, u.gammaOutput),
        map: !!t.map,
        mapEncoding: f(t.map, u.gammaInput),
        matcap: !!t.matcap,
        matcapEncoding: f(t.matcap, u.gammaInput),
        envMap: !!t.envMap,
        envMapMode: t.envMap && t.envMap.mapping,
        envMapEncoding: f(t.envMap, u.gammaInput),
        envMapCubeUV: !!t.envMap && (t.envMap.mapping === bt || t.envMap.mapping === _t),
        lightMap: !!t.lightMap,
        aoMap: !!t.aoMap,
        emissiveMap: !!t.emissiveMap,
        emissiveMapEncoding: f(t.emissiveMap, u.gammaInput),
        bumpMap: !!t.bumpMap,
        normalMap: !!t.normalMap,
        objectSpaceNormalMap: t.normalMapType === ze,
        displacementMap: !!t.displacementMap,
        roughnessMap: !!t.roughnessMap,
        metalnessMap: !!t.metalnessMap,
        specularMap: !!t.specularMap,
        alphaMap: !!t.alphaMap,
        gradientMap: !!t.gradientMap,
        combine: t.combine,
        vertexColors: t.vertexColors,
        fog: !!n,
        useFog: t.fog,
        fogExp: n && n.isFogExp2,
        flatShading: t.flatShading,
        sizeAttenuation: t.sizeAttenuation,
        logarithmicDepthBuffer: p.logarithmicDepthBuffer,
        skinning: t.skinning && 0 < c,
        maxBones: c,
        useVertexTexture: p.floatVertexTextures,
        morphTargets: t.morphTargets,
        morphNormals: t.morphNormals,
        maxMorphTargets: u.maxMorphTargets,
        maxMorphNormals: u.maxMorphNormals,
        numDirLights: e.directional.length,
        numPointLights: e.point.length,
        numSpotLights: e.spot.length,
        numRectAreaLights: e.rectArea.length,
        numHemiLights: e.hemi.length,
        numClippingPlanes: r,
        numClipIntersection: a,
        dithering: t.dithering,
        shadowMapEnabled: u.shadowMap.enabled && o.receiveShadow && 0 < i.length,
        shadowMapType: u.shadowMap.type,
        toneMapping: u.toneMapping,
        physicallyCorrectLights: u.physicallyCorrectLights,
        premultipliedAlpha: t.premultipliedAlpha,
        alphaTest: t.alphaTest,
        doubleSided: t.side === J,
        flipSided: t.side === wt,
        depthPacking: void 0 !== t.depthPacking && t.depthPacking
      };
    }),
      (this.getProgramCode = function (t, e) {
        var i = [];
        if (
          (e.shaderID
            ? i.push(e.shaderID)
            : (i.push(t.fragmentShader), i.push(t.vertexShader)),
          void 0 !== t.defines)
        )
          for (var n in t.defines) i.push(n), i.push(t.defines[n]);
        for (var r = 0; r < a.length; r++) i.push(e[a[r]]);
        return i.push(t.onBeforeCompile.toString()), i.push(u.gammaOutput), i.join();
      }),
      (this.acquireProgram = function (t, e, i, n) {
        for (var r, a = 0, o = h.length; a < o; a++) {
          var s = h[a];
          if (s.code === n) {
            ++(r = s).usedTimes;
            break;
          }
        }
        return void 0 === r && ((r = new lo(u, c, n, t, e, i, p)), h.push(r)), r;
      }),
      (this.releaseProgram = function (t) {
        if (0 == --t.usedTimes) {
          var e = h.indexOf(t);
          (h[e] = h[h.length - 1]), h.pop(), t.destroy();
        }
      }),
      (this.programs = h);
  }
  function po() {
    var n = new WeakMap();
    return {
      get: function (t) {
        var e = n.get(t);
        return void 0 === e && ((e = {}), n.set(t, e)), e;
      },
      remove: function (t) {
        n.delete(t);
      },
      update: function (t, e, i) {
        n.get(t)[e] = i;
      },
      dispose: function () {
        n = new WeakMap();
      }
    };
  }
  function fo(t, e) {
    return t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.program && e.program && t.program !== e.program
      ? t.program.id - e.program.id
      : t.material.id !== e.material.id
      ? t.material.id - e.material.id
      : t.z !== e.z
      ? t.z - e.z
      : t.id - e.id;
  }
  function mo(t, e) {
    return t.renderOrder !== e.renderOrder
      ? t.renderOrder - e.renderOrder
      : t.z !== e.z
      ? e.z - t.z
      : t.id - e.id;
  }
  function go() {
    var o = [],
      s = 0,
      c = [],
      h = [];
    return {
      opaque: c,
      transparent: h,
      init: function () {
        (s = 0), (c.length = 0), (h.length = 0);
      },
      push: function (t, e, i, n, r) {
        var a = o[s];
        void 0 === a
          ? ((a = {
              id: t.id,
              object: t,
              geometry: e,
              material: i,
              program: i.program,
              renderOrder: t.renderOrder,
              z: n,
              group: r
            }),
            (o[s] = a))
          : ((a.id = t.id),
            (a.object = t),
            (a.geometry = e),
            (a.material = i),
            (a.program = i.program),
            (a.renderOrder = t.renderOrder),
            (a.z = n),
            (a.group = r)),
          (!0 === i.transparent ? h : c).push(a),
          s++;
      },
      sort: function () {
        1 < c.length && c.sort(fo), 1 < h.length && h.sort(mo);
      }
    };
  }
  function vo() {
    var r = {};
    return {
      get: function (t, e) {
        var i = t.id + ',' + e.id,
          n = r[i];
        return void 0 === n && ((n = new go()), (r[i] = n)), n;
      },
      dispose: function () {
        r = {};
      }
    };
  }
  function yo() {
    var i = {};
    return {
      get: function (t) {
        if (void 0 !== i[t.id]) return i[t.id];
        var e;
        switch (t.type) {
          case 'DirectionalLight':
            e = {
              direction: new je(),
              color: new Hi(),
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new He()
            };
            break;
          case 'SpotLight':
            e = {
              position: new je(),
              direction: new je(),
              color: new Hi(),
              distance: 0,
              coneCos: 0,
              penumbraCos: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new He()
            };
            break;
          case 'PointLight':
            e = {
              position: new je(),
              color: new Hi(),
              distance: 0,
              decay: 0,
              shadow: !1,
              shadowBias: 0,
              shadowRadius: 1,
              shadowMapSize: new He(),
              shadowCameraNear: 1,
              shadowCameraFar: 1e3
            };
            break;
          case 'HemisphereLight':
            e = { direction: new je(), skyColor: new Hi(), groundColor: new Hi() };
            break;
          case 'RectAreaLight':
            e = {
              color: new Hi(),
              position: new je(),
              halfWidth: new je(),
              halfHeight: new je()
            };
        }
        return (i[t.id] = e);
      }
    };
  }
  var xo,
    bo,
    _o,
    wo,
    Mo,
    Eo,
    To,
    So,
    Ao,
    Lo,
    Ro,
    Po,
    Co,
    Oo,
    Io,
    No,
    Do,
    Uo,
    Bo,
    Fo,
    zo,
    Go,
    Ho,
    Vo,
    ko,
    jo,
    Wo,
    Xo,
    qo = 0;
  function Yo() {
    var _ = new yo(),
      w = {
        id: qo++,
        hash: {
          stateID: -1,
          directionalLength: -1,
          pointLength: -1,
          spotLength: -1,
          rectAreaLength: -1,
          hemiLength: -1,
          shadowsLength: -1
        },
        ambient: [0, 0, 0],
        directional: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        rectArea: [],
        point: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: []
      },
      M = new je(),
      E = new Ve(),
      T = new Ve();
    return {
      setup: function (t, e, i) {
        for (
          var n = 0,
            r = 0,
            a = 0,
            o = 0,
            s = 0,
            c = 0,
            h = 0,
            l = 0,
            u = i.matrixWorldInverse,
            p = 0,
            d = t.length;
          p < d;
          p++
        ) {
          var f = t[p],
            m = f.color,
            g = f.intensity,
            v = f.distance,
            y = f.shadow && f.shadow.map ? f.shadow.map.texture : null;
          if (f.isAmbientLight) (n += m.r * g), (r += m.g * g), (a += m.b * g);
          else if (f.isDirectionalLight) {
            if (
              ((b = _.get(f)).color.copy(f.color).multiplyScalar(f.intensity),
              b.direction.setFromMatrixPosition(f.matrixWorld),
              M.setFromMatrixPosition(f.target.matrixWorld),
              b.direction.sub(M),
              b.direction.transformDirection(u),
              (b.shadow = f.castShadow),
              f.castShadow)
            ) {
              var x = f.shadow;
              (b.shadowBias = x.bias),
                (b.shadowRadius = x.radius),
                (b.shadowMapSize = x.mapSize);
            }
            (w.directionalShadowMap[o] = y),
              (w.directionalShadowMatrix[o] = f.shadow.matrix),
              (w.directional[o] = b),
              o++;
          } else if (f.isSpotLight) {
            if (
              ((b = _.get(f)).position.setFromMatrixPosition(f.matrixWorld),
              b.position.applyMatrix4(u),
              b.color.copy(m).multiplyScalar(g),
              (b.distance = v),
              b.direction.setFromMatrixPosition(f.matrixWorld),
              M.setFromMatrixPosition(f.target.matrixWorld),
              b.direction.sub(M),
              b.direction.transformDirection(u),
              (b.coneCos = Math.cos(f.angle)),
              (b.penumbraCos = Math.cos(f.angle * (1 - f.penumbra))),
              (b.decay = f.decay),
              (b.shadow = f.castShadow),
              f.castShadow)
            ) {
              x = f.shadow;
              (b.shadowBias = x.bias),
                (b.shadowRadius = x.radius),
                (b.shadowMapSize = x.mapSize);
            }
            (w.spotShadowMap[c] = y),
              (w.spotShadowMatrix[c] = f.shadow.matrix),
              (w.spot[c] = b),
              c++;
          } else if (f.isRectAreaLight) {
            (b = _.get(f)).color.copy(m).multiplyScalar(g),
              b.position.setFromMatrixPosition(f.matrixWorld),
              b.position.applyMatrix4(u),
              T.identity(),
              E.copy(f.matrixWorld),
              E.premultiply(u),
              T.extractRotation(E),
              b.halfWidth.set(0.5 * f.width, 0, 0),
              b.halfHeight.set(0, 0.5 * f.height, 0),
              b.halfWidth.applyMatrix4(T),
              b.halfHeight.applyMatrix4(T),
              (w.rectArea[h] = b),
              h++;
          } else if (f.isPointLight) {
            if (
              ((b = _.get(f)).position.setFromMatrixPosition(f.matrixWorld),
              b.position.applyMatrix4(u),
              b.color.copy(f.color).multiplyScalar(f.intensity),
              (b.distance = f.distance),
              (b.decay = f.decay),
              (b.shadow = f.castShadow),
              f.castShadow)
            ) {
              x = f.shadow;
              (b.shadowBias = x.bias),
                (b.shadowRadius = x.radius),
                (b.shadowMapSize = x.mapSize),
                (b.shadowCameraNear = x.camera.near),
                (b.shadowCameraFar = x.camera.far);
            }
            (w.pointShadowMap[s] = y),
              (w.pointShadowMatrix[s] = f.shadow.matrix),
              (w.point[s] = b),
              s++;
          } else if (f.isHemisphereLight) {
            var b;
            (b = _.get(f)).direction.setFromMatrixPosition(f.matrixWorld),
              b.direction.transformDirection(u),
              b.direction.normalize(),
              b.skyColor.copy(f.color).multiplyScalar(g),
              b.groundColor.copy(f.groundColor).multiplyScalar(g),
              (w.hemi[l] = b),
              l++;
          }
        }
        (w.ambient[0] = n),
          (w.ambient[1] = r),
          (w.ambient[2] = a),
          (w.directional.length = o),
          (w.spot.length = c),
          (w.rectArea.length = h),
          (w.point.length = s),
          (w.hemi.length = l),
          (w.hash.stateID = w.id),
          (w.hash.directionalLength = o),
          (w.hash.pointLength = s),
          (w.hash.spotLength = c),
          (w.hash.rectAreaLength = h),
          (w.hash.hemiLength = l),
          (w.hash.shadowsLength = e.length);
      },
      state: w
    };
  }
  function Jo() {
    var e = new Yo(),
      i = [],
      n = [];
    return {
      init: function () {
        (i.length = 0), (n.length = 0);
      },
      state: { lightsArray: i, shadowsArray: n, lights: e },
      setupLights: function (t) {
        e.setup(i, n, t);
      },
      pushLight: function (t) {
        i.push(t);
      },
      pushShadow: function (t) {
        n.push(t);
      }
    };
  }
  function Zo() {
    var n = {};
    return {
      get: function (t, e) {
        var i;
        return (
          void 0 === n[t.id]
            ? ((i = new Jo()), (n[t.id] = {}), (n[t.id][e.id] = i))
            : void 0 === n[t.id][e.id]
            ? ((i = new Jo()), (n[t.id][e.id] = i))
            : (i = n[t.id][e.id]),
          i
        );
      },
      dispose: function () {
        n = {};
      }
    };
  }
  function Qo(t) {
    jr.call(this),
      (this.type = 'MeshDepthMaterial'),
      (this.depthPacking = Ue),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      this.setValues(t);
  }
  function Ko(t) {
    jr.call(this),
      (this.type = 'MeshDistanceMaterial'),
      (this.referencePosition = new je()),
      (this.nearDistance = 1),
      (this.farDistance = 1e3),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.fog = !1),
      (this.lights = !1),
      this.setValues(t);
  }
  function $o(x, m, t) {
    for (
      var b = new Ni(),
        _ = new Ve(),
        w = new He(),
        M = new He(t, t),
        E = new je(),
        T = new je(),
        v = 1,
        y = 2,
        e = 1 + (v | y),
        S = new Array(e),
        A = new Array(e),
        L = {},
        R = { 0: wt, 1: D, 2: J },
        P = [
          new je(1, 0, 0),
          new je(-1, 0, 0),
          new je(0, 0, 1),
          new je(0, 0, -1),
          new je(0, 1, 0),
          new je(0, -1, 0)
        ],
        C = [
          new je(0, 1, 0),
          new je(0, 1, 0),
          new je(0, 1, 0),
          new je(0, 1, 0),
          new je(0, 0, 1),
          new je(0, 0, -1)
        ],
        O = [new Ti(), new Ti(), new Ti(), new Ti(), new Ti(), new Ti()],
        i = 0;
      i !== e;
      ++i
    ) {
      var n = 0 != (i & v),
        r = 0 != (i & y),
        a = new Qo({ depthPacking: Be, morphTargets: n, skinning: r });
      S[i] = a;
      var o = new Ko({ morphTargets: n, skinning: r });
      A[i] = o;
    }
    var I = this;
    function g(t, e, i, n, r, a) {
      var o = t.geometry,
        s = null,
        c = S,
        h = t.customDepthMaterial;
      if ((i && ((c = A), (h = t.customDistanceMaterial)), h)) s = h;
      else {
        var l = !1;
        e.morphTargets &&
          (o && o.isBufferGeometry
            ? (l =
                o.morphAttributes &&
                o.morphAttributes.position &&
                0 < o.morphAttributes.position.length)
            : o && o.isGeometry && (l = o.morphTargets && 0 < o.morphTargets.length)),
          t.isSkinnedMesh &&
            !1 === e.skinning &&
            console.warn(
              'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:',
              t
            );
        var u = t.isSkinnedMesh && e.skinning,
          p = 0;
        l && (p |= v), u && (p |= y), (s = c[p]);
      }
      if (
        x.localClippingEnabled &&
        !0 === e.clipShadows &&
        0 !== e.clippingPlanes.length
      ) {
        var d = s.uuid,
          f = e.uuid,
          m = L[d];
        void 0 === m && ((m = {}), (L[d] = m));
        var g = m[f];
        void 0 === g && ((g = s.clone()), (m[f] = g)), (s = g);
      }
      return (
        (s.visible = e.visible),
        (s.wireframe = e.wireframe),
        (s.side = null != e.shadowSide ? e.shadowSide : R[e.side]),
        (s.clipShadows = e.clipShadows),
        (s.clippingPlanes = e.clippingPlanes),
        (s.clipIntersection = e.clipIntersection),
        (s.wireframeLinewidth = e.wireframeLinewidth),
        (s.linewidth = e.linewidth),
        i &&
          s.isMeshDistanceMaterial &&
          (s.referencePosition.copy(n), (s.nearDistance = r), (s.farDistance = a)),
        s
      );
    }
    function N(t, e, i, n) {
      if (!1 !== t.visible) {
        if (
          t.layers.test(e.layers) &&
          (t.isMesh || t.isLine || t.isPoints) &&
          t.castShadow &&
          (!t.frustumCulled || b.intersectsObject(t))
        ) {
          t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld);
          var r = m.update(t),
            a = t.material;
          if (Array.isArray(a))
            for (var o = r.groups, s = 0, c = o.length; s < c; s++) {
              var h = o[s],
                l = a[h.materialIndex];
              if (l && l.visible) {
                var u = g(t, l, n, T, i.near, i.far);
                x.renderBufferDirect(i, null, r, u, t, h);
              }
            }
          else if (a.visible) {
            u = g(t, a, n, T, i.near, i.far);
            x.renderBufferDirect(i, null, r, u, t, null);
          }
        }
        for (var p = t.children, d = 0, f = p.length; d < f; d++) N(p[d], e, i, n);
      }
    }
    (this.enabled = !1),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this.type = G),
      (this.render = function (t, e, i) {
        if (
          !1 !== I.enabled &&
          (!1 !== I.autoUpdate || !1 !== I.needsUpdate) &&
          0 !== t.length
        ) {
          var n,
            r = x.context,
            a = x.state;
          a.disable(r.BLEND),
            a.buffers.color.setClear(1, 1, 1, 1),
            a.buffers.depth.setTest(!0),
            a.setScissorTest(!1);
          for (var o = 0, s = t.length; o < s; o++) {
            var c = t[o],
              h = c.shadow,
              l = c && c.isPointLight;
            if (void 0 !== h) {
              var u = h.camera;
              if ((w.copy(h.mapSize), w.min(M), l)) {
                var p = w.x,
                  d = w.y;
                O[0].set(2 * p, d, p, d),
                  O[1].set(0, d, p, d),
                  O[2].set(3 * p, d, p, d),
                  O[3].set(p, d, p, d),
                  O[4].set(3 * p, 0, p, d),
                  O[5].set(p, 0, p, d),
                  (w.x *= 4),
                  (w.y *= 2);
              }
              if (null === h.map) {
                var f = { minFilter: At, magFilter: At, format: qt };
                (h.map = new Si(w.x, w.y, f)),
                  (h.map.texture.name = c.name + '.shadowMap'),
                  u.updateProjectionMatrix();
              }
              h.isSpotLightShadow && h.update(c);
              var m = h.map,
                g = h.matrix;
              T.setFromMatrixPosition(c.matrixWorld),
                u.position.copy(T),
                l
                  ? ((n = 6), g.makeTranslation(-T.x, -T.y, -T.z))
                  : ((n = 1),
                    E.setFromMatrixPosition(c.target.matrixWorld),
                    u.lookAt(E),
                    u.updateMatrixWorld(),
                    g.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
                    g.multiply(u.projectionMatrix),
                    g.multiply(u.matrixWorldInverse)),
                x.setRenderTarget(m),
                x.clear();
              for (var v = 0; v < n; v++) {
                if (l) {
                  E.copy(u.position),
                    E.add(P[v]),
                    u.up.copy(C[v]),
                    u.lookAt(E),
                    u.updateMatrixWorld();
                  var y = O[v];
                  a.viewport(y);
                }
                _.multiplyMatrices(u.projectionMatrix, u.matrixWorldInverse),
                  b.setFromMatrix(_),
                  N(e, i, u, l);
              }
            } else console.warn('THREE.WebGLShadowMap:', c, 'has no shadow.');
          }
          I.needsUpdate = !1;
        }
      });
  }
  function ts(l, i, c, n) {
    var r = new (function () {
        var e = !1,
          a = new Ti(),
          i = null,
          o = new Ti(0, 0, 0, 0);
        return {
          setMask: function (t) {
            i === t || e || (l.colorMask(t, t, t, t), (i = t));
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (t, e, i, n, r) {
            !0 === r && ((t *= n), (e *= n), (i *= n)),
              a.set(t, e, i, n),
              !1 === o.equals(a) && (l.clearColor(t, e, i, n), o.copy(a));
          },
          reset: function () {
            (e = !1), (i = null), o.set(-1, 0, 0, 0);
          }
        };
      })(),
      a = new (function () {
        var e = !1,
          i = null,
          n = null,
          r = null;
        return {
          setTest: function (t) {
            (t ? z : G)(l.DEPTH_TEST);
          },
          setMask: function (t) {
            i === t || e || (l.depthMask(t), (i = t));
          },
          setFunc: function (t) {
            if (n !== t) {
              if (t)
                switch (t) {
                  case nt:
                    l.depthFunc(l.NEVER);
                    break;
                  case rt:
                    l.depthFunc(l.ALWAYS);
                    break;
                  case at:
                    l.depthFunc(l.LESS);
                    break;
                  case ot:
                    l.depthFunc(l.LEQUAL);
                    break;
                  case st:
                    l.depthFunc(l.EQUAL);
                    break;
                  case ct:
                    l.depthFunc(l.GEQUAL);
                    break;
                  case ht:
                    l.depthFunc(l.GREATER);
                    break;
                  case lt:
                    l.depthFunc(l.NOTEQUAL);
                    break;
                  default:
                    l.depthFunc(l.LEQUAL);
                }
              else l.depthFunc(l.LEQUAL);
              n = t;
            }
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (t) {
            r !== t && (l.clearDepth(t), (r = t));
          },
          reset: function () {
            (e = !1), (r = n = i = null);
          }
        };
      })(),
      e = new (function () {
        var e = !1,
          i = null,
          n = null,
          r = null,
          a = null,
          o = null,
          s = null,
          c = null,
          h = null;
        return {
          setTest: function (t) {
            (t ? z : G)(l.STENCIL_TEST);
          },
          setMask: function (t) {
            i === t || e || (l.stencilMask(t), (i = t));
          },
          setFunc: function (t, e, i) {
            (n === t && r === e && a === i) ||
              (l.stencilFunc(t, e, i), (n = t), (r = e), (a = i));
          },
          setOp: function (t, e, i) {
            (o === t && s === e && c === i) ||
              (l.stencilOp(t, e, i), (o = t), (s = e), (c = i));
          },
          setLocked: function (t) {
            e = t;
          },
          setClear: function (t) {
            h !== t && (l.clearStencil(t), (h = t));
          },
          reset: function () {
            (e = !1), (h = c = s = o = a = r = n = i = null);
          }
        };
      })(),
      t = l.getParameter(l.MAX_VERTEX_ATTRIBS),
      o = new Uint8Array(t),
      s = new Uint8Array(t),
      h = new Uint8Array(t),
      u = {},
      p = null,
      d = null,
      f = null,
      m = null,
      g = null,
      v = null,
      y = null,
      x = null,
      b = null,
      _ = null,
      w = !1,
      M = null,
      E = null,
      T = null,
      S = null,
      A = null,
      L = l.getParameter(l.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
      R = !1,
      P = 0,
      C = l.getParameter(l.VERSION);
    -1 !== C.indexOf('WebGL')
      ? ((P = parseFloat(/^WebGL\ ([0-9])/.exec(C)[1])), (R = 1 <= P))
      : -1 !== C.indexOf('OpenGL ES') &&
        ((P = parseFloat(/^OpenGL\ ES\ ([0-9])/.exec(C)[1])), (R = 2 <= P));
    var O = null,
      I = {},
      N = new Ti(),
      D = new Ti();
    function U(t, e, i) {
      var n = new Uint8Array(4),
        r = l.createTexture();
      l.bindTexture(t, r),
        l.texParameteri(t, l.TEXTURE_MIN_FILTER, l.NEAREST),
        l.texParameteri(t, l.TEXTURE_MAG_FILTER, l.NEAREST);
      for (var a = 0; a < i; a++)
        l.texImage2D(e + a, 0, l.RGBA, 1, 1, 0, l.RGBA, l.UNSIGNED_BYTE, n);
      return r;
    }
    var B = {};
    function F(t, e) {
      (o[t] = 1),
        0 === s[t] && (l.enableVertexAttribArray(t), (s[t] = 1)),
        h[t] !== e &&
          ((n.isWebGL2 ? l : i.get('ANGLE_instanced_arrays'))[
            n.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE'
          ](t, e),
          (h[t] = e));
    }
    function z(t) {
      !0 !== u[t] && (l.enable(t), (u[t] = !0));
    }
    function G(t) {
      !1 !== u[t] && (l.disable(t), (u[t] = !1));
    }
    function H(t, e, i, n, r, a, o, s) {
      if (t !== Z) {
        if ((f || (z(l.BLEND), (f = !0)), t === et))
          (r = r || e),
            (a = a || i),
            (o = o || n),
            (e === g && r === x) ||
              (l.blendEquationSeparate(c.convert(e), c.convert(r)), (g = e), (x = r)),
            (i === v && n === y && a === b && o === _) ||
              (l.blendFuncSeparate(
                c.convert(i),
                c.convert(n),
                c.convert(a),
                c.convert(o)
              ),
              (v = i),
              (y = n),
              (b = a),
              (_ = o)),
            (m = t),
            (w = null);
        else if (t !== m || s !== w) {
          if (((g === it && x === it) || (l.blendEquation(l.FUNC_ADD), (x = g = it)), s))
            switch (t) {
              case Q:
                l.blendFuncSeparate(
                  l.ONE,
                  l.ONE_MINUS_SRC_ALPHA,
                  l.ONE,
                  l.ONE_MINUS_SRC_ALPHA
                );
                break;
              case K:
                l.blendFunc(l.ONE, l.ONE);
                break;
              case $:
                l.blendFuncSeparate(
                  l.ZERO,
                  l.ZERO,
                  l.ONE_MINUS_SRC_COLOR,
                  l.ONE_MINUS_SRC_ALPHA
                );
                break;
              case tt:
                l.blendFuncSeparate(l.ZERO, l.SRC_COLOR, l.ZERO, l.SRC_ALPHA);
                break;
              default:
                console.error('THREE.WebGLState: Invalid blending: ', t);
            }
          else
            switch (t) {
              case Q:
                l.blendFuncSeparate(
                  l.SRC_ALPHA,
                  l.ONE_MINUS_SRC_ALPHA,
                  l.ONE,
                  l.ONE_MINUS_SRC_ALPHA
                );
                break;
              case K:
                l.blendFunc(l.SRC_ALPHA, l.ONE);
                break;
              case $:
                l.blendFunc(l.ZERO, l.ONE_MINUS_SRC_COLOR);
                break;
              case tt:
                l.blendFunc(l.ZERO, l.SRC_COLOR);
                break;
              default:
                console.error('THREE.WebGLState: Invalid blending: ', t);
            }
          (_ = b = y = v = null), (m = t), (w = s);
        }
      } else f && (G(l.BLEND), (f = !1));
    }
    function V(t) {
      M !== t && (t ? l.frontFace(l.CW) : l.frontFace(l.CCW), (M = t));
    }
    function k(t) {
      t !== X
        ? (z(l.CULL_FACE),
          t !== E &&
            (t === q
              ? l.cullFace(l.BACK)
              : t === Y
              ? l.cullFace(l.FRONT)
              : l.cullFace(l.FRONT_AND_BACK)))
        : G(l.CULL_FACE),
        (E = t);
    }
    function j(t, e, i) {
      t
        ? (z(l.POLYGON_OFFSET_FILL),
          (S === e && A === i) || (l.polygonOffset(e, i), (S = e), (A = i)))
        : G(l.POLYGON_OFFSET_FILL);
    }
    function W(t) {
      void 0 === t && (t = l.TEXTURE0 + L - 1), O !== t && (l.activeTexture(t), (O = t));
    }
    return (
      (B[l.TEXTURE_2D] = U(l.TEXTURE_2D, l.TEXTURE_2D, 1)),
      (B[l.TEXTURE_CUBE_MAP] = U(l.TEXTURE_CUBE_MAP, l.TEXTURE_CUBE_MAP_POSITIVE_X, 6)),
      r.setClear(0, 0, 0, 1),
      a.setClear(1),
      e.setClear(0),
      z(l.DEPTH_TEST),
      a.setFunc(ot),
      V(!1),
      k(q),
      z(l.CULL_FACE),
      H(Z),
      {
        buffers: { color: r, depth: a, stencil: e },
        initAttributes: function () {
          for (var t = 0, e = o.length; t < e; t++) o[t] = 0;
        },
        enableAttribute: function (t) {
          F(t, 0);
        },
        enableAttributeAndDivisor: F,
        disableUnusedAttributes: function () {
          for (var t = 0, e = s.length; t !== e; ++t)
            s[t] !== o[t] && (l.disableVertexAttribArray(t), (s[t] = 0));
        },
        enable: z,
        disable: G,
        getCompressedTextureFormats: function () {
          if (
            null === p &&
            ((p = []),
            i.get('WEBGL_compressed_texture_pvrtc') ||
              i.get('WEBGL_compressed_texture_s3tc') ||
              i.get('WEBGL_compressed_texture_etc1') ||
              i.get('WEBGL_compressed_texture_astc'))
          )
            for (
              var t = l.getParameter(l.COMPRESSED_TEXTURE_FORMATS), e = 0;
              e < t.length;
              e++
            )
              p.push(t[e]);
          return p;
        },
        useProgram: function (t) {
          return d !== t && (l.useProgram(t), (d = t), !0);
        },
        setBlending: H,
        setMaterial: function (t, e) {
          (t.side === J ? G : z)(l.CULL_FACE);
          var i = t.side === wt;
          e && (i = !i),
            V(i),
            t.blending === Q && !1 === t.transparent
              ? H(Z)
              : H(
                  t.blending,
                  t.blendEquation,
                  t.blendSrc,
                  t.blendDst,
                  t.blendEquationAlpha,
                  t.blendSrcAlpha,
                  t.blendDstAlpha,
                  t.premultipliedAlpha
                ),
            a.setFunc(t.depthFunc),
            a.setTest(t.depthTest),
            a.setMask(t.depthWrite),
            r.setMask(t.colorWrite),
            j(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits);
        },
        setFlipSided: V,
        setCullFace: k,
        setLineWidth: function (t) {
          t !== T && (R && l.lineWidth(t), (T = t));
        },
        setPolygonOffset: j,
        setScissorTest: function (t) {
          (t ? z : G)(l.SCISSOR_TEST);
        },
        activeTexture: W,
        bindTexture: function (t, e) {
          null === O && W();
          var i = I[O];
          void 0 === i && ((i = { type: void 0, texture: void 0 }), (I[O] = i)),
            (i.type === t && i.texture === e) ||
              (l.bindTexture(t, e || B[t]), (i.type = t), (i.texture = e));
        },
        compressedTexImage2D: function () {
          try {
            l.compressedTexImage2D.apply(l, arguments);
          } catch (t) {
            console.error('THREE.WebGLState:', t);
          }
        },
        texImage2D: function () {
          try {
            l.texImage2D.apply(l, arguments);
          } catch (t) {
            console.error('THREE.WebGLState:', t);
          }
        },
        texImage3D: function () {
          try {
            l.texImage3D.apply(l, arguments);
          } catch (t) {
            console.error('THREE.WebGLState:', t);
          }
        },
        scissor: function (t) {
          !1 === N.equals(t) && (l.scissor(t.x, t.y, t.z, t.w), N.copy(t));
        },
        viewport: function (t) {
          !1 === D.equals(t) && (l.viewport(t.x, t.y, t.z, t.w), D.copy(t));
        },
        reset: function () {
          for (var t = 0; t < s.length; t++)
            1 === s[t] && (l.disableVertexAttribArray(t), (s[t] = 0));
          (u = {}),
            (I = {}),
            (E = M = m = d = O = p = null),
            r.reset(),
            a.reset(),
            e.reset();
        }
      }
    );
  }
  function es(g, r, v, y, x, b, _) {
    var m,
      s = {};
    function w(t, e) {
      if (t.width > e || t.height > e) {
        if ('data' in t)
          return void console.warn(
            'THREE.WebGLRenderer: image in DataTexture is too big (' +
              t.width +
              'x' +
              t.height +
              ').'
          );
        var i = e / Math.max(t.width, t.height),
          n = document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas');
        return (
          (n.width = Math.floor(t.width * i)),
          (n.height = Math.floor(t.height * i)),
          n
            .getContext('2d')
            .drawImage(t, 0, 0, t.width, t.height, 0, 0, n.width, n.height),
          console.warn(
            'THREE.WebGLRenderer: image is too big (' +
              t.width +
              'x' +
              t.height +
              '). Resized to ' +
              n.width +
              'x' +
              n.height
          ),
          n
        );
      }
      return t;
    }
    function M(t) {
      return Ge.isPowerOfTwo(t.width) && Ge.isPowerOfTwo(t.height);
    }
    function E(t, e) {
      return t.generateMipmaps && e && t.minFilter !== At && t.minFilter !== Pt;
    }
    function T(t, e, i, n) {
      g.generateMipmap(t),
        (y.get(e).__maxMipLevel = Math.log(Math.max(i, n)) * Math.LOG2E);
    }
    function S(t, e) {
      if (!x.isWebGL2) return t;
      if (t === g.RED) {
        if (e === g.FLOAT) return g.R32F;
        if (e === g.HALF_FLOAT) return g.R16F;
        if (e === g.UNSIGNED_BYTE) return g.R8;
      }
      if (t === g.RGB) {
        if (e === g.FLOAT) return g.RGB32F;
        if (e === g.HALF_FLOAT) return g.RGB16F;
        if (e === g.UNSIGNED_BYTE) return g.RGB8;
      }
      if (t === g.RGBA) {
        if (e === g.FLOAT) return g.RGBA32F;
        if (e === g.HALF_FLOAT) return g.RGBA16F;
        if (e === g.UNSIGNED_BYTE) return g.RGBA8;
      }
      return t;
    }
    function a(t) {
      return t === At || t === Lt || t === Rt ? g.NEAREST : g.LINEAR;
    }
    function A(t) {
      var e = t.target;
      e.removeEventListener('dispose', A),
        (function (t) {
          var e = y.get(t);
          if (t.image && e.__image__webglTextureCube)
            g.deleteTexture(e.__image__webglTextureCube);
          else {
            if (void 0 === e.__webglInit) return;
            g.deleteTexture(e.__webglTexture);
          }
          y.remove(t);
        })(e),
        e.isVideoTexture && delete s[e.id],
        _.memory.textures--;
    }
    function o(t) {
      var e = t.target;
      e.removeEventListener('dispose', o),
        (function (t) {
          var e = y.get(t),
            i = y.get(t.texture);
          if (!t) return;
          void 0 !== i.__webglTexture && g.deleteTexture(i.__webglTexture);
          t.depthTexture && t.depthTexture.dispose();
          if (t.isWebGLRenderTargetCube)
            for (var n = 0; n < 6; n++)
              g.deleteFramebuffer(e.__webglFramebuffer[n]),
                e.__webglDepthbuffer && g.deleteRenderbuffer(e.__webglDepthbuffer[n]);
          else
            g.deleteFramebuffer(e.__webglFramebuffer),
              e.__webglDepthbuffer && g.deleteRenderbuffer(e.__webglDepthbuffer);
          y.remove(t.texture), y.remove(t);
        })(e),
        _.memory.textures--;
    }
    function c(t, e) {
      var i,
        n,
        r,
        a = y.get(t);
      if (
        (t.isVideoTexture &&
          ((n = (i = t).id),
          (r = _.render.frame),
          s[n] !== r && ((s[n] = r), i.update())),
        0 < t.version && a.__version !== t.version)
      ) {
        var o = t.image;
        if (void 0 === o)
          console.warn(
            'THREE.WebGLRenderer: Texture marked for update but image is undefined'
          );
        else {
          if (!1 !== o.complete) return void h(a, t, e);
          console.warn(
            'THREE.WebGLRenderer: Texture marked for update but image is incomplete'
          );
        }
      }
      v.activeTexture(g.TEXTURE0 + e), v.bindTexture(g.TEXTURE_2D, a.__webglTexture);
    }
    function L(t, e, i) {
      var n;
      if (
        (i
          ? (g.texParameteri(t, g.TEXTURE_WRAP_S, b.convert(e.wrapS)),
            g.texParameteri(t, g.TEXTURE_WRAP_T, b.convert(e.wrapT)),
            g.texParameteri(t, g.TEXTURE_MAG_FILTER, b.convert(e.magFilter)),
            g.texParameteri(t, g.TEXTURE_MIN_FILTER, b.convert(e.minFilter)))
          : (g.texParameteri(t, g.TEXTURE_WRAP_S, g.CLAMP_TO_EDGE),
            g.texParameteri(t, g.TEXTURE_WRAP_T, g.CLAMP_TO_EDGE),
            (e.wrapS === Tt && e.wrapT === Tt) ||
              console.warn(
                'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.'
              ),
            g.texParameteri(t, g.TEXTURE_MAG_FILTER, a(e.magFilter)),
            g.texParameteri(t, g.TEXTURE_MIN_FILTER, a(e.minFilter)),
            e.minFilter !== At &&
              e.minFilter !== Pt &&
              console.warn(
                'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.'
              )),
        (n = r.get('EXT_texture_filter_anisotropic')))
      ) {
        if (e.type === zt && null === r.get('OES_texture_float_linear')) return;
        if (
          e.type === Gt &&
          null === (x.isWebGL2 || r.get('OES_texture_half_float_linear'))
        )
          return;
        (1 < e.anisotropy || y.get(e).__currentAnisotropy) &&
          (g.texParameterf(
            t,
            n.TEXTURE_MAX_ANISOTROPY_EXT,
            Math.min(e.anisotropy, x.getMaxAnisotropy())
          ),
          (y.get(e).__currentAnisotropy = e.anisotropy));
      }
    }
    function h(t, e, i) {
      var n;
      (n = e.isDataTexture3D ? g.TEXTURE_3D : g.TEXTURE_2D),
        void 0 === t.__webglInit &&
          ((t.__webglInit = !0),
          e.addEventListener('dispose', A),
          (t.__webglTexture = g.createTexture()),
          _.memory.textures++),
        v.activeTexture(g.TEXTURE0 + i),
        v.bindTexture(n, t.__webglTexture),
        g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, e.flipY),
        g.pixelStorei(g.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha),
        g.pixelStorei(g.UNPACK_ALIGNMENT, e.unpackAlignment);
      var r,
        a,
        o = w(e.image, x.maxTextureSize);
      (a = e),
        x.isWebGL2 ||
          (a.wrapS === Tt &&
            a.wrapT === Tt &&
            (a.minFilter === At || a.minFilter === Pt)) ||
          !1 !== M(o) ||
          (o =
            (r = o) instanceof HTMLImageElement ||
            r instanceof HTMLCanvasElement ||
            r instanceof ImageBitmap
              ? (void 0 === m &&
                  (m = document.createElementNS(
                    'http://www.w3.org/1999/xhtml',
                    'canvas'
                  )),
                (m.width = Ge.floorPowerOfTwo(r.width)),
                (m.height = Ge.floorPowerOfTwo(r.height)),
                m.getContext('2d').drawImage(r, 0, 0, m.width, m.height),
                console.warn(
                  'THREE.WebGLRenderer: image is not power of two (' +
                    r.width +
                    'x' +
                    r.height +
                    '). Resized to ' +
                    m.width +
                    'x' +
                    m.height
                ),
                m)
              : r);
      var s = M(o),
        c = b.convert(e.format),
        h = b.convert(e.type),
        l = S(c, h);
      L(n, e, s);
      var u,
        p = e.mipmaps;
      if (e.isDepthTexture) {
        if (((l = g.DEPTH_COMPONENT), e.type === zt)) {
          if (!x.isWebGL2)
            throw new Error('Float Depth Texture only supported in WebGL2.0');
          l = g.DEPTH_COMPONENT32F;
        } else x.isWebGL2 && (l = g.DEPTH_COMPONENT16);
        e.format === Qt &&
          l === g.DEPTH_COMPONENT &&
          e.type !== Ut &&
          e.type !== Ft &&
          (console.warn(
            'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.'
          ),
          (e.type = Ut),
          (h = b.convert(e.type))),
          e.format === Kt &&
            ((l = g.DEPTH_STENCIL),
            e.type !== jt &&
              (console.warn(
                'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.'
              ),
              (e.type = jt),
              (h = b.convert(e.type)))),
          v.texImage2D(g.TEXTURE_2D, 0, l, o.width, o.height, 0, c, h, null);
      } else if (e.isDataTexture)
        if (0 < p.length && s) {
          for (var d = 0, f = p.length; d < f; d++)
            (u = p[d]),
              v.texImage2D(g.TEXTURE_2D, d, l, u.width, u.height, 0, c, h, u.data);
          (e.generateMipmaps = !1), (t.__maxMipLevel = p.length - 1);
        } else
          v.texImage2D(g.TEXTURE_2D, 0, l, o.width, o.height, 0, c, h, o.data),
            (t.__maxMipLevel = 0);
      else if (e.isCompressedTexture) {
        for (d = 0, f = p.length; d < f; d++)
          (u = p[d]),
            e.format !== qt && e.format !== Xt
              ? -1 < v.getCompressedTextureFormats().indexOf(c)
                ? v.compressedTexImage2D(g.TEXTURE_2D, d, l, u.width, u.height, 0, u.data)
                : console.warn(
                    'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()'
                  )
              : v.texImage2D(g.TEXTURE_2D, d, l, u.width, u.height, 0, c, h, u.data);
        t.__maxMipLevel = p.length - 1;
      } else if (e.isDataTexture3D)
        v.texImage3D(g.TEXTURE_3D, 0, l, o.width, o.height, o.depth, 0, c, h, o.data),
          (t.__maxMipLevel = 0);
      else if (0 < p.length && s) {
        for (d = 0, f = p.length; d < f; d++)
          (u = p[d]), v.texImage2D(g.TEXTURE_2D, d, l, c, h, u);
        (e.generateMipmaps = !1), (t.__maxMipLevel = p.length - 1);
      } else v.texImage2D(g.TEXTURE_2D, 0, l, c, h, o), (t.__maxMipLevel = 0);
      E(e, s) && T(g.TEXTURE_2D, e, o.width, o.height),
        (t.__version = e.version),
        e.onUpdate && e.onUpdate(e);
    }
    function l(t, e, i, n) {
      var r = b.convert(e.texture.format),
        a = b.convert(e.texture.type),
        o = S(r, a);
      v.texImage2D(n, 0, o, e.width, e.height, 0, r, a, null),
        g.bindFramebuffer(g.FRAMEBUFFER, t),
        g.framebufferTexture2D(g.FRAMEBUFFER, i, n, y.get(e.texture).__webglTexture, 0),
        g.bindFramebuffer(g.FRAMEBUFFER, null);
    }
    function u(t, e) {
      g.bindRenderbuffer(g.RENDERBUFFER, t),
        e.depthBuffer && !e.stencilBuffer
          ? (g.renderbufferStorage(
              g.RENDERBUFFER,
              g.DEPTH_COMPONENT16,
              e.width,
              e.height
            ),
            g.framebufferRenderbuffer(
              g.FRAMEBUFFER,
              g.DEPTH_ATTACHMENT,
              g.RENDERBUFFER,
              t
            ))
          : e.depthBuffer && e.stencilBuffer
          ? (g.renderbufferStorage(g.RENDERBUFFER, g.DEPTH_STENCIL, e.width, e.height),
            g.framebufferRenderbuffer(
              g.FRAMEBUFFER,
              g.DEPTH_STENCIL_ATTACHMENT,
              g.RENDERBUFFER,
              t
            ))
          : g.renderbufferStorage(g.RENDERBUFFER, g.RGBA4, e.width, e.height),
        g.bindRenderbuffer(g.RENDERBUFFER, null);
    }
    function p(t) {
      var e = y.get(t),
        i = !0 === t.isWebGLRenderTargetCube;
      if (t.depthTexture) {
        if (i)
          throw new Error('target.depthTexture not supported in Cube render targets');
        !(function (t, e) {
          if (e && e.isWebGLRenderTargetCube)
            throw new Error('Depth Texture with cube render targets is not supported');
          if (
            (g.bindFramebuffer(g.FRAMEBUFFER, t),
            !e.depthTexture || !e.depthTexture.isDepthTexture)
          )
            throw new Error(
              'renderTarget.depthTexture must be an instance of THREE.DepthTexture'
            );
          (y.get(e.depthTexture).__webglTexture &&
            e.depthTexture.image.width === e.width &&
            e.depthTexture.image.height === e.height) ||
            ((e.depthTexture.image.width = e.width),
            (e.depthTexture.image.height = e.height),
            (e.depthTexture.needsUpdate = !0)),
            c(e.depthTexture, 0);
          var i = y.get(e.depthTexture).__webglTexture;
          if (e.depthTexture.format === Qt)
            g.framebufferTexture2D(g.FRAMEBUFFER, g.DEPTH_ATTACHMENT, g.TEXTURE_2D, i, 0);
          else {
            if (e.depthTexture.format !== Kt)
              throw new Error('Unknown depthTexture format');
            g.framebufferTexture2D(
              g.FRAMEBUFFER,
              g.DEPTH_STENCIL_ATTACHMENT,
              g.TEXTURE_2D,
              i,
              0
            );
          }
        })(e.__webglFramebuffer, t);
      } else if (i) {
        e.__webglDepthbuffer = [];
        for (var n = 0; n < 6; n++)
          g.bindFramebuffer(g.FRAMEBUFFER, e.__webglFramebuffer[n]),
            (e.__webglDepthbuffer[n] = g.createRenderbuffer()),
            u(e.__webglDepthbuffer[n], t);
      } else
        g.bindFramebuffer(g.FRAMEBUFFER, e.__webglFramebuffer),
          (e.__webglDepthbuffer = g.createRenderbuffer()),
          u(e.__webglDepthbuffer, t);
      g.bindFramebuffer(g.FRAMEBUFFER, null);
    }
    (this.setTexture2D = c),
      (this.setTexture3D = function (t, e) {
        var i = y.get(t);
        0 < t.version && i.__version !== t.version
          ? h(i, t, e)
          : (v.activeTexture(g.TEXTURE0 + e),
            v.bindTexture(g.TEXTURE_3D, i.__webglTexture));
      }),
      (this.setTextureCube = function (t, e) {
        var i = y.get(t);
        if (6 === t.image.length)
          if (0 < t.version && i.__version !== t.version) {
            i.__image__webglTextureCube ||
              (t.addEventListener('dispose', A),
              (i.__image__webglTextureCube = g.createTexture()),
              _.memory.textures++),
              v.activeTexture(g.TEXTURE0 + e),
              v.bindTexture(g.TEXTURE_CUBE_MAP, i.__image__webglTextureCube),
              g.pixelStorei(g.UNPACK_FLIP_Y_WEBGL, t.flipY);
            for (
              var n = t && t.isCompressedTexture,
                r = t.image[0] && t.image[0].isDataTexture,
                a = [],
                o = 0;
              o < 6;
              o++
            )
              a[o] =
                n || r
                  ? r
                    ? t.image[o].image
                    : t.image[o]
                  : w(t.image[o], x.maxCubemapSize);
            var s = a[0],
              c = M(s),
              h = b.convert(t.format),
              l = b.convert(t.type),
              u = S(h, l);
            L(g.TEXTURE_CUBE_MAP, t, c);
            for (o = 0; o < 6; o++)
              if (n)
                for (var p, d = a[o].mipmaps, f = 0, m = d.length; f < m; f++)
                  (p = d[f]),
                    t.format !== qt && t.format !== Xt
                      ? -1 < v.getCompressedTextureFormats().indexOf(h)
                        ? v.compressedTexImage2D(
                            g.TEXTURE_CUBE_MAP_POSITIVE_X + o,
                            f,
                            u,
                            p.width,
                            p.height,
                            0,
                            p.data
                          )
                        : console.warn(
                            'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()'
                          )
                      : v.texImage2D(
                          g.TEXTURE_CUBE_MAP_POSITIVE_X + o,
                          f,
                          u,
                          p.width,
                          p.height,
                          0,
                          h,
                          l,
                          p.data
                        );
              else
                r
                  ? v.texImage2D(
                      g.TEXTURE_CUBE_MAP_POSITIVE_X + o,
                      0,
                      u,
                      a[o].width,
                      a[o].height,
                      0,
                      h,
                      l,
                      a[o].data
                    )
                  : v.texImage2D(g.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, u, h, l, a[o]);
            (i.__maxMipLevel = n ? d.length - 1 : 0),
              E(t, c) && T(g.TEXTURE_CUBE_MAP, t, s.width, s.height),
              (i.__version = t.version),
              t.onUpdate && t.onUpdate(t);
          } else
            v.activeTexture(g.TEXTURE0 + e),
              v.bindTexture(g.TEXTURE_CUBE_MAP, i.__image__webglTextureCube);
      }),
      (this.setTextureCubeDynamic = function (t, e) {
        v.activeTexture(g.TEXTURE0 + e),
          v.bindTexture(g.TEXTURE_CUBE_MAP, y.get(t).__webglTexture);
      }),
      (this.setupRenderTarget = function (t) {
        var e = y.get(t),
          i = y.get(t.texture);
        t.addEventListener('dispose', o),
          (i.__webglTexture = g.createTexture()),
          _.memory.textures++;
        var n = !0 === t.isWebGLRenderTargetCube,
          r = M(t);
        if (n) {
          e.__webglFramebuffer = [];
          for (var a = 0; a < 6; a++) e.__webglFramebuffer[a] = g.createFramebuffer();
        } else e.__webglFramebuffer = g.createFramebuffer();
        if (n) {
          v.bindTexture(g.TEXTURE_CUBE_MAP, i.__webglTexture),
            L(g.TEXTURE_CUBE_MAP, t.texture, r);
          for (a = 0; a < 6; a++)
            l(
              e.__webglFramebuffer[a],
              t,
              g.COLOR_ATTACHMENT0,
              g.TEXTURE_CUBE_MAP_POSITIVE_X + a
            );
          E(t.texture, r) && T(g.TEXTURE_CUBE_MAP, t.texture, t.width, t.height),
            v.bindTexture(g.TEXTURE_CUBE_MAP, null);
        } else
          v.bindTexture(g.TEXTURE_2D, i.__webglTexture),
            L(g.TEXTURE_2D, t.texture, r),
            l(e.__webglFramebuffer, t, g.COLOR_ATTACHMENT0, g.TEXTURE_2D),
            E(t.texture, r) && T(g.TEXTURE_2D, t.texture, t.width, t.height),
            v.bindTexture(g.TEXTURE_2D, null);
        t.depthBuffer && p(t);
      }),
      (this.updateRenderTargetMipmap = function (t) {
        var e = t.texture;
        if (E(e, M(t))) {
          var i = t.isWebGLRenderTargetCube ? g.TEXTURE_CUBE_MAP : g.TEXTURE_2D,
            n = y.get(e).__webglTexture;
          v.bindTexture(i, n), T(i, e, t.width, t.height), v.bindTexture(i, null);
        }
      });
  }
  function is(i, n, r) {
    return {
      convert: function (t) {
        var e;
        if (t === Et) return i.REPEAT;
        if (t === Tt) return i.CLAMP_TO_EDGE;
        if (t === St) return i.MIRRORED_REPEAT;
        if (t === At) return i.NEAREST;
        if (t === Lt) return i.NEAREST_MIPMAP_NEAREST;
        if (t === Rt) return i.NEAREST_MIPMAP_LINEAR;
        if (t === Pt) return i.LINEAR;
        if (t === Ct) return i.LINEAR_MIPMAP_NEAREST;
        if (t === Ot) return i.LINEAR_MIPMAP_LINEAR;
        if (t === It) return i.UNSIGNED_BYTE;
        if (t === Ht) return i.UNSIGNED_SHORT_4_4_4_4;
        if (t === Vt) return i.UNSIGNED_SHORT_5_5_5_1;
        if (t === kt) return i.UNSIGNED_SHORT_5_6_5;
        if (t === Nt) return i.BYTE;
        if (t === Dt) return i.SHORT;
        if (t === Ut) return i.UNSIGNED_SHORT;
        if (t === Bt) return i.INT;
        if (t === Ft) return i.UNSIGNED_INT;
        if (t === zt) return i.FLOAT;
        if (t === Gt) {
          if (r.isWebGL2) return i.HALF_FLOAT;
          if (null !== (e = n.get('OES_texture_half_float'))) return e.HALF_FLOAT_OES;
        }
        if (t === Wt) return i.ALPHA;
        if (t === Xt) return i.RGB;
        if (t === qt) return i.RGBA;
        if (t === Yt) return i.LUMINANCE;
        if (t === Jt) return i.LUMINANCE_ALPHA;
        if (t === Qt) return i.DEPTH_COMPONENT;
        if (t === Kt) return i.DEPTH_STENCIL;
        if (t === $t) return i.RED;
        if (t === it) return i.FUNC_ADD;
        if (t === T) return i.FUNC_SUBTRACT;
        if (t === S) return i.FUNC_REVERSE_SUBTRACT;
        if (t === R) return i.ZERO;
        if (t === P) return i.ONE;
        if (t === C) return i.SRC_COLOR;
        if (t === O) return i.ONE_MINUS_SRC_COLOR;
        if (t === I) return i.SRC_ALPHA;
        if (t === N) return i.ONE_MINUS_SRC_ALPHA;
        if (t === U) return i.DST_ALPHA;
        if (t === B) return i.ONE_MINUS_DST_ALPHA;
        if (t === F) return i.DST_COLOR;
        if (t === z) return i.ONE_MINUS_DST_COLOR;
        if (t === V) return i.SRC_ALPHA_SATURATE;
        if (
          (t === te || t === ee || t === ie || t === ne) &&
          null !== (e = n.get('WEBGL_compressed_texture_s3tc'))
        ) {
          if (t === te) return e.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (t === ee) return e.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (t === ie) return e.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (t === ne) return e.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
        if (
          (t === re || t === ae || t === oe || t === se) &&
          null !== (e = n.get('WEBGL_compressed_texture_pvrtc'))
        ) {
          if (t === re) return e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
          if (t === ae) return e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
          if (t === oe) return e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
          if (t === se) return e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
        }
        if (t === ce && null !== (e = n.get('WEBGL_compressed_texture_etc1')))
          return e.COMPRESSED_RGB_ETC1_WEBGL;
        if (
          (t === he ||
            t === le ||
            t === ue ||
            t === pe ||
            t === de ||
            t === fe ||
            t === me ||
            t === ge ||
            t === ve ||
            t === ye ||
            t === xe ||
            t === be ||
            t === _e ||
            t === we) &&
          null !== (e = n.get('WEBGL_compressed_texture_astc'))
        )
          return t;
        if (t === A || t === L) {
          if (r.isWebGL2) {
            if (t === A) return i.MIN;
            if (t === L) return i.MAX;
          }
          if (null !== (e = n.get('EXT_blend_minmax'))) {
            if (t === A) return e.MIN_EXT;
            if (t === L) return e.MAX_EXT;
          }
        }
        if (t === jt) {
          if (r.isWebGL2) return i.UNSIGNED_INT_24_8;
          if (null !== (e = n.get('WEBGL_depth_texture')))
            return e.UNSIGNED_INT_24_8_WEBGL;
        }
        return 0;
      }
    };
  }
  function ns() {
    bn.call(this), (this.type = 'Group');
  }
  function rs() {
    bn.call(this),
      (this.type = 'Camera'),
      (this.matrixWorldInverse = new Ve()),
      (this.projectionMatrix = new Ve()),
      (this.projectionMatrixInverse = new Ve());
  }
  function as(t, e, i, n) {
    rs.call(this),
      (this.type = 'PerspectiveCamera'),
      (this.fov = void 0 !== t ? t : 50),
      (this.zoom = 1),
      (this.near = void 0 !== i ? i : 0.1),
      (this.far = void 0 !== n ? n : 2e3),
      (this.focus = 10),
      (this.aspect = void 0 !== e ? e : 1),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  function os(t) {
    as.call(this), (this.cameras = t || []);
  }
  function ss(n) {
    var r = this,
      c = null,
      h = null,
      l = null,
      u = [],
      p = new Ve(),
      d = new Ve(),
      f = 'stage';
    'undefined' != typeof window &&
      'VRFrameData' in window &&
      ((h = new window.VRFrameData()),
      window.addEventListener('vrdisplaypresentchange', t, !1));
    var m = new Ve(),
      g = new ke(),
      v = new je(),
      y = new as();
    (y.bounds = new Ti(0, 0, 0.5, 1)), y.layers.enable(1);
    var x = new as();
    (x.bounds = new Ti(0.5, 0, 0.5, 1)), x.layers.enable(2);
    var a,
      o,
      b = new os([y, x]);
    function s() {
      return null !== c && !0 === c.isPresenting;
    }
    function t() {
      if (s()) {
        var t = c.getEyeParameters('left'),
          e = t.renderWidth,
          i = t.renderHeight;
        (o = n.getPixelRatio()),
          (a = n.getSize()),
          n.setDrawingBufferSize(2 * e, i, 1),
          M.start();
      } else r.enabled && n.setDrawingBufferSize(a.width, a.height, o), M.stop();
    }
    b.layers.enable(1), b.layers.enable(2);
    var _ = [];
    function w(t) {
      for (
        var e = navigator.getGamepads && navigator.getGamepads(),
          i = 0,
          n = 0,
          r = e.length;
        i < r;
        i++
      ) {
        var a = e[i];
        if (
          a &&
          ('Daydream Controller' === a.id ||
            'Gear VR Controller' === a.id ||
            'Oculus Go Controller' === a.id ||
            'OpenVR Gamepad' === a.id ||
            a.id.startsWith('Oculus Touch') ||
            a.id.startsWith('Spatial Controller'))
        ) {
          if (n === t) return a;
          n++;
        }
      }
    }
    (this.enabled = !1),
      (this.getController = function (t) {
        var e = u[t];
        return (
          void 0 === e &&
            (((e = new ns()).matrixAutoUpdate = !1), (e.visible = !1), (u[t] = e)),
          e
        );
      }),
      (this.getDevice = function () {
        return c;
      }),
      (this.setDevice = function (t) {
        void 0 !== t && (c = t), M.setContext(t);
      }),
      (this.setFrameOfReferenceType = function (t) {
        f = t;
      }),
      (this.setPoseTarget = function (t) {
        void 0 !== t && (l = t);
      }),
      (this.getCamera = function (t) {
        var e = 'stage' === f ? 1.6 : 0;
        if (null === c) return t.position.set(0, e, 0), t;
        if (
          ((c.depthNear = t.near), (c.depthFar = t.far), c.getFrameData(h), 'stage' === f)
        ) {
          var i = c.stageParameters;
          i ? p.fromArray(i.sittingToStandingTransform) : p.makeTranslation(0, e, 0);
        }
        var n = h.pose,
          r = null !== l ? l : t;
        if (
          (r.matrix.copy(p),
          r.matrix.decompose(r.position, r.quaternion, r.scale),
          null !== n.orientation &&
            (g.fromArray(n.orientation), r.quaternion.multiply(g)),
          null !== n.position &&
            (g.setFromRotationMatrix(p),
            v.fromArray(n.position),
            v.applyQuaternion(g),
            r.position.add(v)),
          r.updateMatrixWorld(),
          !1 === c.isPresenting)
        )
          return t;
        (y.near = t.near),
          (x.near = t.near),
          (y.far = t.far),
          (x.far = t.far),
          b.matrixWorld.copy(t.matrixWorld),
          b.matrixWorldInverse.copy(t.matrixWorldInverse),
          y.matrixWorldInverse.fromArray(h.leftViewMatrix),
          x.matrixWorldInverse.fromArray(h.rightViewMatrix),
          d.getInverse(p),
          'stage' === f &&
            (y.matrixWorldInverse.multiply(d), x.matrixWorldInverse.multiply(d));
        var a = r.parent;
        null !== a &&
          (m.getInverse(a.matrixWorld),
          y.matrixWorldInverse.multiply(m),
          x.matrixWorldInverse.multiply(m)),
          y.matrixWorld.getInverse(y.matrixWorldInverse),
          x.matrixWorld.getInverse(x.matrixWorldInverse),
          y.projectionMatrix.fromArray(h.leftProjectionMatrix),
          x.projectionMatrix.fromArray(h.rightProjectionMatrix),
          b.projectionMatrix.copy(y.projectionMatrix);
        var o = c.getLayers();
        if (o.length) {
          var s = o[0];
          null !== s.leftBounds &&
            4 === s.leftBounds.length &&
            y.bounds.fromArray(s.leftBounds),
            null !== s.rightBounds &&
              4 === s.rightBounds.length &&
              x.bounds.fromArray(s.rightBounds);
        }
        return (
          (function () {
            for (var t = 0; t < u.length; t++) {
              var e = u[t],
                i = w(t);
              if (void 0 !== i && void 0 !== i.pose) {
                if (null === i.pose) return;
                var n = i.pose;
                !1 === n.hasPosition && e.position.set(0.2, -0.6, -0.05),
                  null !== n.position && e.position.fromArray(n.position),
                  null !== n.orientation && e.quaternion.fromArray(n.orientation),
                  e.matrix.compose(e.position, e.quaternion, e.scale),
                  e.matrix.premultiply(p),
                  e.matrix.decompose(e.position, e.quaternion, e.scale),
                  (e.matrixWorldNeedsUpdate = !0),
                  (e.visible = !0);
                var r = 'Daydream Controller' === i.id ? 0 : 1;
                _[t] !== i.buttons[r].pressed &&
                  ((_[t] = i.buttons[r].pressed),
                  !0 === _[t]
                    ? e.dispatchEvent({ type: 'selectstart' })
                    : (e.dispatchEvent({ type: 'selectend' }),
                      e.dispatchEvent({ type: 'select' })));
              } else e.visible = !1;
            }
          })(),
          b
        );
      }),
      (this.getStandingMatrix = function () {
        return p;
      }),
      (this.isPresenting = s);
    var M = new Ji();
    (this.setAnimationLoop = function (t) {
      M.setAnimationLoop(t);
    }),
      (this.submitFrame = function () {
        s() && c.submitFrame();
      }),
      (this.dispose = function () {
        'undefined' != typeof window &&
          window.removeEventListener('vrdisplaypresentchange', t);
      });
  }
  function cs(e) {
    var i = e.context,
      n = null,
      p = null,
      d = null,
      r = 'stage',
      f = null,
      m = [],
      g = [];
    function o() {
      return null !== p && null !== d;
    }
    var t = new as();
    t.layers.enable(1), (t.viewport = new Ti());
    var a = new as();
    a.layers.enable(2), (a.viewport = new Ti());
    var v = new os([t, a]);
    function s(t) {
      var e = m[g.indexOf(t.inputSource)];
      e && e.dispatchEvent({ type: t.type });
    }
    function c() {
      e.setFramebuffer(null), l.stop();
    }
    function h(t, e) {
      null === e
        ? t.matrixWorld.copy(t.matrix)
        : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix),
        t.matrixWorldInverse.getInverse(t.matrixWorld);
    }
    v.layers.enable(1),
      v.layers.enable(2),
      (this.enabled = !1),
      (this.getController = function (t) {
        var e = m[t];
        return (
          void 0 === e &&
            (((e = new ns()).matrixAutoUpdate = !1), (e.visible = !1), (m[t] = e)),
          e
        );
      }),
      (this.getDevice = function () {
        return n;
      }),
      (this.setDevice = function (t) {
        void 0 !== t && (n = t), t instanceof XRDevice && i.setCompatibleXRDevice(t);
      }),
      (this.setFrameOfReferenceType = function (t) {
        r = t;
      }),
      (this.setSession = function (t) {
        null !== (p = t) &&
          (p.addEventListener('select', s),
          p.addEventListener('selectstart', s),
          p.addEventListener('selectend', s),
          p.addEventListener('end', c),
          (p.baseLayer = new XRWebGLLayer(p, i)),
          p.requestFrameOfReference(r).then(function (t) {
            (d = t),
              e.setFramebuffer(p.baseLayer.framebuffer),
              l.setContext(p),
              l.start();
          }),
          (g = p.getInputSources()),
          p.addEventListener('inputsourceschange', function () {
            (g = p.getInputSources()), console.log(g);
          }));
      }),
      (this.getCamera = function (t) {
        if (o()) {
          var e = t.parent,
            i = v.cameras;
          h(v, e);
          for (var n = 0; n < i.length; n++) h(i[n], e);
          t.matrixWorld.copy(v.matrixWorld);
          for (var r = t.children, a = ((n = 0), r.length); n < a; n++)
            r[n].updateMatrixWorld(!0);
          return v;
        }
        return t;
      }),
      (this.isPresenting = o);
    var y = null;
    var l = new Ji();
    l.setAnimationLoop(function (t, e) {
      if (null !== (f = e.getDevicePose(d)))
        for (var i = p.baseLayer, n = e.views, r = 0; r < n.length; r++) {
          var a = n[r],
            o = i.getViewport(a),
            s = f.getViewMatrix(a),
            c = v.cameras[r];
          c.matrix.fromArray(s).getInverse(c.matrix),
            c.projectionMatrix.fromArray(a.projectionMatrix),
            c.viewport.set(o.x, o.y, o.width, o.height),
            0 === r &&
              (v.matrix.copy(c.matrix), v.projectionMatrix.copy(c.projectionMatrix));
        }
      for (r = 0; r < m.length; r++) {
        var h = m[r],
          l = g[r];
        if (l) {
          var u = e.getInputPose(l, d);
          if (null !== u) {
            'targetRay' in u
              ? (h.matrix.elements = u.targetRay.transformMatrix)
              : 'pointerMatrix' in u && (h.matrix.elements = u.pointerMatrix),
              h.matrix.decompose(h.position, h.rotation, h.scale),
              (h.visible = !0);
            continue;
          }
        }
        h.visible = !1;
      }
      y && y(t);
    }),
      (this.setAnimationLoop = function (t) {
        y = t;
      }),
      (this.dispose = function () {}),
      (this.getStandingMatrix = function () {
        return (
          console.warn('THREE.WebXRManager: getStandingMatrix() is no longer needed.'),
          new THREE.Matrix4()
        );
      }),
      (this.submitFrame = function () {});
  }
  function hs(t) {
    console.log('THREE.WebGLRenderer', '97');
    var n =
        void 0 !== (t = t || {}).canvas
          ? t.canvas
          : document.createElementNS('http://www.w3.org/1999/xhtml', 'canvas'),
      e = void 0 !== t.context ? t.context : null,
      i = void 0 !== t.alpha && t.alpha,
      r = void 0 === t.depth || t.depth,
      a = void 0 === t.stencil || t.stencil,
      o = void 0 !== t.antialias && t.antialias,
      s = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
      c = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
      h = void 0 !== t.powerPreference ? t.powerPreference : 'default',
      d = null,
      H = null;
    (this.domElement = n),
      (this.context = null),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.gammaFactor = 2),
      (this.gammaInput = !1),
      (this.gammaOutput = !1),
      (this.physicallyCorrectLights = !1),
      (this.toneMapping = Mt),
      (this.toneMappingExposure = 1),
      (this.toneMappingWhitePoint = 1),
      (this.maxMorphTargets = 8),
      (this.maxMorphNormals = 4);
    var V,
      M,
      k,
      j,
      l,
      W,
      u,
      E,
      T,
      f,
      y,
      p,
      m,
      g,
      S,
      A,
      L,
      v,
      X = this,
      x = !1,
      b = null,
      _ = null,
      w = null,
      q = -1,
      R = { geometry: null, program: null, wireframe: !1 },
      Y = null,
      P = null,
      C = new Ti(),
      O = new Ti(),
      I = null,
      J = 0,
      N = n.width,
      Z = n.height,
      Q = 1,
      D = new Ti(0, 0, N, Z),
      U = new Ti(0, 0, N, Z),
      B = !1,
      F = new Ni(),
      K = new ea(),
      $ = !1,
      tt = !1,
      z = new Ve(),
      et = new je();
    function G() {
      return null === _ ? Q : 1;
    }
    try {
      var it = {
        alpha: i,
        depth: r,
        stencil: a,
        antialias: o,
        premultipliedAlpha: s,
        preserveDrawingBuffer: c,
        powerPreference: h
      };
      if (
        (n.addEventListener('webglcontextlost', ot, !1),
        n.addEventListener('webglcontextrestored', st, !1),
        null ===
          (V = e || n.getContext('webgl', it) || n.getContext('experimental-webgl', it)))
      )
        throw null !== n.getContext('webgl')
          ? new Error('Error creating WebGL context with your selected attributes.')
          : new Error('Error creating WebGL context.');
      void 0 === V.getShaderPrecisionFormat &&
        (V.getShaderPrecisionFormat = function () {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        });
    } catch (t) {
      console.error('THREE.WebGLRenderer: ' + t.message);
    }
    function nt() {
      (M = new ia(V)),
        (k = new ta(V, M, t)).isWebGL2 ||
          (M.get('WEBGL_depth_texture'),
          M.get('OES_texture_float'),
          M.get('OES_texture_half_float'),
          M.get('OES_texture_half_float_linear'),
          M.get('OES_standard_derivatives'),
          M.get('OES_element_index_uint'),
          M.get('ANGLE_instanced_arrays')),
        M.get('OES_texture_float_linear'),
        (v = new is(V, M, k)),
        (j = new ts(V, M, v, k)).scissor(O.copy(U).multiplyScalar(Q)),
        j.viewport(C.copy(D).multiplyScalar(Q)),
        (l = new aa(V)),
        (W = new po()),
        (u = new es(V, M, j, W, k, v, l)),
        (E = new Zi(V)),
        (T = new na(V, E, l)),
        (f = new ca(T, l)),
        (S = new sa(V)),
        (y = new uo(X, M, k)),
        (p = new vo()),
        (m = new Zo()),
        (g = new Kr(X, j, f, s)),
        (A = new $r(V, M, l, k)),
        (L = new ra(V, M, l, k)),
        (l.programs = y.programs),
        (X.context = V),
        (X.capabilities = k),
        (X.extensions = M),
        (X.properties = W),
        (X.renderLists = p),
        (X.state = j),
        (X.info = l);
    }
    nt();
    var rt = null;
    'undefined' != typeof navigator && (rt = new ('xr' in navigator ? cs : ss)(X)),
      (this.vr = rt);
    var at = new $o(X, f, k.maxTextureSize);
    function ot(t) {
      t.preventDefault(), console.log('THREE.WebGLRenderer: Context Lost.'), (x = !0);
    }
    function st() {
      console.log('THREE.WebGLRenderer: Context Restored.'), (x = !1), nt();
    }
    function ct(t) {
      var e,
        i = t.target;
      i.removeEventListener('dispose', ct), ht((e = i)), W.remove(e);
    }
    function ht(t) {
      var e = W.get(t).program;
      (t.program = void 0) !== e && y.releaseProgram(e);
    }
    (this.shadowMap = at),
      (this.getContext = function () {
        return V;
      }),
      (this.getContextAttributes = function () {
        return V.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        var t = M.get('WEBGL_lose_context');
        t && t.loseContext();
      }),
      (this.forceContextRestore = function () {
        var t = M.get('WEBGL_lose_context');
        t && t.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return Q;
      }),
      (this.setPixelRatio = function (t) {
        void 0 !== t && ((Q = t), this.setSize(N, Z, !1));
      }),
      (this.getSize = function () {
        return { width: N, height: Z };
      }),
      (this.setSize = function (t, e, i) {
        rt.isPresenting()
          ? console.warn(
              "THREE.WebGLRenderer: Can't change size while VR device is presenting."
            )
          : ((N = t),
            (Z = e),
            (n.width = t * Q),
            (n.height = e * Q),
            !1 !== i && ((n.style.width = t + 'px'), (n.style.height = e + 'px')),
            this.setViewport(0, 0, t, e));
      }),
      (this.getDrawingBufferSize = function () {
        return { width: N * Q, height: Z * Q };
      }),
      (this.setDrawingBufferSize = function (t, e, i) {
        (N = t),
          (Z = e),
          (Q = i),
          (n.width = t * i),
          (n.height = e * i),
          this.setViewport(0, 0, t, e);
      }),
      (this.getCurrentViewport = function () {
        return C;
      }),
      (this.setViewport = function (t, e, i, n) {
        D.set(t, Z - e - n, i, n), j.viewport(C.copy(D).multiplyScalar(Q));
      }),
      (this.setScissor = function (t, e, i, n) {
        U.set(t, Z - e - n, i, n), j.scissor(O.copy(U).multiplyScalar(Q));
      }),
      (this.setScissorTest = function (t) {
        j.setScissorTest((B = t));
      }),
      (this.getClearColor = function () {
        return g.getClearColor();
      }),
      (this.setClearColor = function () {
        g.setClearColor.apply(g, arguments);
      }),
      (this.getClearAlpha = function () {
        return g.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        g.setClearAlpha.apply(g, arguments);
      }),
      (this.clear = function (t, e, i) {
        var n = 0;
        (void 0 !== t && !t) || (n |= V.COLOR_BUFFER_BIT),
          (void 0 !== e && !e) || (n |= V.DEPTH_BUFFER_BIT),
          (void 0 !== i && !i) || (n |= V.STENCIL_BUFFER_BIT),
          V.clear(n);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        n.removeEventListener('webglcontextlost', ot, !1),
          n.removeEventListener('webglcontextrestored', st, !1),
          p.dispose(),
          m.dispose(),
          W.dispose(),
          f.dispose(),
          rt.dispose(),
          ft.stop();
      }),
      (this.renderBufferImmediate = function (t, e) {
        j.initAttributes();
        var i = W.get(t);
        t.hasPositions && !i.position && (i.position = V.createBuffer()),
          t.hasNormals && !i.normal && (i.normal = V.createBuffer()),
          t.hasUvs && !i.uv && (i.uv = V.createBuffer()),
          t.hasColors && !i.color && (i.color = V.createBuffer());
        var n = e.getAttributes();
        t.hasPositions &&
          (V.bindBuffer(V.ARRAY_BUFFER, i.position),
          V.bufferData(V.ARRAY_BUFFER, t.positionArray, V.DYNAMIC_DRAW),
          j.enableAttribute(n.position),
          V.vertexAttribPointer(n.position, 3, V.FLOAT, !1, 0, 0)),
          t.hasNormals &&
            (V.bindBuffer(V.ARRAY_BUFFER, i.normal),
            V.bufferData(V.ARRAY_BUFFER, t.normalArray, V.DYNAMIC_DRAW),
            j.enableAttribute(n.normal),
            V.vertexAttribPointer(n.normal, 3, V.FLOAT, !1, 0, 0)),
          t.hasUvs &&
            (V.bindBuffer(V.ARRAY_BUFFER, i.uv),
            V.bufferData(V.ARRAY_BUFFER, t.uvArray, V.DYNAMIC_DRAW),
            j.enableAttribute(n.uv),
            V.vertexAttribPointer(n.uv, 2, V.FLOAT, !1, 0, 0)),
          t.hasColors &&
            (V.bindBuffer(V.ARRAY_BUFFER, i.color),
            V.bufferData(V.ARRAY_BUFFER, t.colorArray, V.DYNAMIC_DRAW),
            j.enableAttribute(n.color),
            V.vertexAttribPointer(n.color, 3, V.FLOAT, !1, 0, 0)),
          j.disableUnusedAttributes(),
          V.drawArrays(V.TRIANGLES, 0, t.count),
          (t.count = 0);
      }),
      (this.renderBufferDirect = function (t, e, i, n, r, a) {
        var o = r.isMesh && r.normalMatrix.determinant() < 0;
        j.setMaterial(n, o);
        var s = yt(t, e, n, r),
          c = !1;
        (R.geometry === i.id &&
          R.program === s.id &&
          R.wireframe === (!0 === n.wireframe)) ||
          ((R.geometry = i.id),
          (R.program = s.id),
          (R.wireframe = !0 === n.wireframe),
          (c = !0)),
          r.morphTargetInfluences && (S.update(r, i, n, s), (c = !0));
        var h,
          l = i.index,
          u = i.attributes.position,
          p = 1;
        !0 === n.wireframe && ((l = T.getWireframeAttribute(i)), (p = 2));
        var d = A;
        null !== l && ((h = E.get(l)), (d = L).setIndex(h)),
          c &&
            ((function (t, e, i) {
              if (
                i &&
                i.isInstancedBufferGeometry & !k.isWebGL2 &&
                null === M.get('ANGLE_instanced_arrays')
              )
                return console.error(
                  'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.'
                );
              j.initAttributes();
              var n = i.attributes,
                r = e.getAttributes(),
                a = t.defaultAttributeValues;
              for (var o in r) {
                var s = r[o];
                if (0 <= s) {
                  var c = n[o];
                  if (void 0 !== c) {
                    var h = c.normalized,
                      l = c.itemSize,
                      u = E.get(c);
                    if (void 0 === u) continue;
                    var p = u.buffer,
                      d = u.type,
                      f = u.bytesPerElement;
                    if (c.isInterleavedBufferAttribute) {
                      var m = c.data,
                        g = m.stride,
                        v = c.offset;
                      m && m.isInstancedInterleavedBuffer
                        ? (j.enableAttributeAndDivisor(s, m.meshPerAttribute),
                          void 0 === i.maxInstancedCount &&
                            (i.maxInstancedCount = m.meshPerAttribute * m.count))
                        : j.enableAttribute(s),
                        V.bindBuffer(V.ARRAY_BUFFER, p),
                        V.vertexAttribPointer(s, l, d, h, g * f, v * f);
                    } else
                      c.isInstancedBufferAttribute
                        ? (j.enableAttributeAndDivisor(s, c.meshPerAttribute),
                          void 0 === i.maxInstancedCount &&
                            (i.maxInstancedCount = c.meshPerAttribute * c.count))
                        : j.enableAttribute(s),
                        V.bindBuffer(V.ARRAY_BUFFER, p),
                        V.vertexAttribPointer(s, l, d, h, 0, 0);
                  } else if (void 0 !== a) {
                    var y = a[o];
                    if (void 0 !== y)
                      switch (y.length) {
                        case 2:
                          V.vertexAttrib2fv(s, y);
                          break;
                        case 3:
                          V.vertexAttrib3fv(s, y);
                          break;
                        case 4:
                          V.vertexAttrib4fv(s, y);
                          break;
                        default:
                          V.vertexAttrib1fv(s, y);
                      }
                  }
                }
              }
              j.disableUnusedAttributes();
            })(n, s, i),
            null !== l && V.bindBuffer(V.ELEMENT_ARRAY_BUFFER, h.buffer));
        var f = 1 / 0;
        null !== l ? (f = l.count) : void 0 !== u && (f = u.count);
        var m = i.drawRange.start * p,
          g = i.drawRange.count * p,
          v = null !== a ? a.start * p : 0,
          y = null !== a ? a.count * p : 1 / 0,
          x = Math.max(m, v),
          b = Math.min(f, m + g, v + y) - 1,
          _ = Math.max(0, b - x + 1);
        if (0 !== _) {
          if (r.isMesh)
            if (!0 === n.wireframe)
              j.setLineWidth(n.wireframeLinewidth * G()), d.setMode(V.LINES);
            else
              switch (r.drawMode) {
                case Le:
                  d.setMode(V.TRIANGLES);
                  break;
                case 1:
                  d.setMode(V.TRIANGLE_STRIP);
                  break;
                case 2:
                  d.setMode(V.TRIANGLE_FAN);
              }
          else if (r.isLine) {
            var w = n.linewidth;
            void 0 === w && (w = 1),
              j.setLineWidth(w * G()),
              r.isLineSegments
                ? d.setMode(V.LINES)
                : r.isLineLoop
                ? d.setMode(V.LINE_LOOP)
                : d.setMode(V.LINE_STRIP);
          } else r.isPoints ? d.setMode(V.POINTS) : r.isSprite && d.setMode(V.TRIANGLES);
          i && i.isInstancedBufferGeometry
            ? 0 < i.maxInstancedCount && d.renderInstances(i, x, _)
            : d.render(x, _);
        }
      }),
      (this.compile = function (i, t) {
        (H = m.get(i, t)).init(),
          i.traverse(function (t) {
            t.isLight && (H.pushLight(t), t.castShadow && H.pushShadow(t));
          }),
          H.setupLights(t),
          i.traverse(function (t) {
            if (t.material)
              if (Array.isArray(t.material))
                for (var e = 0; e < t.material.length; e++) vt(t.material[e], i.fog, t);
              else vt(t.material, i.fog, t);
          });
      });
    var lt = null;
    var ut,
      pt,
      dt,
      ft = new Ji();
    function mt(t, e, i, n) {
      for (var r = 0, a = t.length; r < a; r++) {
        var o = t[r],
          s = o.object,
          c = o.geometry,
          h = void 0 === n ? o.material : n,
          l = o.group;
        if (i.isArrayCamera)
          for (var u = (P = i).cameras, p = 0, d = u.length; p < d; p++) {
            var f = u[p];
            if (s.layers.test(f.layers)) {
              if ('viewport' in f) j.viewport(C.copy(f.viewport));
              else {
                var m = f.bounds,
                  g = m.x * N,
                  v = m.y * Z,
                  y = m.z * N,
                  x = m.w * Z;
                j.viewport(C.set(g, v, y, x).multiplyScalar(Q));
              }
              H.setupLights(f), gt(s, e, f, c, h, l);
            }
          }
        else (P = null), gt(s, e, i, c, h, l);
      }
    }
    function gt(t, e, i, n, r, a) {
      if (
        (t.onBeforeRender(X, e, i, n, r, a),
        (H = m.get(e, P || i)),
        t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld),
        t.normalMatrix.getNormalMatrix(t.modelViewMatrix),
        t.isImmediateRenderObject)
      ) {
        j.setMaterial(r);
        var o = yt(i, e.fog, r, t);
        (R.geometry = null),
          (R.program = null),
          (R.wireframe = !1),
          (s = o),
          t.render(function (t) {
            X.renderBufferImmediate(t, s);
          });
      } else X.renderBufferDirect(i, e.fog, n, r, t, a);
      var s;
      t.onAfterRender(X, e, i, n, r, a), (H = m.get(e, P || i));
    }
    function vt(t, e, i) {
      var n = W.get(t),
        r = H.state.lights,
        a = H.state.shadowsArray,
        o = n.lightsHash,
        s = r.state.hash,
        c = y.getParameters(t, r.state, a, e, K.numPlanes, K.numIntersection, i),
        h = y.getProgramCode(t, c),
        l = n.program,
        u = !0;
      if (void 0 === l) t.addEventListener('dispose', ct);
      else if (l.code !== h) ht(t);
      else if (
        o.stateID !== s.stateID ||
        o.directionalLength !== s.directionalLength ||
        o.pointLength !== s.pointLength ||
        o.spotLength !== s.spotLength ||
        o.rectAreaLength !== s.rectAreaLength ||
        o.hemiLength !== s.hemiLength ||
        o.shadowsLength !== s.shadowsLength
      )
        (o.stateID = s.stateID),
          (o.directionalLength = s.directionalLength),
          (o.pointLength = s.pointLength),
          (o.spotLength = s.spotLength),
          (o.rectAreaLength = s.rectAreaLength),
          (o.hemiLength = s.hemiLength),
          (o.shadowsLength = s.shadowsLength),
          (u = !1);
      else {
        if (void 0 !== c.shaderID) return;
        u = !1;
      }
      if (u) {
        if (c.shaderID) {
          var p = Yi[c.shaderID];
          n.shader = {
            name: t.type,
            uniforms: zi.clone(p.uniforms),
            vertexShader: p.vertexShader,
            fragmentShader: p.fragmentShader
          };
        } else
          n.shader = {
            name: t.type,
            uniforms: t.uniforms,
            vertexShader: t.vertexShader,
            fragmentShader: t.fragmentShader
          };
        t.onBeforeCompile(n.shader, X),
          (h = y.getProgramCode(t, c)),
          (l = y.acquireProgram(t, n.shader, c, h)),
          (n.program = l),
          (t.program = l);
      }
      var d = l.getAttributes();
      if (t.morphTargets)
        for (var f = (t.numSupportedMorphTargets = 0); f < X.maxMorphTargets; f++)
          0 <= d['morphTarget' + f] && t.numSupportedMorphTargets++;
      if (t.morphNormals)
        for (f = t.numSupportedMorphNormals = 0; f < X.maxMorphNormals; f++)
          0 <= d['morphNormal' + f] && t.numSupportedMorphNormals++;
      var m = n.shader.uniforms;
      ((t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping) ||
        ((n.numClippingPlanes = K.numPlanes),
        (n.numIntersection = K.numIntersection),
        (m.clippingPlanes = K.uniform)),
        (n.fog = e),
        void 0 === o && (n.lightsHash = o = {}),
        (o.stateID = s.stateID),
        (o.directionalLength = s.directionalLength),
        (o.pointLength = s.pointLength),
        (o.spotLength = s.spotLength),
        (o.rectAreaLength = s.rectAreaLength),
        (o.hemiLength = s.hemiLength),
        (o.shadowsLength = s.shadowsLength),
        t.lights &&
          ((m.ambientLightColor.value = r.state.ambient),
          (m.directionalLights.value = r.state.directional),
          (m.spotLights.value = r.state.spot),
          (m.rectAreaLights.value = r.state.rectArea),
          (m.pointLights.value = r.state.point),
          (m.hemisphereLights.value = r.state.hemi),
          (m.directionalShadowMap.value = r.state.directionalShadowMap),
          (m.directionalShadowMatrix.value = r.state.directionalShadowMatrix),
          (m.spotShadowMap.value = r.state.spotShadowMap),
          (m.spotShadowMatrix.value = r.state.spotShadowMatrix),
          (m.pointShadowMap.value = r.state.pointShadowMap),
          (m.pointShadowMatrix.value = r.state.pointShadowMatrix));
      var g = n.program.getUniforms(),
        v = to.seqWithValue(g.seq, m);
      n.uniformsList = v;
    }
    function yt(t, e, i, n) {
      J = 0;
      var r = W.get(i),
        a = H.state.lights,
        o = r.lightsHash,
        s = a.state.hash;
      if ($ && (tt || t !== Y)) {
        var c = t === Y && i.id === q;
        K.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, c);
      }
      !1 === i.needsUpdate &&
        (void 0 === r.program || (i.fog && r.fog !== e)
          ? (i.needsUpdate = !0)
          : ((!i.lights ||
              (o.stateID === s.stateID &&
                o.directionalLength === s.directionalLength &&
                o.pointLength === s.pointLength &&
                o.spotLength === s.spotLength &&
                o.rectAreaLength === s.rectAreaLength &&
                o.hemiLength === s.hemiLength &&
                o.shadowsLength === s.shadowsLength)) &&
              (void 0 === r.numClippingPlanes ||
                (r.numClippingPlanes === K.numPlanes &&
                  r.numIntersection === K.numIntersection))) ||
            (i.needsUpdate = !0)),
        i.needsUpdate && (vt(i, e, n), (i.needsUpdate = !1));
      var h,
        l,
        u,
        p,
        d,
        f,
        m,
        g,
        v,
        y,
        x,
        b,
        _,
        w,
        M,
        E,
        T,
        S,
        A,
        L,
        R = !1,
        P = !1,
        C = !1,
        O = r.program,
        I = O.getUniforms(),
        N = r.shader.uniforms;
      if (
        (j.useProgram(O.program) && (C = P = R = !0),
        i.id !== q && ((q = i.id), (P = !0)),
        R || Y !== t)
      ) {
        if (
          (I.setValue(V, 'projectionMatrix', t.projectionMatrix),
          k.logarithmicDepthBuffer &&
            I.setValue(V, 'logDepthBufFC', 2 / (Math.log(t.far + 1) / Math.LN2)),
          Y !== t && ((Y = t), (C = P = !0)),
          i.isShaderMaterial ||
            i.isMeshPhongMaterial ||
            i.isMeshStandardMaterial ||
            i.envMap)
        ) {
          var D = I.map.cameraPosition;
          void 0 !== D && D.setValue(V, et.setFromMatrixPosition(t.matrixWorld));
        }
        (i.isMeshPhongMaterial ||
          i.isMeshLambertMaterial ||
          i.isMeshBasicMaterial ||
          i.isMeshStandardMaterial ||
          i.isShaderMaterial ||
          i.skinning) &&
          I.setValue(V, 'viewMatrix', t.matrixWorldInverse);
      }
      if (i.skinning) {
        I.setOptional(V, n, 'bindMatrix'), I.setOptional(V, n, 'bindMatrixInverse');
        var U = n.skeleton;
        if (U) {
          var B = U.bones;
          if (k.floatVertexTextures) {
            if (void 0 === U.boneTexture) {
              var F = Math.sqrt(4 * B.length);
              (F = Ge.ceilPowerOfTwo(F)), (F = Math.max(F, 4));
              var z = new Float32Array(F * F * 4);
              z.set(U.boneMatrices);
              var G = new Li(z, F, F, qt, zt);
              (G.needsUpdate = !0),
                (U.boneMatrices = z),
                (U.boneTexture = G),
                (U.boneTextureSize = F);
            }
            I.setValue(V, 'boneTexture', U.boneTexture),
              I.setValue(V, 'boneTextureSize', U.boneTextureSize);
          } else I.setOptional(V, U, 'boneMatrices');
        }
      }
      return (
        P &&
          (I.setValue(V, 'toneMappingExposure', X.toneMappingExposure),
          I.setValue(V, 'toneMappingWhitePoint', X.toneMappingWhitePoint),
          i.lights &&
            ((L = C),
            ((A = N).ambientLightColor.needsUpdate = L),
            (A.directionalLights.needsUpdate = L),
            (A.pointLights.needsUpdate = L),
            (A.spotLights.needsUpdate = L),
            (A.rectAreaLights.needsUpdate = L),
            (A.hemisphereLights.needsUpdate = L)),
          e &&
            i.fog &&
            ((S = e),
            ((T = N).fogColor.value = S.color),
            S.isFog
              ? ((T.fogNear.value = S.near), (T.fogFar.value = S.far))
              : S.isFogExp2 && (T.fogDensity.value = S.density)),
          i.isMeshBasicMaterial
            ? xt(N, i)
            : i.isMeshLambertMaterial
            ? (xt(N, i),
              (M = N),
              (E = i).emissiveMap && (M.emissiveMap.value = E.emissiveMap))
            : i.isMeshPhongMaterial
            ? (xt(N, i),
              i.isMeshToonMaterial
                ? (bt((_ = N), (w = i)),
                  w.gradientMap && (_.gradientMap.value = w.gradientMap))
                : bt(N, i))
            : i.isMeshStandardMaterial
            ? (xt(N, i),
              i.isMeshPhysicalMaterial
                ? (_t((x = N), (b = i)),
                  (x.reflectivity.value = b.reflectivity),
                  (x.clearCoat.value = b.clearCoat),
                  (x.clearCoatRoughness.value = b.clearCoatRoughness))
                : _t(N, i))
            : i.isMeshMatcapMaterial
            ? (xt(N, i),
              (function (t, e) {
                e.matcap && (t.matcap.value = e.matcap);
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  e.side === wt && (t.bumpScale.value *= -1));
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  e.side === wt && t.normalScale.value.negate());
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(N, i))
            : i.isMeshDepthMaterial
            ? (xt(N, i),
              (v = N),
              (y = i).displacementMap &&
                ((v.displacementMap.value = y.displacementMap),
                (v.displacementScale.value = y.displacementScale),
                (v.displacementBias.value = y.displacementBias)))
            : i.isMeshDistanceMaterial
            ? (xt(N, i),
              (function (t, e) {
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
                t.referencePosition.value.copy(e.referencePosition),
                  (t.nearDistance.value = e.nearDistance),
                  (t.farDistance.value = e.farDistance);
              })(N, i))
            : i.isMeshNormalMaterial
            ? (xt(N, i),
              (function (t, e) {
                e.bumpMap &&
                  ((t.bumpMap.value = e.bumpMap),
                  (t.bumpScale.value = e.bumpScale),
                  e.side === wt && (t.bumpScale.value *= -1));
                e.normalMap &&
                  ((t.normalMap.value = e.normalMap),
                  t.normalScale.value.copy(e.normalScale),
                  e.side === wt && t.normalScale.value.negate());
                e.displacementMap &&
                  ((t.displacementMap.value = e.displacementMap),
                  (t.displacementScale.value = e.displacementScale),
                  (t.displacementBias.value = e.displacementBias));
              })(N, i))
            : i.isLineBasicMaterial
            ? ((g = i),
              ((m = N).diffuse.value = g.color),
              (m.opacity.value = g.opacity),
              i.isLineDashedMaterial &&
                ((f = i),
                ((d = N).dashSize.value = f.dashSize),
                (d.totalSize.value = f.dashSize + f.gapSize),
                (d.scale.value = f.scale)))
            : i.isPointsMaterial
            ? ((p = i),
              ((u = N).diffuse.value = p.color),
              (u.opacity.value = p.opacity),
              (u.size.value = p.size * Q),
              (u.scale.value = 0.5 * Z),
              (u.map.value = p.map),
              null !== p.map &&
                (!0 === p.map.matrixAutoUpdate && p.map.updateMatrix(),
                u.uvTransform.value.copy(p.map.matrix)))
            : i.isSpriteMaterial
            ? ((l = i),
              ((h = N).diffuse.value = l.color),
              (h.opacity.value = l.opacity),
              (h.rotation.value = l.rotation),
              (h.map.value = l.map),
              null !== l.map &&
                (!0 === l.map.matrixAutoUpdate && l.map.updateMatrix(),
                h.uvTransform.value.copy(l.map.matrix)))
            : i.isShadowMaterial &&
              ((N.color.value = i.color), (N.opacity.value = i.opacity)),
          void 0 !== N.ltc_1 && (N.ltc_1.value = qi.LTC_1),
          void 0 !== N.ltc_2 && (N.ltc_2.value = qi.LTC_2),
          to.upload(V, r.uniformsList, N, X)),
        i.isShaderMaterial &&
          !0 === i.uniformsNeedUpdate &&
          (to.upload(V, r.uniformsList, N, X), (i.uniformsNeedUpdate = !1)),
        i.isSpriteMaterial && I.setValue(V, 'center', n.center),
        I.setValue(V, 'modelViewMatrix', n.modelViewMatrix),
        I.setValue(V, 'normalMatrix', n.normalMatrix),
        I.setValue(V, 'modelMatrix', n.matrixWorld),
        O
      );
    }
    function xt(t, e) {
      var i;
      (t.opacity.value = e.opacity),
        e.color && (t.diffuse.value = e.color),
        e.emissive &&
          t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity),
        e.map && (t.map.value = e.map),
        e.alphaMap && (t.alphaMap.value = e.alphaMap),
        e.specularMap && (t.specularMap.value = e.specularMap),
        e.envMap &&
          ((t.envMap.value = e.envMap),
          (t.flipEnvMap.value = e.envMap && e.envMap.isCubeTexture ? -1 : 1),
          (t.reflectivity.value = e.reflectivity),
          (t.refractionRatio.value = e.refractionRatio),
          (t.maxMipLevel.value = W.get(e.envMap).__maxMipLevel)),
        e.lightMap &&
          ((t.lightMap.value = e.lightMap),
          (t.lightMapIntensity.value = e.lightMapIntensity)),
        e.aoMap &&
          ((t.aoMap.value = e.aoMap), (t.aoMapIntensity.value = e.aoMapIntensity)),
        e.map
          ? (i = e.map)
          : e.specularMap
          ? (i = e.specularMap)
          : e.displacementMap
          ? (i = e.displacementMap)
          : e.normalMap
          ? (i = e.normalMap)
          : e.bumpMap
          ? (i = e.bumpMap)
          : e.roughnessMap
          ? (i = e.roughnessMap)
          : e.metalnessMap
          ? (i = e.metalnessMap)
          : e.alphaMap
          ? (i = e.alphaMap)
          : e.emissiveMap && (i = e.emissiveMap),
        void 0 !== i &&
          (i.isWebGLRenderTarget && (i = i.texture),
          !0 === i.matrixAutoUpdate && i.updateMatrix(),
          t.uvTransform.value.copy(i.matrix));
    }
    function bt(t, e) {
      (t.specular.value = e.specular),
        (t.shininess.value = Math.max(e.shininess, 1e-4)),
        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
        e.bumpMap &&
          ((t.bumpMap.value = e.bumpMap),
          (t.bumpScale.value = e.bumpScale),
          e.side === wt && (t.bumpScale.value *= -1)),
        e.normalMap &&
          ((t.normalMap.value = e.normalMap),
          t.normalScale.value.copy(e.normalScale),
          e.side === wt && t.normalScale.value.negate()),
        e.displacementMap &&
          ((t.displacementMap.value = e.displacementMap),
          (t.displacementScale.value = e.displacementScale),
          (t.displacementBias.value = e.displacementBias));
    }
    function _t(t, e) {
      (t.roughness.value = e.roughness),
        (t.metalness.value = e.metalness),
        e.roughnessMap && (t.roughnessMap.value = e.roughnessMap),
        e.metalnessMap && (t.metalnessMap.value = e.metalnessMap),
        e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
        e.bumpMap &&
          ((t.bumpMap.value = e.bumpMap),
          (t.bumpScale.value = e.bumpScale),
          e.side === wt && (t.bumpScale.value *= -1)),
        e.normalMap &&
          ((t.normalMap.value = e.normalMap),
          t.normalScale.value.copy(e.normalScale),
          e.side === wt && t.normalScale.value.negate()),
        e.displacementMap &&
          ((t.displacementMap.value = e.displacementMap),
          (t.displacementScale.value = e.displacementScale),
          (t.displacementBias.value = e.displacementBias)),
        e.envMap && (t.envMapIntensity.value = e.envMapIntensity);
    }
    ft.setAnimationLoop(function (t) {
      rt.isPresenting() || (lt && lt(t));
    }),
      'undefined' != typeof window && ft.setContext(window),
      (this.setAnimationLoop = function (t) {
        (lt = t), rt.setAnimationLoop(t), ft.start();
      }),
      (this.render = function (t, e, i, n) {
        if (e && e.isCamera) {
          if (!x) {
            (R.geometry = null),
              (R.program = null),
              (R.wireframe = !1),
              (q = -1),
              !(Y = null) === t.autoUpdate && t.updateMatrixWorld(),
              null === e.parent && e.updateMatrixWorld(),
              rt.enabled && (e = rt.getCamera(e)),
              (H = m.get(t, e)).init(),
              t.onBeforeRender(X, t, e, i),
              z.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse),
              F.setFromMatrix(z),
              (tt = this.localClippingEnabled),
              ($ = K.init(this.clippingPlanes, tt, e)),
              (d = p.get(t, e)).init(),
              (function t(e, i, n) {
                if (!1 === e.visible) return;
                var r = e.layers.test(i.layers);
                if (r)
                  if (e.isLight) H.pushLight(e), e.castShadow && H.pushShadow(e);
                  else if (e.isSprite) {
                    if (!e.frustumCulled || F.intersectsSprite(e)) {
                      n && et.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
                      var a = f.update(e),
                        o = e.material;
                      d.push(e, a, o, et.z, null);
                    }
                  } else if (e.isImmediateRenderObject)
                    n && et.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z),
                      d.push(e, null, e.material, et.z, null);
                  else if (
                    (e.isMesh || e.isLine || e.isPoints) &&
                    (e.isSkinnedMesh && e.skeleton.update(),
                    !e.frustumCulled || F.intersectsObject(e))
                  ) {
                    n && et.setFromMatrixPosition(e.matrixWorld).applyMatrix4(z);
                    var a = f.update(e),
                      o = e.material;
                    if (Array.isArray(o))
                      for (var s = a.groups, c = 0, h = s.length; c < h; c++) {
                        var l = s[c],
                          u = o[l.materialIndex];
                        u && u.visible && d.push(e, a, u, et.z, l);
                      }
                    else o.visible && d.push(e, a, o, et.z, null);
                  }
                var p = e.children;
                for (var c = 0, h = p.length; c < h; c++) t(p[c], i, n);
              })(t, e, X.sortObjects),
              !0 === X.sortObjects && d.sort(),
              $ && K.beginShadows();
            var r = H.state.shadowsArray;
            at.render(r, t, e),
              H.setupLights(e),
              $ && K.endShadows(),
              this.info.autoReset && this.info.reset(),
              void 0 === i && (i = null),
              this.setRenderTarget(i),
              g.render(d, t, e, n);
            var a = d.opaque,
              o = d.transparent;
            if (t.overrideMaterial) {
              var s = t.overrideMaterial;
              a.length && mt(a, t, e, s), o.length && mt(o, t, e, s);
            } else a.length && mt(a, t, e), o.length && mt(o, t, e);
            i && u.updateRenderTargetMipmap(i),
              j.buffers.depth.setTest(!0),
              j.buffers.depth.setMask(!0),
              j.buffers.color.setMask(!0),
              j.setPolygonOffset(!1),
              t.onAfterRender(X, t, e),
              rt.enabled && rt.submitFrame(),
              (H = d = null);
          }
        } else
          console.error(
            'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.'
          );
      }),
      (this.allocTextureUnit = function () {
        var t = J;
        return (
          t >= k.maxTextures &&
            console.warn(
              'THREE.WebGLRenderer: Trying to use ' +
                t +
                ' texture units while this GPU supports only ' +
                k.maxTextures
            ),
          (J += 1),
          t
        );
      }),
      (this.setTexture2D =
        ((ut = !1),
        function (t, e) {
          t &&
            t.isWebGLRenderTarget &&
            (ut ||
              (console.warn(
                "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."
              ),
              (ut = !0)),
            (t = t.texture)),
            u.setTexture2D(t, e);
        })),
      (this.setTexture3D = function (t, e) {
        u.setTexture3D(t, e);
      }),
      (this.setTexture =
        ((pt = !1),
        function (t, e) {
          pt ||
            (console.warn(
              'THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.'
            ),
            (pt = !0)),
            u.setTexture2D(t, e);
        })),
      (this.setTextureCube =
        ((dt = !1),
        function (t, e) {
          t &&
            t.isWebGLRenderTargetCube &&
            (dt ||
              (console.warn(
                "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."
              ),
              (dt = !0)),
            (t = t.texture)),
            (t && t.isCubeTexture) || (Array.isArray(t.image) && 6 === t.image.length)
              ? u.setTextureCube(t, e)
              : u.setTextureCubeDynamic(t, e);
        })),
      (this.setFramebuffer = function (t) {
        b = t;
      }),
      (this.getRenderTarget = function () {
        return _;
      }),
      (this.setRenderTarget = function (t) {
        (_ = t) && void 0 === W.get(t).__webglFramebuffer && u.setupRenderTarget(t);
        var e = b,
          i = !1;
        if (t) {
          var n = W.get(t).__webglFramebuffer;
          t.isWebGLRenderTargetCube ? ((e = n[t.activeCubeFace]), (i = !0)) : (e = n),
            C.copy(t.viewport),
            O.copy(t.scissor),
            (I = t.scissorTest);
        } else C.copy(D).multiplyScalar(Q), O.copy(U).multiplyScalar(Q), (I = B);
        if (
          (w !== e && (V.bindFramebuffer(V.FRAMEBUFFER, e), (w = e)),
          j.viewport(C),
          j.scissor(O),
          j.setScissorTest(I),
          i)
        ) {
          var r = W.get(t.texture);
          V.framebufferTexture2D(
            V.FRAMEBUFFER,
            V.COLOR_ATTACHMENT0,
            V.TEXTURE_CUBE_MAP_POSITIVE_X + t.activeCubeFace,
            r.__webglTexture,
            t.activeMipMapLevel
          );
        }
      }),
      (this.readRenderTargetPixels = function (t, e, i, n, r, a) {
        if (t && t.isWebGLRenderTarget) {
          var o = W.get(t).__webglFramebuffer;
          if (o) {
            var s = !1;
            o !== w && (V.bindFramebuffer(V.FRAMEBUFFER, o), (s = !0));
            try {
              var c = t.texture,
                h = c.format,
                l = c.type;
              if (
                h !== qt &&
                v.convert(h) !== V.getParameter(V.IMPLEMENTATION_COLOR_READ_FORMAT)
              )
                return void console.error(
                  'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.'
                );
              if (
                !(
                  l === It ||
                  v.convert(l) === V.getParameter(V.IMPLEMENTATION_COLOR_READ_TYPE) ||
                  (l === zt &&
                    (k.isWebGL2 ||
                      M.get('OES_texture_float') ||
                      M.get('WEBGL_color_buffer_float'))) ||
                  (l === Gt &&
                    (k.isWebGL2
                      ? M.get('EXT_color_buffer_float')
                      : M.get('EXT_color_buffer_half_float')))
                )
              )
                return void console.error(
                  'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.'
                );
              V.checkFramebufferStatus(V.FRAMEBUFFER) === V.FRAMEBUFFER_COMPLETE
                ? 0 <= e &&
                  e <= t.width - n &&
                  0 <= i &&
                  i <= t.height - r &&
                  V.readPixels(e, i, n, r, v.convert(h), v.convert(l), a)
                : console.error(
                    'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.'
                  );
            } finally {
              s && V.bindFramebuffer(V.FRAMEBUFFER, w);
            }
          }
        } else
          console.error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.'
          );
      }),
      (this.copyFramebufferToTexture = function (t, e, i) {
        var n = e.image.width,
          r = e.image.height,
          a = v.convert(e.format);
        this.setTexture2D(e, 0),
          V.copyTexImage2D(V.TEXTURE_2D, i || 0, a, t.x, t.y, n, r, 0);
      }),
      (this.copyTextureToTexture = function (t, e, i, n) {
        var r = e.image.width,
          a = e.image.height,
          o = v.convert(i.format),
          s = v.convert(i.type);
        this.setTexture2D(i, 0),
          e.isDataTexture
            ? V.texSubImage2D(V.TEXTURE_2D, n || 0, t.x, t.y, r, a, o, s, e.image.data)
            : V.texSubImage2D(V.TEXTURE_2D, n || 0, t.x, t.y, o, s, e.image);
      });
  }
  function ls(t, e) {
    (this.name = ''), (this.color = new Hi(t)), (this.density = void 0 !== e ? e : 25e-5);
  }
  function us(t, e, i) {
    (this.name = ''),
      (this.color = new Hi(t)),
      (this.near = void 0 !== e ? e : 1),
      (this.far = void 0 !== i ? i : 1e3);
  }
  function ps() {
    bn.call(this),
      (this.type = 'Scene'),
      (this.background = null),
      (this.fog = null),
      (this.overrideMaterial = null),
      (this.autoUpdate = !0);
  }
  function ds(t, e) {
    (this.array = t),
      (this.stride = e),
      (this.count = void 0 !== t ? t.length / e : 0),
      (this.dynamic = !1),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0);
  }
  function fs(t, e, i, n) {
    (this.data = t), (this.itemSize = e), (this.offset = i), (this.normalized = !0 === n);
  }
  function ms(t) {
    jr.call(this),
      (this.type = 'SpriteMaterial'),
      (this.color = new Hi(16777215)),
      (this.map = null),
      (this.rotation = 0),
      (this.sizeAttenuation = !0),
      (this.lights = !1),
      (this.transparent = !0),
      this.setValues(t);
  }
  function gs(t) {
    if ((bn.call(this), (this.type = 'Sprite'), void 0 === xo)) {
      xo = new $n();
      var e = new ds(
        new Float32Array([
          -0.5,
          -0.5,
          0,
          0,
          0,
          0.5,
          -0.5,
          0,
          1,
          0,
          0.5,
          0.5,
          0,
          1,
          1,
          -0.5,
          0.5,
          0,
          0,
          1
        ]),
        5
      );
      xo.setIndex([0, 1, 2, 0, 2, 3]),
        xo.addAttribute('position', new fs(e, 3, 0, !1)),
        xo.addAttribute('uv', new fs(e, 2, 3, !1));
    }
    (this.geometry = xo),
      (this.material = void 0 !== t ? t : new ms()),
      (this.center = new He(0.5, 0.5));
  }
  function vs(t, e, i, n, r, a) {
    Mo.subVectors(t, i).addScalar(0.5).multiply(n),
      void 0 !== r
        ? ((Eo.x = a * Mo.x - r * Mo.y), (Eo.y = r * Mo.x + a * Mo.y))
        : Eo.copy(Mo),
      t.copy(e),
      (t.x += Eo.x),
      (t.y += Eo.y),
      t.applyMatrix4(To);
  }
  function ys() {
    bn.call(this),
      (this.type = 'LOD'),
      Object.defineProperties(this, { levels: { enumerable: !0, value: [] } });
  }
  function xs(t, e) {
    if (
      ((t = t || []),
      (this.bones = t.slice(0)),
      (this.boneMatrices = new Float32Array(16 * this.bones.length)),
      void 0 === e)
    )
      this.calculateInverses();
    else if (this.bones.length === e.length) this.boneInverses = e.slice(0);
    else {
      console.warn('THREE.Skeleton boneInverses is the wrong length.'),
        (this.boneInverses = []);
      for (var i = 0, n = this.bones.length; i < n; i++) this.boneInverses.push(new Ve());
    }
  }
  function bs() {
    bn.call(this), (this.type = 'Bone');
  }
  function _s(t, e) {
    Jr.call(this, t, e),
      (this.type = 'SkinnedMesh'),
      (this.bindMode = 'attached'),
      (this.bindMatrix = new Ve()),
      (this.bindMatrixInverse = new Ve());
    var i = new xs(this.initBones());
    this.bind(i, this.matrixWorld), this.normalizeSkinWeights();
  }
  function ws(t) {
    jr.call(this),
      (this.type = 'LineBasicMaterial'),
      (this.color = new Hi(16777215)),
      (this.linewidth = 1),
      (this.linecap = 'round'),
      (this.linejoin = 'round'),
      (this.lights = !1),
      this.setValues(t);
  }
  function Ms(t, e, i) {
    1 === i &&
      console.error(
        'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.'
      ),
      bn.call(this),
      (this.type = 'Line'),
      (this.geometry = void 0 !== t ? t : new $n()),
      (this.material = void 0 !== e ? e : new ws({ color: 16777215 * Math.random() }));
  }
  function Es(t, e) {
    Ms.call(this, t, e), (this.type = 'LineSegments');
  }
  function Ts(t, e) {
    Ms.call(this, t, e), (this.type = 'LineLoop');
  }
  function Ss(t) {
    jr.call(this),
      (this.type = 'PointsMaterial'),
      (this.color = new Hi(16777215)),
      (this.map = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.morphTargets = !1),
      (this.lights = !1),
      this.setValues(t);
  }
  function As(t, e) {
    bn.call(this),
      (this.type = 'Points'),
      (this.geometry = void 0 !== t ? t : new $n()),
      (this.material = void 0 !== e ? e : new Ss({ color: 16777215 * Math.random() }));
  }
  function Ls(t, e, i, n, r, a, o, s, c) {
    Ei.call(this, t, e, i, n, r, a, o, s, c), (this.generateMipmaps = !1);
  }
  function Rs(t, e, i, n, r, a, o, s, c, h, l, u) {
    Ei.call(this, null, a, o, s, c, h, n, r, l, u),
      (this.image = { width: e, height: i }),
      (this.mipmaps = t),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
  function Ps(t, e, i, n, r, a, o, s, c) {
    Ei.call(this, t, e, i, n, r, a, o, s, c), (this.needsUpdate = !0);
  }
  function Cs(t, e, i, n, r, a, o, s, c, h) {
    if ((h = void 0 !== h ? h : Qt) !== Qt && h !== Kt)
      throw new Error(
        'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat'
      );
    void 0 === i && h === Qt && (i = Ut),
      void 0 === i && h === Kt && (i = jt),
      Ei.call(this, null, n, r, a, o, s, h, i, c),
      (this.image = { width: t, height: e }),
      (this.magFilter = void 0 !== o ? o : At),
      (this.minFilter = void 0 !== s ? s : At),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
  function Os(t) {
    $n.call(this), (this.type = 'WireframeGeometry');
    var e,
      i,
      n,
      r,
      a,
      o,
      s,
      c,
      h,
      l,
      u = [],
      p = [0, 0],
      d = {},
      f = ['a', 'b', 'c'];
    if (t && t.isGeometry) {
      var m = t.faces;
      for (e = 0, n = m.length; e < n; e++) {
        var g = m[e];
        for (i = 0; i < 3; i++)
          (s = g[f[i]]),
            (c = g[f[(i + 1) % 3]]),
            (p[0] = Math.min(s, c)),
            (p[1] = Math.max(s, c)),
            void 0 === d[(h = p[0] + ',' + p[1])] &&
              (d[h] = { index1: p[0], index2: p[1] });
      }
      for (h in d)
        (o = d[h]),
          (l = t.vertices[o.index1]),
          u.push(l.x, l.y, l.z),
          (l = t.vertices[o.index2]),
          u.push(l.x, l.y, l.z);
    } else if (t && t.isBufferGeometry) {
      var v, y, x, b, _, w;
      if (((l = new je()), null !== t.index)) {
        for (
          v = t.attributes.position,
            y = t.index,
            0 === (x = t.groups).length &&
              (x = [{ start: 0, count: y.count, materialIndex: 0 }]),
            r = 0,
            a = x.length;
          r < a;
          ++r
        )
          for (n = (e = (b = x[r]).start) + b.count; e < n; e += 3)
            for (i = 0; i < 3; i++)
              (s = y.getX(e + i)),
                (c = y.getX(e + ((i + 1) % 3))),
                (p[0] = Math.min(s, c)),
                (p[1] = Math.max(s, c)),
                void 0 === d[(h = p[0] + ',' + p[1])] &&
                  (d[h] = { index1: p[0], index2: p[1] });
        for (h in d)
          (o = d[h]),
            l.fromBufferAttribute(v, o.index1),
            u.push(l.x, l.y, l.z),
            l.fromBufferAttribute(v, o.index2),
            u.push(l.x, l.y, l.z);
      } else
        for (e = 0, n = (v = t.attributes.position).count / 3; e < n; e++)
          for (i = 0; i < 3; i++)
            (_ = 3 * e + i),
              l.fromBufferAttribute(v, _),
              u.push(l.x, l.y, l.z),
              (w = 3 * e + ((i + 1) % 3)),
              l.fromBufferAttribute(v, w),
              u.push(l.x, l.y, l.z);
    }
    this.addAttribute('position', new Fn(u, 3));
  }
  function Is(t, e, i) {
    Rn.call(this),
      (this.type = 'ParametricGeometry'),
      (this.parameters = { func: t, slices: e, stacks: i }),
      this.fromBufferGeometry(new Ns(t, e, i)),
      this.mergeVertices();
  }
  function Ns(t, e, i) {
    $n.call(this),
      (this.type = 'ParametricBufferGeometry'),
      (this.parameters = { func: t, slices: e, stacks: i });
    var n,
      r,
      a = [],
      o = [],
      s = [],
      c = [],
      h = new je(),
      l = new je(),
      u = new je(),
      p = new je(),
      d = new je();
    t.length < 3 &&
      console.error(
        'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.'
      );
    var f = e + 1;
    for (n = 0; n <= i; n++) {
      var m = n / i;
      for (r = 0; r <= e; r++) {
        var g = r / e;
        t(g, m, l),
          o.push(l.x, l.y, l.z),
          0 <= g - 1e-5
            ? (t(g - 1e-5, m, u), p.subVectors(l, u))
            : (t(1e-5 + g, m, u), p.subVectors(u, l)),
          0 <= m - 1e-5
            ? (t(g, m - 1e-5, u), d.subVectors(l, u))
            : (t(g, 1e-5 + m, u), d.subVectors(u, l)),
          h.crossVectors(p, d).normalize(),
          s.push(h.x, h.y, h.z),
          c.push(g, m);
      }
    }
    for (n = 0; n < i; n++)
      for (r = 0; r < e; r++) {
        var v = n * f + r,
          y = n * f + r + 1,
          x = (n + 1) * f + r + 1,
          b = (n + 1) * f + r;
        a.push(v, y, b), a.push(y, x, b);
      }
    this.setIndex(a),
      this.addAttribute('position', new Fn(o, 3)),
      this.addAttribute('normal', new Fn(s, 3)),
      this.addAttribute('uv', new Fn(c, 2));
  }
  function Ds(t, e, i, n) {
    Rn.call(this),
      (this.type = 'PolyhedronGeometry'),
      (this.parameters = { vertices: t, indices: e, radius: i, detail: n }),
      this.fromBufferGeometry(new Us(t, e, i, n)),
      this.mergeVertices();
  }
  function Us(n, a, t, e) {
    $n.call(this),
      (this.type = 'PolyhedronBufferGeometry'),
      (this.parameters = { vertices: n, indices: a, radius: t, detail: e }),
      (t = t || 1);
    var l = [],
      u = [];
    function o(t, e, i, n) {
      var r,
        a,
        o = Math.pow(2, n),
        s = [];
      for (r = 0; r <= o; r++) {
        s[r] = [];
        var c = t.clone().lerp(i, r / o),
          h = e.clone().lerp(i, r / o),
          l = o - r;
        for (a = 0; a <= l; a++)
          s[r][a] = 0 === a && r === o ? c : c.clone().lerp(h, a / l);
      }
      for (r = 0; r < o; r++)
        for (a = 0; a < 2 * (o - r) - 1; a++) {
          var u = Math.floor(a / 2);
          a % 2 == 0
            ? (p(s[r][u + 1]), p(s[r + 1][u]), p(s[r][u]))
            : (p(s[r][u + 1]), p(s[r + 1][u + 1]), p(s[r + 1][u]));
        }
    }
    function p(t) {
      l.push(t.x, t.y, t.z);
    }
    function s(t, e) {
      var i = 3 * t;
      (e.x = n[0 + i]), (e.y = n[1 + i]), (e.z = n[2 + i]);
    }
    function d(t, e, i, n) {
      n < 0 && 1 === t.x && (u[e] = t.x - 1),
        0 === i.x && 0 === i.z && (u[e] = n / 2 / Math.PI + 0.5);
    }
    function f(t) {
      return Math.atan2(t.z, -t.x);
    }
    !(function (t) {
      for (var e = new je(), i = new je(), n = new je(), r = 0; r < a.length; r += 3)
        s(a[r + 0], e), s(a[r + 1], i), s(a[r + 2], n), o(e, i, n, t);
    })((e = e || 0)),
      (function (t) {
        for (var e = new je(), i = 0; i < l.length; i += 3)
          (e.x = l[i + 0]),
            (e.y = l[i + 1]),
            (e.z = l[i + 2]),
            e.normalize().multiplyScalar(t),
            (l[i + 0] = e.x),
            (l[i + 1] = e.y),
            (l[i + 2] = e.z);
      })(t),
      (function () {
        for (var t = new je(), e = 0; e < l.length; e += 3) {
          (t.x = l[e + 0]), (t.y = l[e + 1]), (t.z = l[e + 2]);
          var i = f(t) / 2 / Math.PI + 0.5,
            n =
              ((r = t),
              Math.atan2(-r.y, Math.sqrt(r.x * r.x + r.z * r.z)) / Math.PI + 0.5);
          u.push(i, 1 - n);
        }
        var r;
        (function () {
          for (
            var t = new je(),
              e = new je(),
              i = new je(),
              n = new je(),
              r = new He(),
              a = new He(),
              o = new He(),
              s = 0,
              c = 0;
            s < l.length;
            s += 9, c += 6
          ) {
            t.set(l[s + 0], l[s + 1], l[s + 2]),
              e.set(l[s + 3], l[s + 4], l[s + 5]),
              i.set(l[s + 6], l[s + 7], l[s + 8]),
              r.set(u[c + 0], u[c + 1]),
              a.set(u[c + 2], u[c + 3]),
              o.set(u[c + 4], u[c + 5]),
              n.copy(t).add(e).add(i).divideScalar(3);
            var h = f(n);
            d(r, c + 0, t, h), d(a, c + 2, e, h), d(o, c + 4, i, h);
          }
        })(),
          (function () {
            for (var t = 0; t < u.length; t += 6) {
              var e = u[t + 0],
                i = u[t + 2],
                n = u[t + 4],
                r = Math.max(e, i, n),
                a = Math.min(e, i, n);
              0.9 < r &&
                a < 0.1 &&
                (e < 0.2 && (u[t + 0] += 1),
                i < 0.2 && (u[t + 2] += 1),
                n < 0.2 && (u[t + 4] += 1));
            }
          })();
      })(),
      this.addAttribute('position', new Fn(l, 3)),
      this.addAttribute('normal', new Fn(l.slice(), 3)),
      this.addAttribute('uv', new Fn(u, 2)),
      0 === e ? this.computeVertexNormals() : this.normalizeNormals();
  }
  function Bs(t, e) {
    Rn.call(this),
      (this.type = 'TetrahedronGeometry'),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new Fs(t, e)),
      this.mergeVertices();
  }
  function Fs(t, e) {
    Us.call(
      this,
      [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
      [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1],
      t,
      e
    ),
      (this.type = 'TetrahedronBufferGeometry'),
      (this.parameters = { radius: t, detail: e });
  }
  function zs(t, e) {
    Rn.call(this),
      (this.type = 'OctahedronGeometry'),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new Gs(t, e)),
      this.mergeVertices();
  }
  function Gs(t, e) {
    Us.call(
      this,
      [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
      t,
      e
    ),
      (this.type = 'OctahedronBufferGeometry'),
      (this.parameters = { radius: t, detail: e });
  }
  function Hs(t, e) {
    Rn.call(this),
      (this.type = 'IcosahedronGeometry'),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new Vs(t, e)),
      this.mergeVertices();
  }
  function Vs(t, e) {
    var i = (1 + Math.sqrt(5)) / 2;
    Us.call(
      this,
      [
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        0,
        0,
        -1,
        i,
        0,
        1,
        i,
        0,
        -1,
        -i,
        0,
        1,
        -i,
        i,
        0,
        -1,
        i,
        0,
        1,
        -i,
        0,
        -1,
        -i,
        0,
        1
      ],
      [
        0,
        11,
        5,
        0,
        5,
        1,
        0,
        1,
        7,
        0,
        7,
        10,
        0,
        10,
        11,
        1,
        5,
        9,
        5,
        11,
        4,
        11,
        10,
        2,
        10,
        7,
        6,
        7,
        1,
        8,
        3,
        9,
        4,
        3,
        4,
        2,
        3,
        2,
        6,
        3,
        6,
        8,
        3,
        8,
        9,
        4,
        9,
        5,
        2,
        4,
        11,
        6,
        2,
        10,
        8,
        6,
        7,
        9,
        8,
        1
      ],
      t,
      e
    ),
      (this.type = 'IcosahedronBufferGeometry'),
      (this.parameters = { radius: t, detail: e });
  }
  function ks(t, e) {
    Rn.call(this),
      (this.type = 'DodecahedronGeometry'),
      (this.parameters = { radius: t, detail: e }),
      this.fromBufferGeometry(new js(t, e)),
      this.mergeVertices();
  }
  function js(t, e) {
    var i = (1 + Math.sqrt(5)) / 2,
      n = 1 / i;
    Us.call(
      this,
      [
        -1,
        -1,
        -1,
        -1,
        -1,
        1,
        -1,
        1,
        -1,
        -1,
        1,
        1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        1,
        -1,
        1,
        1,
        1,
        0,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        -n,
        -i,
        0,
        -n,
        i,
        0,
        n,
        -i,
        0,
        n,
        i,
        0,
        -i,
        0,
        -n,
        i,
        0,
        -n,
        -i,
        0,
        n,
        i,
        0,
        n
      ],
      [
        3,
        11,
        7,
        3,
        7,
        15,
        3,
        15,
        13,
        7,
        19,
        17,
        7,
        17,
        6,
        7,
        6,
        15,
        17,
        4,
        8,
        17,
        8,
        10,
        17,
        10,
        6,
        8,
        0,
        16,
        8,
        16,
        2,
        8,
        2,
        10,
        0,
        12,
        1,
        0,
        1,
        18,
        0,
        18,
        16,
        6,
        10,
        2,
        6,
        2,
        13,
        6,
        13,
        15,
        2,
        16,
        18,
        2,
        18,
        3,
        2,
        3,
        13,
        18,
        1,
        9,
        18,
        9,
        11,
        18,
        11,
        3,
        4,
        14,
        12,
        4,
        12,
        0,
        4,
        0,
        8,
        11,
        9,
        5,
        11,
        5,
        19,
        11,
        19,
        7,
        19,
        5,
        14,
        19,
        14,
        4,
        19,
        4,
        17,
        1,
        12,
        14,
        1,
        14,
        5,
        1,
        5,
        9
      ],
      t,
      e
    ),
      (this.type = 'DodecahedronBufferGeometry'),
      (this.parameters = { radius: t, detail: e });
  }
  function Ws(t, e, i, n, r, a) {
    Rn.call(this),
      (this.type = 'TubeGeometry'),
      (this.parameters = {
        path: t,
        tubularSegments: e,
        radius: i,
        radialSegments: n,
        closed: r
      }),
      void 0 !== a && console.warn('THREE.TubeGeometry: taper has been removed.');
    var o = new Xs(t, e, i, n, r);
    (this.tangents = o.tangents),
      (this.normals = o.normals),
      (this.binormals = o.binormals),
      this.fromBufferGeometry(o),
      this.mergeVertices();
  }
  function Xs(o, s, c, h, t) {
    $n.call(this),
      (this.type = 'TubeBufferGeometry'),
      (this.parameters = {
        path: o,
        tubularSegments: s,
        radius: c,
        radialSegments: h,
        closed: t
      }),
      (s = s || 64),
      (c = c || 1),
      (h = h || 8),
      (t = t || !1);
    var l = o.computeFrenetFrames(s, t);
    (this.tangents = l.tangents),
      (this.normals = l.normals),
      (this.binormals = l.binormals);
    var r,
      u,
      p = new je(),
      d = new je(),
      e = new He(),
      f = new je(),
      m = [],
      g = [],
      i = [],
      a = [];
    function n(t) {
      f = o.getPointAt(t / s, f);
      var e = l.normals[t],
        i = l.binormals[t];
      for (u = 0; u <= h; u++) {
        var n = (u / h) * Math.PI * 2,
          r = Math.sin(n),
          a = -Math.cos(n);
        (d.x = a * e.x + r * i.x),
          (d.y = a * e.y + r * i.y),
          (d.z = a * e.z + r * i.z),
          d.normalize(),
          g.push(d.x, d.y, d.z),
          (p.x = f.x + c * d.x),
          (p.y = f.y + c * d.y),
          (p.z = f.z + c * d.z),
          m.push(p.x, p.y, p.z);
      }
    }
    !(function () {
      for (r = 0; r < s; r++) n(r);
      n(!1 === t ? s : 0),
        (function () {
          for (r = 0; r <= s; r++)
            for (u = 0; u <= h; u++) (e.x = r / s), (e.y = u / h), i.push(e.x, e.y);
        })(),
        (function () {
          for (u = 1; u <= s; u++)
            for (r = 1; r <= h; r++) {
              var t = (h + 1) * (u - 1) + (r - 1),
                e = (h + 1) * u + (r - 1),
                i = (h + 1) * u + r,
                n = (h + 1) * (u - 1) + r;
              a.push(t, e, n), a.push(e, i, n);
            }
        })();
    })(),
      this.setIndex(a),
      this.addAttribute('position', new Fn(m, 3)),
      this.addAttribute('normal', new Fn(g, 3)),
      this.addAttribute('uv', new Fn(i, 2));
  }
  function qs(t, e, i, n, r, a, o) {
    Rn.call(this),
      (this.type = 'TorusKnotGeometry'),
      (this.parameters = {
        radius: t,
        tube: e,
        tubularSegments: i,
        radialSegments: n,
        p: r,
        q: a
      }),
      void 0 !== o &&
        console.warn(
          'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.'
        ),
      this.fromBufferGeometry(new Ys(t, e, i, n, r, a)),
      this.mergeVertices();
  }
  function Ys(t, e, i, n, r, a) {
    $n.call(this),
      (this.type = 'TorusKnotBufferGeometry'),
      (this.parameters = {
        radius: t,
        tube: e,
        tubularSegments: i,
        radialSegments: n,
        p: r,
        q: a
      }),
      (t = t || 1),
      (e = e || 0.4),
      (i = Math.floor(i) || 64),
      (n = Math.floor(n) || 8),
      (r = r || 2),
      (a = a || 3);
    var o,
      s,
      c = [],
      h = [],
      l = [],
      u = [],
      p = new je(),
      d = new je(),
      f = new je(),
      m = new je(),
      g = new je(),
      v = new je(),
      y = new je();
    for (o = 0; o <= i; ++o) {
      var x = (o / i) * r * Math.PI * 2;
      for (
        A(x, r, a, t, f),
          A(0.01 + x, r, a, t, m),
          v.subVectors(m, f),
          y.addVectors(m, f),
          g.crossVectors(v, y),
          y.crossVectors(g, v),
          g.normalize(),
          y.normalize(),
          s = 0;
        s <= n;
        ++s
      ) {
        var b = (s / n) * Math.PI * 2,
          _ = -e * Math.cos(b),
          w = e * Math.sin(b);
        (p.x = f.x + (_ * y.x + w * g.x)),
          (p.y = f.y + (_ * y.y + w * g.y)),
          (p.z = f.z + (_ * y.z + w * g.z)),
          h.push(p.x, p.y, p.z),
          d.subVectors(p, f).normalize(),
          l.push(d.x, d.y, d.z),
          u.push(o / i),
          u.push(s / n);
      }
    }
    for (s = 1; s <= i; s++)
      for (o = 1; o <= n; o++) {
        var M = (n + 1) * (s - 1) + (o - 1),
          E = (n + 1) * s + (o - 1),
          T = (n + 1) * s + o,
          S = (n + 1) * (s - 1) + o;
        c.push(M, E, S), c.push(E, T, S);
      }
    function A(t, e, i, n, r) {
      var a = Math.cos(t),
        o = Math.sin(t),
        s = (i / e) * t,
        c = Math.cos(s);
      (r.x = n * (2 + c) * 0.5 * a),
        (r.y = n * (2 + c) * o * 0.5),
        (r.z = n * Math.sin(s) * 0.5);
    }
    this.setIndex(c),
      this.addAttribute('position', new Fn(h, 3)),
      this.addAttribute('normal', new Fn(l, 3)),
      this.addAttribute('uv', new Fn(u, 2));
  }
  function Js(t, e, i, n, r) {
    Rn.call(this),
      (this.type = 'TorusGeometry'),
      (this.parameters = {
        radius: t,
        tube: e,
        radialSegments: i,
        tubularSegments: n,
        arc: r
      }),
      this.fromBufferGeometry(new Zs(t, e, i, n, r)),
      this.mergeVertices();
  }
  function Zs(t, e, i, n, r) {
    $n.call(this),
      (this.type = 'TorusBufferGeometry'),
      (this.parameters = {
        radius: t,
        tube: e,
        radialSegments: i,
        tubularSegments: n,
        arc: r
      }),
      (t = t || 1),
      (e = e || 0.4),
      (i = Math.floor(i) || 8),
      (n = Math.floor(n) || 6),
      (r = r || 2 * Math.PI);
    var a,
      o,
      s = [],
      c = [],
      h = [],
      l = [],
      u = new je(),
      p = new je(),
      d = new je();
    for (a = 0; a <= i; a++)
      for (o = 0; o <= n; o++) {
        var f = (o / n) * r,
          m = (a / i) * Math.PI * 2;
        (p.x = (t + e * Math.cos(m)) * Math.cos(f)),
          (p.y = (t + e * Math.cos(m)) * Math.sin(f)),
          (p.z = e * Math.sin(m)),
          c.push(p.x, p.y, p.z),
          (u.x = t * Math.cos(f)),
          (u.y = t * Math.sin(f)),
          d.subVectors(p, u).normalize(),
          h.push(d.x, d.y, d.z),
          l.push(o / n),
          l.push(a / i);
      }
    for (a = 1; a <= i; a++)
      for (o = 1; o <= n; o++) {
        var g = (n + 1) * a + o - 1,
          v = (n + 1) * (a - 1) + o - 1,
          y = (n + 1) * (a - 1) + o,
          x = (n + 1) * a + o;
        s.push(g, v, x), s.push(v, y, x);
      }
    this.setIndex(s),
      this.addAttribute('position', new Fn(c, 3)),
      this.addAttribute('normal', new Fn(h, 3)),
      this.addAttribute('uv', new Fn(l, 2));
  }
  (((Qo.prototype = Object.create(
    jr.prototype
  )).constructor = Qo).prototype.isMeshDepthMaterial = !0),
    (Qo.prototype.copy = function (t) {
      return (
        jr.prototype.copy.call(this, t),
        (this.depthPacking = t.depthPacking),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        this
      );
    }),
    (((Ko.prototype = Object.create(
      jr.prototype
    )).constructor = Ko).prototype.isMeshDistanceMaterial = !0),
    (Ko.prototype.copy = function (t) {
      return (
        jr.prototype.copy.call(this, t),
        this.referencePosition.copy(t.referencePosition),
        (this.nearDistance = t.nearDistance),
        (this.farDistance = t.farDistance),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.map = t.map),
        (this.alphaMap = t.alphaMap),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        this
      );
    }),
    (ns.prototype = Object.assign(Object.create(bn.prototype), {
      constructor: ns,
      isGroup: !0
    })),
    (rs.prototype = Object.assign(Object.create(bn.prototype), {
      constructor: rs,
      isCamera: !0,
      copy: function (t, e) {
        return (
          bn.prototype.copy.call(this, t, e),
          this.matrixWorldInverse.copy(t.matrixWorldInverse),
          this.projectionMatrix.copy(t.projectionMatrix),
          this.projectionMatrixInverse.copy(t.projectionMatrixInverse),
          this
        );
      },
      getWorldDirection: function (t) {
        void 0 === t &&
          (console.warn('THREE.Camera: .getWorldDirection() target is now required'),
          (t = new je())),
          this.updateMatrixWorld(!0);
        var e = this.matrixWorld.elements;
        return t.set(-e[8], -e[9], -e[10]).normalize();
      },
      updateMatrixWorld: function (t) {
        bn.prototype.updateMatrixWorld.call(this, t),
          this.matrixWorldInverse.getInverse(this.matrixWorld);
      },
      clone: function () {
        return new this.constructor().copy(this);
      }
    })),
    (as.prototype = Object.assign(Object.create(rs.prototype), {
      constructor: as,
      isPerspectiveCamera: !0,
      copy: function (t, e) {
        return (
          rs.prototype.copy.call(this, t, e),
          (this.fov = t.fov),
          (this.zoom = t.zoom),
          (this.near = t.near),
          (this.far = t.far),
          (this.focus = t.focus),
          (this.aspect = t.aspect),
          (this.view = null === t.view ? null : Object.assign({}, t.view)),
          (this.filmGauge = t.filmGauge),
          (this.filmOffset = t.filmOffset),
          this
        );
      },
      setFocalLength: function (t) {
        var e = (0.5 * this.getFilmHeight()) / t;
        (this.fov = 2 * Ge.RAD2DEG * Math.atan(e)), this.updateProjectionMatrix();
      },
      getFocalLength: function () {
        var t = Math.tan(0.5 * Ge.DEG2RAD * this.fov);
        return (0.5 * this.getFilmHeight()) / t;
      },
      getEffectiveFOV: function () {
        return (
          2 * Ge.RAD2DEG * Math.atan(Math.tan(0.5 * Ge.DEG2RAD * this.fov) / this.zoom)
        );
      },
      getFilmWidth: function () {
        return this.filmGauge * Math.min(this.aspect, 1);
      },
      getFilmHeight: function () {
        return this.filmGauge / Math.max(this.aspect, 1);
      },
      setViewOffset: function (t, e, i, n, r, a) {
        (this.aspect = t / e),
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1
            }),
          (this.view.enabled = !0),
          (this.view.fullWidth = t),
          (this.view.fullHeight = e),
          (this.view.offsetX = i),
          (this.view.offsetY = n),
          (this.view.width = r),
          (this.view.height = a),
          this.updateProjectionMatrix();
      },
      clearViewOffset: function () {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function () {
        var t = this.near,
          e = (t * Math.tan(0.5 * Ge.DEG2RAD * this.fov)) / this.zoom,
          i = 2 * e,
          n = this.aspect * i,
          r = -0.5 * n,
          a = this.view;
        if (null !== this.view && this.view.enabled) {
          var o = a.fullWidth,
            s = a.fullHeight;
          (r += (a.offsetX * n) / o),
            (e -= (a.offsetY * i) / s),
            (n *= a.width / o),
            (i *= a.height / s);
        }
        var c = this.filmOffset;
        0 !== c && (r += (t * c) / this.getFilmWidth()),
          this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far),
          this.projectionMatrixInverse.getInverse(this.projectionMatrix);
      },
      toJSON: function (t) {
        var e = bn.prototype.toJSON.call(this, t);
        return (
          (e.object.fov = this.fov),
          (e.object.zoom = this.zoom),
          (e.object.near = this.near),
          (e.object.far = this.far),
          (e.object.focus = this.focus),
          (e.object.aspect = this.aspect),
          null !== this.view && (e.object.view = Object.assign({}, this.view)),
          (e.object.filmGauge = this.filmGauge),
          (e.object.filmOffset = this.filmOffset),
          e
        );
      }
    })),
    (os.prototype = Object.assign(Object.create(as.prototype), {
      constructor: os,
      isArrayCamera: !0
    })),
    (ls.prototype.isFogExp2 = !0),
    (ls.prototype.clone = function () {
      return new ls(this.color, this.density);
    }),
    (ls.prototype.toJSON = function () {
      return { type: 'FogExp2', color: this.color.getHex(), density: this.density };
    }),
    (us.prototype.isFog = !0),
    (us.prototype.clone = function () {
      return new us(this.color, this.near, this.far);
    }),
    (us.prototype.toJSON = function () {
      return { type: 'Fog', color: this.color.getHex(), near: this.near, far: this.far };
    }),
    (ps.prototype = Object.assign(Object.create(bn.prototype), {
      constructor: ps,
      copy: function (t, e) {
        return (
          bn.prototype.copy.call(this, t, e),
          null !== t.background && (this.background = t.background.clone()),
          null !== t.fog && (this.fog = t.fog.clone()),
          null !== t.overrideMaterial &&
            (this.overrideMaterial = t.overrideMaterial.clone()),
          (this.autoUpdate = t.autoUpdate),
          (this.matrixAutoUpdate = t.matrixAutoUpdate),
          this
        );
      },
      toJSON: function (t) {
        var e = bn.prototype.toJSON.call(this, t);
        return (
          null !== this.background && (e.object.background = this.background.toJSON(t)),
          null !== this.fog && (e.object.fog = this.fog.toJSON()),
          e
        );
      }
    })),
    Object.defineProperty(ds.prototype, 'needsUpdate', {
      set: function (t) {
        !0 === t && this.version++;
      }
    }),
    Object.assign(ds.prototype, {
      isInterleavedBuffer: !0,
      onUploadCallback: function () {},
      setArray: function (t) {
        if (Array.isArray(t))
          throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
        return (
          (this.count = void 0 !== t ? t.length / this.stride : 0), (this.array = t), this
        );
      },
      setDynamic: function (t) {
        return (this.dynamic = t), this;
      },
      copy: function (t) {
        return (
          (this.array = new t.array.constructor(t.array)),
          (this.count = t.count),
          (this.stride = t.stride),
          (this.dynamic = t.dynamic),
          this
        );
      },
      copyAt: function (t, e, i) {
        (t *= this.stride), (i *= e.stride);
        for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
        return this;
      },
      set: function (t, e) {
        return void 0 === e && (e = 0), this.array.set(t, e), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      onUpload: function (t) {
        return (this.onUploadCallback = t), this;
      }
    }),
    Object.defineProperties(fs.prototype, {
      count: {
        get: function () {
          return this.data.count;
        }
      },
      array: {
        get: function () {
          return this.data.array;
        }
      }
    }),
    Object.assign(fs.prototype, {
      isInterleavedBufferAttribute: !0,
      setX: function (t, e) {
        return (this.data.array[t * this.data.stride + this.offset] = e), this;
      },
      setY: function (t, e) {
        return (this.data.array[t * this.data.stride + this.offset + 1] = e), this;
      },
      setZ: function (t, e) {
        return (this.data.array[t * this.data.stride + this.offset + 2] = e), this;
      },
      setW: function (t, e) {
        return (this.data.array[t * this.data.stride + this.offset + 3] = e), this;
      },
      getX: function (t) {
        return this.data.array[t * this.data.stride + this.offset];
      },
      getY: function (t) {
        return this.data.array[t * this.data.stride + this.offset + 1];
      },
      getZ: function (t) {
        return this.data.array[t * this.data.stride + this.offset + 2];
      },
      getW: function (t) {
        return this.data.array[t * this.data.stride + this.offset + 3];
      },
      setXY: function (t, e, i) {
        return (
          (t = t * this.data.stride + this.offset),
          (this.data.array[t + 0] = e),
          (this.data.array[t + 1] = i),
          this
        );
      },
      setXYZ: function (t, e, i, n) {
        return (
          (t = t * this.data.stride + this.offset),
          (this.data.array[t + 0] = e),
          (this.data.array[t + 1] = i),
          (this.data.array[t + 2] = n),
          this
        );
      },
      setXYZW: function (t, e, i, n, r) {
        return (
          (t = t * this.data.stride + this.offset),
          (this.data.array[t + 0] = e),
          (this.data.array[t + 1] = i),
          (this.data.array[t + 2] = n),
          (this.data.array[t + 3] = r),
          this
        );
      }
    }),
    (((ms.prototype = Object.create(
      jr.prototype
    )).constructor = ms).prototype.isSpriteMaterial = !0),
    (ms.prototype.copy = function (t) {
      return (
        jr.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.rotation = t.rotation),
        (this.sizeAttenuation = t.sizeAttenuation),
        this
      );
    }),
    (gs.prototype = Object.assign(Object.create(bn.prototype), {
      constructor: gs,
      isSprite: !0,
      raycast:
        ((bo = new je()),
        (_o = new je()),
        (wo = new je()),
        (Mo = new He()),
        (Eo = new He()),
        (To = new Ve()),
        (So = new je()),
        (Ao = new je()),
        (Lo = new je()),
        (Ro = new He()),
        (Po = new He()),
        (Co = new He()),
        function (t, e) {
          _o.setFromMatrixScale(this.matrixWorld),
            To.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld),
            wo.setFromMatrixPosition(this.modelViewMatrix);
          var i,
            n,
            r = this.material.rotation;
          0 !== r && ((n = Math.cos(r)), (i = Math.sin(r)));
          var a = this.center;
          vs(So.set(-0.5, -0.5, 0), wo, a, _o, i, n),
            vs(Ao.set(0.5, -0.5, 0), wo, a, _o, i, n),
            vs(Lo.set(0.5, 0.5, 0), wo, a, _o, i, n),
            Ro.set(0, 0),
            Po.set(1, 0),
            Co.set(1, 1);
          var o = t.ray.intersectTriangle(So, Ao, Lo, !1, bo);
          if (
            null !== o ||
            (vs(Ao.set(-0.5, 0.5, 0), wo, a, _o, i, n),
            Po.set(0, 1),
            null !== (o = t.ray.intersectTriangle(So, Lo, Ao, !1, bo)))
          ) {
            var s = t.ray.origin.distanceTo(bo);
            s < t.near ||
              s > t.far ||
              e.push({
                distance: s,
                point: bo.clone(),
                uv: qr.getUV(bo, So, Ao, Lo, Ro, Po, Co, new He()),
                face: null,
                object: this
              });
          }
        }),
      clone: function () {
        return new this.constructor(this.material).copy(this);
      },
      copy: function (t) {
        return (
          bn.prototype.copy.call(this, t),
          void 0 !== t.center && this.center.copy(t.center),
          this
        );
      }
    })),
    (ys.prototype = Object.assign(Object.create(bn.prototype), {
      constructor: ys,
      copy: function (t) {
        bn.prototype.copy.call(this, t, !1);
        for (var e = t.levels, i = 0, n = e.length; i < n; i++) {
          var r = e[i];
          this.addLevel(r.object.clone(), r.distance);
        }
        return this;
      },
      addLevel: function (t, e) {
        void 0 === e && (e = 0), (e = Math.abs(e));
        for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++);
        i.splice(n, 0, { distance: e, object: t }), this.add(t);
      },
      getObjectForDistance: function (t) {
        for (
          var e = this.levels, i = 1, n = e.length;
          i < n && !(t < e[i].distance);
          i++
        );
        return e[i - 1].object;
      },
      raycast:
        ((No = new je()),
        function (t, e) {
          No.setFromMatrixPosition(this.matrixWorld);
          var i = t.ray.origin.distanceTo(No);
          this.getObjectForDistance(i).raycast(t, e);
        }),
      update:
        ((Oo = new je()),
        (Io = new je()),
        function (t) {
          var e = this.levels;
          if (1 < e.length) {
            Oo.setFromMatrixPosition(t.matrixWorld),
              Io.setFromMatrixPosition(this.matrixWorld);
            var i = Oo.distanceTo(Io);
            e[0].object.visible = !0;
            for (var n = 1, r = e.length; n < r && i >= e[n].distance; n++)
              (e[n - 1].object.visible = !1), (e[n].object.visible = !0);
            for (; n < r; n++) e[n].object.visible = !1;
          }
        }),
      toJSON: function (t) {
        var e = bn.prototype.toJSON.call(this, t);
        e.object.levels = [];
        for (var i = this.levels, n = 0, r = i.length; n < r; n++) {
          var a = i[n];
          e.object.levels.push({ object: a.object.uuid, distance: a.distance });
        }
        return e;
      }
    })),
    Object.assign(xs.prototype, {
      calculateInverses: function () {
        this.boneInverses = [];
        for (var t = 0, e = this.bones.length; t < e; t++) {
          var i = new Ve();
          this.bones[t] && i.getInverse(this.bones[t].matrixWorld),
            this.boneInverses.push(i);
        }
      },
      pose: function () {
        var t, e, i;
        for (e = 0, i = this.bones.length; e < i; e++)
          (t = this.bones[e]) && t.matrixWorld.getInverse(this.boneInverses[e]);
        for (e = 0, i = this.bones.length; e < i; e++)
          (t = this.bones[e]) &&
            (t.parent && t.parent.isBone
              ? (t.matrix.getInverse(t.parent.matrixWorld),
                t.matrix.multiply(t.matrixWorld))
              : t.matrix.copy(t.matrixWorld),
            t.matrix.decompose(t.position, t.quaternion, t.scale));
      },
      update:
        ((Do = new Ve()),
        (Uo = new Ve()),
        function () {
          for (
            var t = this.bones,
              e = this.boneInverses,
              i = this.boneMatrices,
              n = this.boneTexture,
              r = 0,
              a = t.length;
            r < a;
            r++
          ) {
            var o = t[r] ? t[r].matrixWorld : Uo;
            Do.multiplyMatrices(o, e[r]), Do.toArray(i, 16 * r);
          }
          void 0 !== n && (n.needsUpdate = !0);
        }),
      clone: function () {
        return new xs(this.bones, this.boneInverses);
      },
      getBoneByName: function (t) {
        for (var e = 0, i = this.bones.length; e < i; e++) {
          var n = this.bones[e];
          if (n.name === t) return n;
        }
      }
    }),
    (bs.prototype = Object.assign(Object.create(bn.prototype), {
      constructor: bs,
      isBone: !0
    })),
    (_s.prototype = Object.assign(Object.create(Jr.prototype), {
      constructor: _s,
      isSkinnedMesh: !0,
      initBones: function () {
        var t,
          e,
          i,
          n,
          r = [];
        if (this.geometry && void 0 !== this.geometry.bones) {
          for (i = 0, n = this.geometry.bones.length; i < n; i++)
            (e = this.geometry.bones[i]),
              (t = new bs()),
              r.push(t),
              (t.name = e.name),
              t.position.fromArray(e.pos),
              t.quaternion.fromArray(e.rotq),
              void 0 !== e.scl && t.scale.fromArray(e.scl);
          for (i = 0, n = this.geometry.bones.length; i < n; i++)
            -1 !== (e = this.geometry.bones[i]).parent &&
            null !== e.parent &&
            void 0 !== r[e.parent]
              ? r[e.parent].add(r[i])
              : this.add(r[i]);
        }
        return this.updateMatrixWorld(!0), r;
      },
      bind: function (t, e) {
        (this.skeleton = t),
          void 0 === e &&
            (this.updateMatrixWorld(!0),
            this.skeleton.calculateInverses(),
            (e = this.matrixWorld)),
          this.bindMatrix.copy(e),
          this.bindMatrixInverse.getInverse(e);
      },
      pose: function () {
        this.skeleton.pose();
      },
      normalizeSkinWeights: function () {
        var t, e;
        if (this.geometry && this.geometry.isGeometry)
          for (e = 0; e < this.geometry.skinWeights.length; e++) {
            var i = this.geometry.skinWeights[e];
            (t = 1 / i.manhattanLength()) !== 1 / 0
              ? i.multiplyScalar(t)
              : i.set(1, 0, 0, 0);
          }
        else if (this.geometry && this.geometry.isBufferGeometry) {
          var n = new Ti(),
            r = this.geometry.attributes.skinWeight;
          for (e = 0; e < r.count; e++)
            (n.x = r.getX(e)),
              (n.y = r.getY(e)),
              (n.z = r.getZ(e)),
              (n.w = r.getW(e)),
              (t = 1 / n.manhattanLength()) !== 1 / 0
                ? n.multiplyScalar(t)
                : n.set(1, 0, 0, 0),
              r.setXYZW(e, n.x, n.y, n.z, n.w);
        }
      },
      updateMatrixWorld: function (t) {
        Jr.prototype.updateMatrixWorld.call(this, t),
          'attached' === this.bindMode
            ? this.bindMatrixInverse.getInverse(this.matrixWorld)
            : 'detached' === this.bindMode
            ? this.bindMatrixInverse.getInverse(this.bindMatrix)
            : console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
      },
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      }
    })),
    (((ws.prototype = Object.create(
      jr.prototype
    )).constructor = ws).prototype.isLineBasicMaterial = !0),
    (ws.prototype.copy = function (t) {
      return (
        jr.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.linewidth = t.linewidth),
        (this.linecap = t.linecap),
        (this.linejoin = t.linejoin),
        this
      );
    }),
    (Ms.prototype = Object.assign(Object.create(bn.prototype), {
      constructor: Ms,
      isLine: !0,
      computeLineDistances:
        ((Go = new je()),
        (Ho = new je()),
        function () {
          var t = this.geometry;
          if (t.isBufferGeometry)
            if (null === t.index) {
              for (var e = t.attributes.position, i = [0], n = 1, r = e.count; n < r; n++)
                Go.fromBufferAttribute(e, n - 1),
                  Ho.fromBufferAttribute(e, n),
                  (i[n] = i[n - 1]),
                  (i[n] += Go.distanceTo(Ho));
              t.addAttribute('lineDistance', new Fn(i, 1));
            } else
              console.warn(
                'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
              );
          else if (t.isGeometry) {
            var a = t.vertices;
            for ((i = t.lineDistances)[0] = 0, n = 1, r = a.length; n < r; n++)
              (i[n] = i[n - 1]), (i[n] += a[n - 1].distanceTo(a[n]));
          }
          return this;
        }),
      raycast:
        ((Bo = new Ve()),
        (Fo = new Xr()),
        (zo = new Oi()),
        function (t, e) {
          var i = t.linePrecision,
            n = this.geometry,
            r = this.matrixWorld;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            zo.copy(n.boundingSphere),
            zo.applyMatrix4(r),
            (zo.radius += i),
            !1 !== t.ray.intersectsSphere(zo))
          ) {
            Bo.getInverse(r), Fo.copy(t.ray).applyMatrix4(Bo);
            var a = i / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              o = a * a,
              s = new je(),
              c = new je(),
              h = new je(),
              l = new je(),
              u = this && this.isLineSegments ? 2 : 1;
            if (n.isBufferGeometry) {
              var p = n.index,
                d = n.attributes.position.array;
              if (null !== p)
                for (var f = p.array, m = 0, g = f.length - 1; m < g; m += u) {
                  var v = f[m],
                    y = f[m + 1];
                  s.fromArray(d, 3 * v),
                    c.fromArray(d, 3 * y),
                    o < Fo.distanceSqToSegment(s, c, l, h) ||
                      (l.applyMatrix4(this.matrixWorld),
                      (_ = t.ray.origin.distanceTo(l)) < t.near ||
                        _ > t.far ||
                        e.push({
                          distance: _,
                          point: h.clone().applyMatrix4(this.matrixWorld),
                          index: m,
                          face: null,
                          faceIndex: null,
                          object: this
                        }));
                }
              else
                for (m = 0, g = d.length / 3 - 1; m < g; m += u)
                  s.fromArray(d, 3 * m),
                    c.fromArray(d, 3 * m + 3),
                    o < Fo.distanceSqToSegment(s, c, l, h) ||
                      (l.applyMatrix4(this.matrixWorld),
                      (_ = t.ray.origin.distanceTo(l)) < t.near ||
                        _ > t.far ||
                        e.push({
                          distance: _,
                          point: h.clone().applyMatrix4(this.matrixWorld),
                          index: m,
                          face: null,
                          faceIndex: null,
                          object: this
                        }));
            } else if (n.isGeometry) {
              var x = n.vertices,
                b = x.length;
              for (m = 0; m < b - 1; m += u) {
                var _;
                o < Fo.distanceSqToSegment(x[m], x[m + 1], l, h) ||
                  (l.applyMatrix4(this.matrixWorld),
                  (_ = t.ray.origin.distanceTo(l)) < t.near ||
                    _ > t.far ||
                    e.push({
                      distance: _,
                      point: h.clone().applyMatrix4(this.matrixWorld),
                      index: m,
                      face: null,
                      faceIndex: null,
                      object: this
                    }));
              }
            }
          }
        }),
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      }
    })),
    (Es.prototype = Object.assign(Object.create(Ms.prototype), {
      constructor: Es,
      isLineSegments: !0,
      computeLineDistances:
        ((Vo = new je()),
        (ko = new je()),
        function () {
          var t = this.geometry;
          if (t.isBufferGeometry)
            if (null === t.index) {
              for (
                var e = t.attributes.position, i = [], n = 0, r = e.count;
                n < r;
                n += 2
              )
                Vo.fromBufferAttribute(e, n),
                  ko.fromBufferAttribute(e, n + 1),
                  (i[n] = 0 === n ? 0 : i[n - 1]),
                  (i[n + 1] = i[n] + Vo.distanceTo(ko));
              t.addAttribute('lineDistance', new Fn(i, 1));
            } else
              console.warn(
                'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.'
              );
          else if (t.isGeometry) {
            var a = t.vertices;
            for (i = t.lineDistances, n = 0, r = a.length; n < r; n += 2)
              Vo.copy(a[n]),
                ko.copy(a[n + 1]),
                (i[n] = 0 === n ? 0 : i[n - 1]),
                (i[n + 1] = i[n] + Vo.distanceTo(ko));
          }
          return this;
        })
    })),
    (Ts.prototype = Object.assign(Object.create(Ms.prototype), {
      constructor: Ts,
      isLineLoop: !0
    })),
    (((Ss.prototype = Object.create(
      jr.prototype
    )).constructor = Ss).prototype.isPointsMaterial = !0),
    (Ss.prototype.copy = function (t) {
      return (
        jr.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.size = t.size),
        (this.sizeAttenuation = t.sizeAttenuation),
        (this.morphTargets = t.morphTargets),
        this
      );
    }),
    (As.prototype = Object.assign(Object.create(bn.prototype), {
      constructor: As,
      isPoints: !0,
      raycast:
        ((jo = new Ve()),
        (Wo = new Xr()),
        (Xo = new Oi()),
        function (r, a) {
          var o = this,
            t = this.geometry,
            s = this.matrixWorld,
            e = r.params.Points.threshold;
          if (
            (null === t.boundingSphere && t.computeBoundingSphere(),
            Xo.copy(t.boundingSphere),
            Xo.applyMatrix4(s),
            (Xo.radius += e),
            !1 !== r.ray.intersectsSphere(Xo))
          ) {
            jo.getInverse(s), Wo.copy(r.ray).applyMatrix4(jo);
            var i = e / ((this.scale.x + this.scale.y + this.scale.z) / 3),
              c = i * i,
              n = new je(),
              h = new je();
            if (t.isBufferGeometry) {
              var l = t.index,
                u = t.attributes.position.array;
              if (null !== l)
                for (var p = l.array, d = 0, f = p.length; d < f; d++) {
                  var m = p[d];
                  n.fromArray(u, 3 * m), y(n, m);
                }
              else {
                d = 0;
                for (var g = u.length / 3; d < g; d++) n.fromArray(u, 3 * d), y(n, d);
              }
            } else {
              var v = t.vertices;
              for (d = 0, g = v.length; d < g; d++) y(v[d], d);
            }
          }
          function y(t, e) {
            var i = Wo.distanceSqToPoint(t);
            if (i < c) {
              Wo.closestPointToPoint(t, h), h.applyMatrix4(s);
              var n = r.ray.origin.distanceTo(h);
              if (n < r.near || n > r.far) return;
              a.push({
                distance: n,
                distanceToRay: Math.sqrt(i),
                point: h.clone(),
                index: e,
                face: null,
                object: o
              });
            }
          }
        }),
      clone: function () {
        return new this.constructor(this.geometry, this.material).copy(this);
      }
    })),
    (Ls.prototype = Object.assign(Object.create(Ei.prototype), {
      constructor: Ls,
      isVideoTexture: !0,
      update: function () {
        var t = this.image;
        t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0);
      }
    })),
    (((Rs.prototype = Object.create(
      Ei.prototype
    )).constructor = Rs).prototype.isCompressedTexture = !0),
    (((Ps.prototype = Object.create(
      Ei.prototype
    )).constructor = Ps).prototype.isCanvasTexture = !0),
    (((Cs.prototype = Object.create(
      Ei.prototype
    )).constructor = Cs).prototype.isDepthTexture = !0),
    ((Os.prototype = Object.create($n.prototype)).constructor = Os),
    ((Is.prototype = Object.create(Rn.prototype)).constructor = Is),
    ((Ns.prototype = Object.create($n.prototype)).constructor = Ns),
    ((Ds.prototype = Object.create(Rn.prototype)).constructor = Ds),
    ((Us.prototype = Object.create($n.prototype)).constructor = Us),
    ((Bs.prototype = Object.create(Rn.prototype)).constructor = Bs),
    ((Fs.prototype = Object.create(Us.prototype)).constructor = Fs),
    ((zs.prototype = Object.create(Rn.prototype)).constructor = zs),
    ((Gs.prototype = Object.create(Us.prototype)).constructor = Gs),
    ((Hs.prototype = Object.create(Rn.prototype)).constructor = Hs),
    ((Vs.prototype = Object.create(Us.prototype)).constructor = Vs),
    ((ks.prototype = Object.create(Rn.prototype)).constructor = ks),
    ((js.prototype = Object.create(Us.prototype)).constructor = js),
    ((Ws.prototype = Object.create(Rn.prototype)).constructor = Ws),
    ((Xs.prototype = Object.create($n.prototype)).constructor = Xs),
    ((qs.prototype = Object.create(Rn.prototype)).constructor = qs),
    ((Ys.prototype = Object.create($n.prototype)).constructor = Ys),
    ((Js.prototype = Object.create(Rn.prototype)).constructor = Js),
    ((Zs.prototype = Object.create($n.prototype)).constructor = Zs);
  var Qs = function (t, e, i) {
    i = i || 2;
    var n,
      r,
      a,
      o,
      s,
      c,
      h,
      l = e && e.length,
      u = l ? e[0] * i : t.length,
      p = Ks(t, 0, u, i, !0),
      d = [];
    if (!p) return d;
    if (
      (l &&
        (p = (function (t, e, i, n) {
          var r,
            a,
            o,
            s,
            c,
            h = [];
          for (r = 0, a = e.length; r < a; r++)
            (o = e[r] * n),
              (s = r < a - 1 ? e[r + 1] * n : t.length),
              (c = Ks(t, o, s, n, !1)) === c.next && (c.steiner = !0),
              h.push(cc(c));
          for (h.sort(ac), r = 0; r < h.length; r++) oc(h[r], i), (i = $s(i, i.next));
          return i;
        })(t, e, p, i)),
      t.length > 80 * i)
    ) {
      (n = a = t[0]), (r = o = t[1]);
      for (var f = i; f < u; f += i)
        (s = t[f]) < n && (n = s),
          (c = t[f + 1]) < r && (r = c),
          a < s && (a = s),
          o < c && (o = c);
      h = 0 !== (h = Math.max(a - n, o - r)) ? 1 / h : 0;
    }
    return tc(p, d, i, n, r, h), d;
  };
  function Ks(t, e, i, n, r) {
    var a, o;
    if (
      r ===
      0 <
        (function (t, e, i, n) {
          for (var r = 0, a = e, o = i - n; a < i; a += n)
            (r += (t[o] - t[a]) * (t[a + 1] + t[o + 1])), (o = a);
          return r;
        })(t, e, i, n)
    )
      for (a = e; a < i; a += n) o = mc(a, t[a], t[a + 1], o);
    else for (a = i - n; e <= a; a -= n) o = mc(a, t[a], t[a + 1], o);
    return o && uc(o, o.next) && (gc(o), (o = o.next)), o;
  }
  function $s(t, e) {
    if (!t) return t;
    e = e || t;
    var i,
      n = t;
    do {
      if (((i = !1), n.steiner || (!uc(n, n.next) && 0 !== lc(n.prev, n, n.next))))
        n = n.next;
      else {
        if ((gc(n), (n = e = n.prev) === n.next)) break;
        i = !0;
      }
    } while (i || n !== e);
    return e;
  }
  function tc(t, e, i, n, r, a, o) {
    if (t) {
      !o &&
        a &&
        (function (t, e, i, n) {
          var r = t;
          for (
            ;
            null === r.z && (r.z = sc(r.x, r.y, e, i, n)),
              (r.prevZ = r.prev),
              (r.nextZ = r.next),
              (r = r.next),
              r !== t;

          );
          (r.prevZ.nextZ = null),
            (r.prevZ = null),
            (function (t) {
              var e,
                i,
                n,
                r,
                a,
                o,
                s,
                c,
                h = 1;
              do {
                for (i = t, a = t = null, o = 0; i; ) {
                  for (o++, n = i, e = s = 0; e < h && (s++, (n = n.nextZ)); e++);
                  for (c = h; 0 < s || (0 < c && n); )
                    0 !== s && (0 === c || !n || i.z <= n.z)
                      ? ((i = (r = i).nextZ), s--)
                      : ((n = (r = n).nextZ), c--),
                      a ? (a.nextZ = r) : (t = r),
                      (r.prevZ = a),
                      (a = r);
                  i = n;
                }
                (a.nextZ = null), (h *= 2);
              } while (1 < o);
            })(r);
        })(t, n, r, a);
      for (var s, c, h = t; t.prev !== t.next; )
        if (((s = t.prev), (c = t.next), a ? ic(t, n, r, a) : ec(t)))
          e.push(s.i / i),
            e.push(t.i / i),
            e.push(c.i / i),
            gc(t),
            (t = c.next),
            (h = c.next);
        else if ((t = c) === h) {
          o
            ? 1 === o
              ? tc((t = nc(t, e, i)), e, i, n, r, a, 2)
              : 2 === o && rc(t, e, i, n, r, a)
            : tc($s(t), e, i, n, r, a, 1);
          break;
        }
    }
  }
  function ec(t) {
    var e = t.prev,
      i = t,
      n = t.next;
    if (!(0 <= lc(e, i, n))) {
      for (var r = t.next.next; r !== t.prev; ) {
        if (hc(e.x, e.y, i.x, i.y, n.x, n.y, r.x, r.y) && 0 <= lc(r.prev, r, r.next))
          return;
        r = r.next;
      }
      return 1;
    }
  }
  function ic(t, e, i, n) {
    var r = t.prev,
      a = t,
      o = t.next;
    if (!(0 <= lc(r, a, o))) {
      for (
        var s = r.x < a.x ? (r.x < o.x ? r.x : o.x) : a.x < o.x ? a.x : o.x,
          c = r.y < a.y ? (r.y < o.y ? r.y : o.y) : a.y < o.y ? a.y : o.y,
          h = r.x > a.x ? (r.x > o.x ? r.x : o.x) : a.x > o.x ? a.x : o.x,
          l = r.y > a.y ? (r.y > o.y ? r.y : o.y) : a.y > o.y ? a.y : o.y,
          u = sc(s, c, e, i, n),
          p = sc(h, l, e, i, n),
          d = t.nextZ;
        d && d.z <= p;

      ) {
        if (
          d !== t.prev &&
          d !== t.next &&
          hc(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) &&
          0 <= lc(d.prev, d, d.next)
        )
          return;
        d = d.nextZ;
      }
      for (d = t.prevZ; d && d.z >= u; ) {
        if (
          d !== t.prev &&
          d !== t.next &&
          hc(r.x, r.y, a.x, a.y, o.x, o.y, d.x, d.y) &&
          0 <= lc(d.prev, d, d.next)
        )
          return;
        d = d.prevZ;
      }
      return 1;
    }
  }
  function nc(t, e, i) {
    var n = t;
    do {
      var r = n.prev,
        a = n.next.next;
      !uc(r, a) &&
        pc(r, n, n.next, a) &&
        dc(r, a) &&
        dc(a, r) &&
        (e.push(r.i / i),
        e.push(n.i / i),
        e.push(a.i / i),
        gc(n),
        gc(n.next),
        (n = t = a)),
        (n = n.next);
    } while (n !== t);
    return n;
  }
  function rc(t, e, i, n, r, a) {
    var o,
      s,
      c = t;
    do {
      for (var h = c.next.next; h !== c.prev; ) {
        if (
          c.i !== h.i &&
          ((s = h),
          (o = c).next.i !== s.i &&
            o.prev.i !== s.i &&
            !(function (t, e) {
              var i = t;
              do {
                if (
                  i.i !== t.i &&
                  i.next.i !== t.i &&
                  i.i !== e.i &&
                  i.next.i !== e.i &&
                  pc(i, i.next, t, e)
                )
                  return 1;
                i = i.next;
              } while (i !== t);
              return;
            })(o, s) &&
            dc(o, s) &&
            dc(s, o) &&
            (function (t, e) {
              var i = t,
                n = !1,
                r = (t.x + e.x) / 2,
                a = (t.y + e.y) / 2;
              for (
                ;
                i.y > a != i.next.y > a &&
                  i.next.y !== i.y &&
                  r < ((i.next.x - i.x) * (a - i.y)) / (i.next.y - i.y) + i.x &&
                  (n = !n),
                  (i = i.next),
                  i !== t;

              );
              return n;
            })(o, s))
        ) {
          var l = fc(c, h);
          return (
            (c = $s(c, c.next)),
            (l = $s(l, l.next)),
            tc(c, e, i, n, r, a),
            void tc(l, e, i, n, r, a)
          );
        }
        h = h.next;
      }
      c = c.next;
    } while (c !== t);
  }
  function ac(t, e) {
    return t.x - e.x;
  }
  function oc(t, e) {
    if (
      (e = (function (t, e) {
        var i,
          n = e,
          r = t.x,
          a = t.y,
          o = -1 / 0;
        do {
          if (a <= n.y && a >= n.next.y && n.next.y !== n.y) {
            var s = n.x + ((a - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
            if (s <= r && o < s) {
              if ((o = s) === r) {
                if (a === n.y) return n;
                if (a === n.next.y) return n.next;
              }
              i = n.x < n.next.x ? n : n.next;
            }
          }
          n = n.next;
        } while (n !== e);
        if (!i) return null;
        if (r === o) return i.prev;
        var c,
          h = i,
          l = i.x,
          u = i.y,
          p = 1 / 0;
        n = i.next;
        for (; n !== h; )
          r >= n.x &&
            n.x >= l &&
            r !== n.x &&
            hc(a < u ? r : o, a, l, u, a < u ? o : r, a, n.x, n.y) &&
            ((c = Math.abs(a - n.y) / (r - n.x)) < p || (c === p && n.x > i.x)) &&
            dc(n, t) &&
            ((i = n), (p = c)),
            (n = n.next);
        return i;
      })(t, e))
    ) {
      var i = fc(e, t);
      $s(i, i.next);
    }
  }
  function sc(t, e, i, n, r) {
    return (
      (t =
        1431655765 &
        ((t =
          858993459 &
          ((t =
            252645135 &
            ((t = 16711935 & ((t = 32767 * (t - i) * r) | (t << 8))) | (t << 4))) |
            (t << 2))) |
          (t << 1))) |
      ((e =
        1431655765 &
        ((e =
          858993459 &
          ((e =
            252645135 &
            ((e = 16711935 & ((e = 32767 * (e - n) * r) | (e << 8))) | (e << 4))) |
            (e << 2))) |
          (e << 1))) <<
        1)
    );
  }
  function cc(t) {
    for (var e = t, i = t; e.x < i.x && (i = e), (e = e.next) !== t; );
    return i;
  }
  function hc(t, e, i, n, r, a, o, s) {
    return (
      0 <= (r - o) * (e - s) - (t - o) * (a - s) &&
      0 <= (t - o) * (n - s) - (i - o) * (e - s) &&
      0 <= (i - o) * (a - s) - (r - o) * (n - s)
    );
  }
  function lc(t, e, i) {
    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y);
  }
  function uc(t, e) {
    return t.x === e.x && t.y === e.y;
  }
  function pc(t, e, i, n) {
    return (
      (uc(t, e) && uc(i, n)) ||
      (uc(t, n) && uc(i, e)) ||
      (0 < lc(t, e, i) != 0 < lc(t, e, n) && 0 < lc(i, n, t) != 0 < lc(i, n, e))
    );
  }
  function dc(t, e) {
    return lc(t.prev, t, t.next) < 0
      ? 0 <= lc(t, e, t.next) && 0 <= lc(t, t.prev, e)
      : lc(t, e, t.prev) < 0 || lc(t, t.next, e) < 0;
  }
  function fc(t, e) {
    var i = new vc(t.i, t.x, t.y),
      n = new vc(e.i, e.x, e.y),
      r = t.next,
      a = e.prev;
    return (
      ((t.next = e).prev = t),
      ((i.next = r).prev = i),
      ((n.next = i).prev = n),
      ((a.next = n).prev = a),
      n
    );
  }
  function mc(t, e, i, n) {
    var r = new vc(t, e, i);
    return (
      n
        ? ((r.next = n.next), ((r.prev = n).next.prev = r), (n.next = r))
        : ((r.prev = r).next = r),
      r
    );
  }
  function gc(t) {
    (t.next.prev = t.prev),
      (t.prev.next = t.next),
      t.prevZ && (t.prevZ.nextZ = t.nextZ),
      t.nextZ && (t.nextZ.prevZ = t.prevZ);
  }
  function vc(t, e, i) {
    (this.i = t),
      (this.x = e),
      (this.y = i),
      (this.prev = null),
      (this.next = null),
      (this.z = null),
      (this.prevZ = null),
      (this.nextZ = null),
      (this.steiner = !1);
  }
  var yc = {
    area: function (t) {
      for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++)
        i += t[n].x * t[r].y - t[r].x * t[n].y;
      return 0.5 * i;
    },
    isClockWise: function (t) {
      return yc.area(t) < 0;
    },
    triangulateShape: function (t, e) {
      var i = [],
        n = [],
        r = [];
      xc(t), bc(i, t);
      var a = t.length;
      e.forEach(xc);
      for (var o = 0; o < e.length; o++) n.push(a), (a += e[o].length), bc(i, e[o]);
      var s = Qs(i, n);
      for (o = 0; o < s.length; o += 3) r.push(s.slice(o, o + 3));
      return r;
    }
  };
  function xc(t) {
    var e = t.length;
    2 < e && t[e - 1].equals(t[0]) && t.pop();
  }
  function bc(t, e) {
    for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y);
  }
  function _c(t, e) {
    Rn.call(this),
      (this.type = 'ExtrudeGeometry'),
      (this.parameters = { shapes: t, options: e }),
      this.fromBufferGeometry(new wc(t, e)),
      this.mergeVertices();
  }
  function wc(t, Z) {
    $n.call(this),
      (this.type = 'ExtrudeBufferGeometry'),
      (this.parameters = { shapes: t, options: Z }),
      (t = Array.isArray(t) ? t : [t]);
    for (var Q = this, K = [], $ = [], e = 0, i = t.length; e < i; e++) {
      n(t[e]);
    }
    function n(t) {
      var n = [],
        e = void 0 !== Z.curveSegments ? Z.curveSegments : 12,
        c = void 0 !== Z.steps ? Z.steps : 1,
        i = void 0 !== Z.depth ? Z.depth : 100,
        r = void 0 === Z.bevelEnabled || Z.bevelEnabled,
        a = void 0 !== Z.bevelThickness ? Z.bevelThickness : 6,
        o = void 0 !== Z.bevelSize ? Z.bevelSize : a - 2,
        h = void 0 !== Z.bevelSegments ? Z.bevelSegments : 3,
        s = Z.extrudePath,
        l = void 0 !== Z.UVGenerator ? Z.UVGenerator : Mc;
      void 0 !== Z.amount &&
        (console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.'),
        (i = Z.amount));
      var u,
        p,
        d,
        f,
        m,
        g,
        v,
        y,
        x = !1;
      s &&
        ((u = s.getSpacedPoints(c)),
        (r = !(x = !0)),
        (p = s.computeFrenetFrames(c, !1)),
        (d = new je()),
        (f = new je()),
        (m = new je())),
        r || (o = a = h = 0);
      var b = t.extractPoints(e),
        _ = b.shape,
        w = b.holes;
      if (!yc.isClockWise(_))
        for (_ = _.reverse(), v = 0, y = w.length; v < y; v++)
          (g = w[v]), yc.isClockWise(g) && (w[v] = g.reverse());
      var M = yc.triangulateShape(_, w),
        E = _;
      for (v = 0, y = w.length; v < y; v++) (g = w[v]), (_ = _.concat(g));
      function T(t, e, i) {
        return (
          e || console.error('THREE.ExtrudeGeometry: vec does not exist'),
          e.clone().multiplyScalar(i).add(t)
        );
      }
      var S,
        A,
        L,
        R,
        P,
        C,
        O = _.length,
        I = M.length;
      function N(t, e, i) {
        var n,
          r,
          a,
          o = t.x - e.x,
          s = t.y - e.y,
          c = i.x - t.x,
          h = i.y - t.y,
          l = o * o + s * s,
          u = o * h - s * c;
        if (Math.abs(u) > Number.EPSILON) {
          var p = Math.sqrt(l),
            d = Math.sqrt(c * c + h * h),
            f = e.x - s / p,
            m = e.y + o / p,
            g = ((i.x - h / d - f) * h - (i.y + c / d - m) * c) / (o * h - s * c),
            v = (n = f + o * g - t.x) * n + (r = m + s * g - t.y) * r;
          if (v <= 2) return new He(n, r);
          a = Math.sqrt(v / 2);
        } else {
          var y = !1;
          o > Number.EPSILON
            ? c > Number.EPSILON && (y = !0)
            : o < -Number.EPSILON
            ? c < -Number.EPSILON && (y = !0)
            : Math.sign(s) === Math.sign(h) && (y = !0),
            (a = y
              ? ((n = -s), (r = o), Math.sqrt(l))
              : ((n = o), (r = s), Math.sqrt(l / 2)));
        }
        return new He(n / a, r / a);
      }
      for (var D = [], U = 0, B = E.length, F = B - 1, z = U + 1; U < B; U++, F++, z++)
        F === B && (F = 0), z === B && (z = 0), (D[U] = N(E[U], E[F], E[z]));
      var G,
        H,
        V = [],
        k = D.concat();
      for (v = 0, y = w.length; v < y; v++) {
        for (
          g = w[v], G = [], U = 0, F = (B = g.length) - 1, z = U + 1;
          U < B;
          U++, F++, z++
        )
          F === B && (F = 0), z === B && (z = 0), (G[U] = N(g[U], g[F], g[z]));
        V.push(G), (k = k.concat(G));
      }
      for (S = 0; S < h; S++) {
        for (
          L = S / h,
            R = a * Math.cos((L * Math.PI) / 2),
            A = o * Math.sin((L * Math.PI) / 2),
            U = 0,
            B = E.length;
          U < B;
          U++
        )
          W((P = T(E[U], D[U], A)).x, P.y, -R);
        for (v = 0, y = w.length; v < y; v++)
          for (g = w[v], G = V[v], U = 0, B = g.length; U < B; U++)
            W((P = T(g[U], G[U], A)).x, P.y, -R);
      }
      for (A = o, U = 0; U < O; U++)
        (P = r ? T(_[U], k[U], A) : _[U]),
          x
            ? (f.copy(p.normals[0]).multiplyScalar(P.x),
              d.copy(p.binormals[0]).multiplyScalar(P.y),
              m.copy(u[0]).add(f).add(d),
              W(m.x, m.y, m.z))
            : W(P.x, P.y, 0);
      for (H = 1; H <= c; H++)
        for (U = 0; U < O; U++)
          (P = r ? T(_[U], k[U], A) : _[U]),
            x
              ? (f.copy(p.normals[H]).multiplyScalar(P.x),
                d.copy(p.binormals[H]).multiplyScalar(P.y),
                m.copy(u[H]).add(f).add(d),
                W(m.x, m.y, m.z))
              : W(P.x, P.y, (i / c) * H);
      for (S = h - 1; 0 <= S; S--) {
        for (
          L = S / h,
            R = a * Math.cos((L * Math.PI) / 2),
            A = o * Math.sin((L * Math.PI) / 2),
            U = 0,
            B = E.length;
          U < B;
          U++
        )
          W((P = T(E[U], D[U], A)).x, P.y, i + R);
        for (v = 0, y = w.length; v < y; v++)
          for (g = w[v], G = V[v], U = 0, B = g.length; U < B; U++)
            (P = T(g[U], G[U], A)),
              x ? W(P.x, P.y + u[c - 1].y, u[c - 1].x + R) : W(P.x, P.y, i + R);
      }
      function j(t, e) {
        var i, n;
        for (U = t.length; 0 <= --U; ) {
          (n = (i = U) - 1) < 0 && (n = t.length - 1);
          var r = 0,
            a = c + 2 * h;
          for (r = 0; r < a; r++) {
            var o = O * r,
              s = O * (r + 1);
            q(e + i + o, e + n + o, e + n + s, e + i + s);
          }
        }
      }
      function W(t, e, i) {
        n.push(t), n.push(e), n.push(i);
      }
      function X(t, e, i) {
        Y(t), Y(e), Y(i);
        var n = K.length / 3,
          r = l.generateTopUV(Q, K, n - 3, n - 2, n - 1);
        J(r[0]), J(r[1]), J(r[2]);
      }
      function q(t, e, i, n) {
        Y(t), Y(e), Y(n), Y(e), Y(i), Y(n);
        var r = K.length / 3,
          a = l.generateSideWallUV(Q, K, r - 6, r - 3, r - 2, r - 1);
        J(a[0]), J(a[1]), J(a[3]), J(a[1]), J(a[2]), J(a[3]);
      }
      function Y(t) {
        K.push(n[3 * t + 0]), K.push(n[3 * t + 1]), K.push(n[3 * t + 2]);
      }
      function J(t) {
        $.push(t.x), $.push(t.y);
      }
      !(function () {
        var t = K.length / 3;
        if (r) {
          var e = 0,
            i = O * e;
          for (U = 0; U < I; U++) X((C = M[U])[2] + i, C[1] + i, C[0] + i);
          for (i = O * (e = c + 2 * h), U = 0; U < I; U++)
            X((C = M[U])[0] + i, C[1] + i, C[2] + i);
        } else {
          for (U = 0; U < I; U++) X((C = M[U])[2], C[1], C[0]);
          for (U = 0; U < I; U++) X((C = M[U])[0] + O * c, C[1] + O * c, C[2] + O * c);
        }
        Q.addGroup(t, K.length / 3 - t, 0);
      })(),
        (function () {
          var t = K.length / 3,
            e = 0;
          for (j(E, e), e += E.length, v = 0, y = w.length; v < y; v++)
            j((g = w[v]), e), (e += g.length);
          Q.addGroup(t, K.length / 3 - t, 1);
        })();
    }
    this.addAttribute('position', new Fn(K, 3)),
      this.addAttribute('uv', new Fn($, 2)),
      this.computeVertexNormals();
  }
  (((_c.prototype = Object.create(
    Rn.prototype
  )).constructor = _c).prototype.toJSON = function () {
    var t = Rn.prototype.toJSON.call(this);
    return Ec(this.parameters.shapes, this.parameters.options, t);
  }),
    (((wc.prototype = Object.create(
      $n.prototype
    )).constructor = wc).prototype.toJSON = function () {
      var t = $n.prototype.toJSON.call(this);
      return Ec(this.parameters.shapes, this.parameters.options, t);
    });
  var Mc = {
    generateTopUV: function (t, e, i, n, r) {
      var a = e[3 * i],
        o = e[3 * i + 1],
        s = e[3 * n],
        c = e[3 * n + 1],
        h = e[3 * r],
        l = e[3 * r + 1];
      return [new He(a, o), new He(s, c), new He(h, l)];
    },
    generateSideWallUV: function (t, e, i, n, r, a) {
      var o = e[3 * i],
        s = e[3 * i + 1],
        c = e[3 * i + 2],
        h = e[3 * n],
        l = e[3 * n + 1],
        u = e[3 * n + 2],
        p = e[3 * r],
        d = e[3 * r + 1],
        f = e[3 * r + 2],
        m = e[3 * a],
        g = e[3 * a + 1],
        v = e[3 * a + 2];
      return Math.abs(s - l) < 0.01
        ? [new He(o, 1 - c), new He(h, 1 - u), new He(p, 1 - f), new He(m, 1 - v)]
        : [new He(s, 1 - c), new He(l, 1 - u), new He(d, 1 - f), new He(g, 1 - v)];
    }
  };
  function Ec(t, e, i) {
    if (((i.shapes = []), Array.isArray(t)))
      for (var n = 0, r = t.length; n < r; n++) {
        var a = t[n];
        i.shapes.push(a.uuid);
      }
    else i.shapes.push(t.uuid);
    return (
      void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
    );
  }
  function Tc(t, e) {
    Rn.call(this),
      (this.type = 'TextGeometry'),
      (this.parameters = { text: t, parameters: e }),
      this.fromBufferGeometry(new Sc(t, e)),
      this.mergeVertices();
  }
  function Sc(t, e) {
    var i = (e = e || {}).font;
    if (!i || !i.isFont)
      return (
        console.error(
          'THREE.TextGeometry: font parameter is not an instance of THREE.Font.'
        ),
        new Rn()
      );
    var n = i.generateShapes(t, e.size);
    (e.depth = void 0 !== e.height ? e.height : 50),
      void 0 === e.bevelThickness && (e.bevelThickness = 10),
      void 0 === e.bevelSize && (e.bevelSize = 8),
      void 0 === e.bevelEnabled && (e.bevelEnabled = !1),
      wc.call(this, n, e),
      (this.type = 'TextBufferGeometry');
  }
  function Ac(t, e, i, n, r, a, o) {
    Rn.call(this),
      (this.type = 'SphereGeometry'),
      (this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: i,
        phiStart: n,
        phiLength: r,
        thetaStart: a,
        thetaLength: o
      }),
      this.fromBufferGeometry(new Lc(t, e, i, n, r, a, o)),
      this.mergeVertices();
  }
  function Lc(t, e, i, n, r, a, o) {
    $n.call(this),
      (this.type = 'SphereBufferGeometry'),
      (this.parameters = {
        radius: t,
        widthSegments: e,
        heightSegments: i,
        phiStart: n,
        phiLength: r,
        thetaStart: a,
        thetaLength: o
      }),
      (t = t || 1),
      (e = Math.max(3, Math.floor(e) || 8)),
      (i = Math.max(2, Math.floor(i) || 6)),
      (n = void 0 !== n ? n : 0),
      (r = void 0 !== r ? r : 2 * Math.PI);
    var s,
      c,
      h = (a = void 0 !== a ? a : 0) + (o = void 0 !== o ? o : Math.PI),
      l = 0,
      u = [],
      p = new je(),
      d = new je(),
      f = [],
      m = [],
      g = [],
      v = [];
    for (c = 0; c <= i; c++) {
      var y = [],
        x = c / i;
      for (s = 0; s <= e; s++) {
        var b = s / e;
        (p.x = -t * Math.cos(n + b * r) * Math.sin(a + x * o)),
          (p.y = t * Math.cos(a + x * o)),
          (p.z = t * Math.sin(n + b * r) * Math.sin(a + x * o)),
          m.push(p.x, p.y, p.z),
          d.set(p.x, p.y, p.z).normalize(),
          g.push(d.x, d.y, d.z),
          v.push(b, 1 - x),
          y.push(l++);
      }
      u.push(y);
    }
    for (c = 0; c < i; c++)
      for (s = 0; s < e; s++) {
        var _ = u[c][s + 1],
          w = u[c][s],
          M = u[c + 1][s],
          E = u[c + 1][s + 1];
        (0 !== c || 0 < a) && f.push(_, w, E),
          (c !== i - 1 || h < Math.PI) && f.push(w, M, E);
      }
    this.setIndex(f),
      this.addAttribute('position', new Fn(m, 3)),
      this.addAttribute('normal', new Fn(g, 3)),
      this.addAttribute('uv', new Fn(v, 2));
  }
  function Rc(t, e, i, n, r, a) {
    Rn.call(this),
      (this.type = 'RingGeometry'),
      (this.parameters = {
        innerRadius: t,
        outerRadius: e,
        thetaSegments: i,
        phiSegments: n,
        thetaStart: r,
        thetaLength: a
      }),
      this.fromBufferGeometry(new Pc(t, e, i, n, r, a)),
      this.mergeVertices();
  }
  function Pc(t, e, i, n, r, a) {
    $n.call(this),
      (this.type = 'RingBufferGeometry'),
      (this.parameters = {
        innerRadius: t,
        outerRadius: e,
        thetaSegments: i,
        phiSegments: n,
        thetaStart: r,
        thetaLength: a
      }),
      (t = t || 0.5),
      (e = e || 1),
      (r = void 0 !== r ? r : 0),
      (a = void 0 !== a ? a : 2 * Math.PI),
      (i = void 0 !== i ? Math.max(3, i) : 8);
    var o,
      s,
      c,
      h = [],
      l = [],
      u = [],
      p = [],
      d = t,
      f = (e - t) / (n = void 0 !== n ? Math.max(1, n) : 1),
      m = new je(),
      g = new He();
    for (s = 0; s <= n; s++) {
      for (c = 0; c <= i; c++)
        (o = r + (c / i) * a),
          (m.x = d * Math.cos(o)),
          (m.y = d * Math.sin(o)),
          l.push(m.x, m.y, m.z),
          u.push(0, 0, 1),
          (g.x = (m.x / e + 1) / 2),
          (g.y = (m.y / e + 1) / 2),
          p.push(g.x, g.y);
      d += f;
    }
    for (s = 0; s < n; s++) {
      var v = s * (i + 1);
      for (c = 0; c < i; c++) {
        var y = (o = c + v),
          x = o + i + 1,
          b = o + i + 2,
          _ = o + 1;
        h.push(y, x, _), h.push(x, b, _);
      }
    }
    this.setIndex(h),
      this.addAttribute('position', new Fn(l, 3)),
      this.addAttribute('normal', new Fn(u, 3)),
      this.addAttribute('uv', new Fn(p, 2));
  }
  function Cc(t, e, i, n) {
    Rn.call(this),
      (this.type = 'LatheGeometry'),
      (this.parameters = { points: t, segments: e, phiStart: i, phiLength: n }),
      this.fromBufferGeometry(new Oc(t, e, i, n)),
      this.mergeVertices();
  }
  function Oc(t, e, i, n) {
    $n.call(this),
      (this.type = 'LatheBufferGeometry'),
      (this.parameters = { points: t, segments: e, phiStart: i, phiLength: n }),
      (e = Math.floor(e) || 12),
      (i = i || 0),
      (n = n || 2 * Math.PI),
      (n = Ge.clamp(n, 0, 2 * Math.PI));
    var r,
      a,
      o,
      s = [],
      c = [],
      h = [],
      l = 1 / e,
      u = new je(),
      p = new He();
    for (a = 0; a <= e; a++) {
      var d = i + a * l * n,
        f = Math.sin(d),
        m = Math.cos(d);
      for (o = 0; o <= t.length - 1; o++)
        (u.x = t[o].x * f),
          (u.y = t[o].y),
          (u.z = t[o].x * m),
          c.push(u.x, u.y, u.z),
          (p.x = a / e),
          (p.y = o / (t.length - 1)),
          h.push(p.x, p.y);
    }
    for (a = 0; a < e; a++)
      for (o = 0; o < t.length - 1; o++) {
        var g = (r = o + a * t.length),
          v = r + t.length,
          y = r + t.length + 1,
          x = r + 1;
        s.push(g, v, x), s.push(v, y, x);
      }
    if (
      (this.setIndex(s),
      this.addAttribute('position', new Fn(c, 3)),
      this.addAttribute('uv', new Fn(h, 2)),
      this.computeVertexNormals(),
      n === 2 * Math.PI)
    ) {
      var b = this.attributes.normal.array,
        _ = new je(),
        w = new je(),
        M = new je();
      for (r = e * t.length * 3, o = a = 0; a < t.length; a++, o += 3)
        (_.x = b[o + 0]),
          (_.y = b[o + 1]),
          (_.z = b[o + 2]),
          (w.x = b[r + o + 0]),
          (w.y = b[r + o + 1]),
          (w.z = b[r + o + 2]),
          M.addVectors(_, w).normalize(),
          (b[o + 0] = b[r + o + 0] = M.x),
          (b[o + 1] = b[r + o + 1] = M.y),
          (b[o + 2] = b[r + o + 2] = M.z);
    }
  }
  function Ic(t, e) {
    Rn.call(this),
      (this.type = 'ShapeGeometry'),
      'object' == typeof e &&
        (console.warn('THREE.ShapeGeometry: Options parameter has been removed.'),
        (e = e.curveSegments)),
      (this.parameters = { shapes: t, curveSegments: e }),
      this.fromBufferGeometry(new Nc(t, e)),
      this.mergeVertices();
  }
  function Nc(t, f) {
    $n.call(this),
      (this.type = 'ShapeBufferGeometry'),
      (this.parameters = { shapes: t, curveSegments: f }),
      (f = f || 12);
    var m = [],
      g = [],
      v = [],
      y = [],
      e = 0,
      x = 0;
    if (!1 === Array.isArray(t)) n(t);
    else
      for (var i = 0; i < t.length; i++)
        n(t[i]), this.addGroup(e, x, i), (e += x), (x = 0);
    function n(t) {
      var e,
        i,
        n,
        r = g.length / 3,
        a = t.extractPoints(f),
        o = a.shape,
        s = a.holes;
      if (!1 === yc.isClockWise(o))
        for (o = o.reverse(), e = 0, i = s.length; e < i; e++)
          (n = s[e]), !0 === yc.isClockWise(n) && (s[e] = n.reverse());
      var c = yc.triangulateShape(o, s);
      for (e = 0, i = s.length; e < i; e++) (n = s[e]), (o = o.concat(n));
      for (e = 0, i = o.length; e < i; e++) {
        var h = o[e];
        g.push(h.x, h.y, 0), v.push(0, 0, 1), y.push(h.x, h.y);
      }
      for (e = 0, i = c.length; e < i; e++) {
        var l = c[e],
          u = l[0] + r,
          p = l[1] + r,
          d = l[2] + r;
        m.push(u, p, d), (x += 3);
      }
    }
    this.setIndex(m),
      this.addAttribute('position', new Fn(g, 3)),
      this.addAttribute('normal', new Fn(v, 3)),
      this.addAttribute('uv', new Fn(y, 2));
  }
  function Dc(t, e) {
    if (((e.shapes = []), Array.isArray(t)))
      for (var i = 0, n = t.length; i < n; i++) {
        var r = t[i];
        e.shapes.push(r.uuid);
      }
    else e.shapes.push(t.uuid);
    return e;
  }
  function Uc(t, e) {
    $n.call(this),
      (this.type = 'EdgesGeometry'),
      (this.parameters = { thresholdAngle: e }),
      (e = void 0 !== e ? e : 1);
    var i,
      n,
      r,
      a,
      o = [],
      s = Math.cos(Ge.DEG2RAD * e),
      c = [0, 0],
      h = {},
      l = ['a', 'b', 'c'];
    t.isBufferGeometry ? (a = new Rn()).fromBufferGeometry(t) : (a = t.clone()),
      a.mergeVertices(),
      a.computeFaceNormals();
    for (var u = a.vertices, p = a.faces, d = 0, f = p.length; d < f; d++)
      for (var m = p[d], g = 0; g < 3; g++)
        (i = m[l[g]]),
          (n = m[l[(g + 1) % 3]]),
          (c[0] = Math.min(i, n)),
          (c[1] = Math.max(i, n)),
          void 0 === h[(r = c[0] + ',' + c[1])]
            ? (h[r] = { index1: c[0], index2: c[1], face1: d, face2: void 0 })
            : (h[r].face2 = d);
    for (r in h) {
      var v = h[r];
      if (void 0 === v.face2 || p[v.face1].normal.dot(p[v.face2].normal) <= s) {
        var y = u[v.index1];
        o.push(y.x, y.y, y.z), (y = u[v.index2]), o.push(y.x, y.y, y.z);
      }
    }
    this.addAttribute('position', new Fn(o, 3));
  }
  function Bc(t, e, i, n, r, a, o, s) {
    Rn.call(this),
      (this.type = 'CylinderGeometry'),
      (this.parameters = {
        radiusTop: t,
        radiusBottom: e,
        height: i,
        radialSegments: n,
        heightSegments: r,
        openEnded: a,
        thetaStart: o,
        thetaLength: s
      }),
      this.fromBufferGeometry(new Fc(t, e, i, n, r, a, o, s)),
      this.mergeVertices();
  }
  function Fc(v, y, x, b, _, t, w, M) {
    $n.call(this),
      (this.type = 'CylinderBufferGeometry'),
      (this.parameters = {
        radiusTop: v,
        radiusBottom: y,
        height: x,
        radialSegments: b,
        heightSegments: _,
        openEnded: t,
        thetaStart: w,
        thetaLength: M
      });
    var E = this;
    (v = void 0 !== v ? v : 1),
      (y = void 0 !== y ? y : 1),
      (x = x || 1),
      (b = Math.floor(b) || 8),
      (_ = Math.floor(_) || 1),
      (t = void 0 !== t && t),
      (w = void 0 !== w ? w : 0),
      (M = void 0 !== M ? M : 2 * Math.PI);
    var T = [],
      S = [],
      A = [],
      L = [],
      R = 0,
      P = [],
      C = x / 2,
      O = 0;
    function e(t) {
      var e,
        i,
        n,
        r = new He(),
        a = new je(),
        o = 0,
        s = !0 === t ? v : y,
        c = !0 === t ? 1 : -1;
      for (i = R, e = 1; e <= b; e++)
        S.push(0, C * c, 0), A.push(0, c, 0), L.push(0.5, 0.5), R++;
      for (n = R, e = 0; e <= b; e++) {
        var h = (e / b) * M + w,
          l = Math.cos(h),
          u = Math.sin(h);
        (a.x = s * u),
          (a.y = C * c),
          (a.z = s * l),
          S.push(a.x, a.y, a.z),
          A.push(0, c, 0),
          (r.x = 0.5 * l + 0.5),
          (r.y = 0.5 * u * c + 0.5),
          L.push(r.x, r.y),
          R++;
      }
      for (e = 0; e < b; e++) {
        var p = i + e,
          d = n + e;
        !0 === t ? T.push(d, d + 1, p) : T.push(d + 1, d, p), (o += 3);
      }
      E.addGroup(O, o, !0 === t ? 1 : 2), (O += o);
    }
    !(function () {
      var t,
        e,
        i = new je(),
        n = new je(),
        r = 0,
        a = (y - v) / x;
      for (e = 0; e <= _; e++) {
        var o = [],
          s = e / _,
          c = s * (y - v) + v;
        for (t = 0; t <= b; t++) {
          var h = t / b,
            l = h * M + w,
            u = Math.sin(l),
            p = Math.cos(l);
          (n.x = c * u),
            (n.y = -s * x + C),
            (n.z = c * p),
            S.push(n.x, n.y, n.z),
            i.set(u, a, p).normalize(),
            A.push(i.x, i.y, i.z),
            L.push(h, 1 - s),
            o.push(R++);
        }
        P.push(o);
      }
      for (t = 0; t < b; t++)
        for (e = 0; e < _; e++) {
          var d = P[e][t],
            f = P[e + 1][t],
            m = P[e + 1][t + 1],
            g = P[e][t + 1];
          T.push(d, f, g), T.push(f, m, g), (r += 6);
        }
      E.addGroup(O, r, 0), (O += r);
    })(),
      !1 === t && (0 < v && e(!0), 0 < y && e(!1)),
      this.setIndex(T),
      this.addAttribute('position', new Fn(S, 3)),
      this.addAttribute('normal', new Fn(A, 3)),
      this.addAttribute('uv', new Fn(L, 2));
  }
  function zc(t, e, i, n, r, a, o) {
    Bc.call(this, 0, t, e, i, n, r, a, o),
      (this.type = 'ConeGeometry'),
      (this.parameters = {
        radius: t,
        height: e,
        radialSegments: i,
        heightSegments: n,
        openEnded: r,
        thetaStart: a,
        thetaLength: o
      });
  }
  function Gc(t, e, i, n, r, a, o) {
    Fc.call(this, 0, t, e, i, n, r, a, o),
      (this.type = 'ConeBufferGeometry'),
      (this.parameters = {
        radius: t,
        height: e,
        radialSegments: i,
        heightSegments: n,
        openEnded: r,
        thetaStart: a,
        thetaLength: o
      });
  }
  function Hc(t, e, i, n) {
    Rn.call(this),
      (this.type = 'CircleGeometry'),
      (this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: n }),
      this.fromBufferGeometry(new Vc(t, e, i, n)),
      this.mergeVertices();
  }
  function Vc(t, e, i, n) {
    $n.call(this),
      (this.type = 'CircleBufferGeometry'),
      (this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: n }),
      (t = t || 1),
      (e = void 0 !== e ? Math.max(3, e) : 8),
      (i = void 0 !== i ? i : 0),
      (n = void 0 !== n ? n : 2 * Math.PI);
    var r,
      a,
      o = [],
      s = [],
      c = [],
      h = [],
      l = new je(),
      u = new He();
    for (
      s.push(0, 0, 0), c.push(0, 0, 1), h.push(0.5, 0.5), a = 0, r = 3;
      a <= e;
      a++, r += 3
    ) {
      var p = i + (a / e) * n;
      (l.x = t * Math.cos(p)),
        (l.y = t * Math.sin(p)),
        s.push(l.x, l.y, l.z),
        c.push(0, 0, 1),
        (u.x = (s[r] / t + 1) / 2),
        (u.y = (s[r + 1] / t + 1) / 2),
        h.push(u.x, u.y);
    }
    for (r = 1; r <= e; r++) o.push(r, r + 1, 0);
    this.setIndex(o),
      this.addAttribute('position', new Fn(s, 3)),
      this.addAttribute('normal', new Fn(c, 3)),
      this.addAttribute('uv', new Fn(h, 2));
  }
  ((Tc.prototype = Object.create(Rn.prototype)).constructor = Tc),
    ((Sc.prototype = Object.create(wc.prototype)).constructor = Sc),
    ((Ac.prototype = Object.create(Rn.prototype)).constructor = Ac),
    ((Lc.prototype = Object.create($n.prototype)).constructor = Lc),
    ((Rc.prototype = Object.create(Rn.prototype)).constructor = Rc),
    ((Pc.prototype = Object.create($n.prototype)).constructor = Pc),
    ((Cc.prototype = Object.create(Rn.prototype)).constructor = Cc),
    ((Oc.prototype = Object.create($n.prototype)).constructor = Oc),
    (((Ic.prototype = Object.create(
      Rn.prototype
    )).constructor = Ic).prototype.toJSON = function () {
      var t = Rn.prototype.toJSON.call(this);
      return Dc(this.parameters.shapes, t);
    }),
    (((Nc.prototype = Object.create(
      $n.prototype
    )).constructor = Nc).prototype.toJSON = function () {
      var t = $n.prototype.toJSON.call(this);
      return Dc(this.parameters.shapes, t);
    }),
    ((Uc.prototype = Object.create($n.prototype)).constructor = Uc),
    ((Bc.prototype = Object.create(Rn.prototype)).constructor = Bc),
    ((Fc.prototype = Object.create($n.prototype)).constructor = Fc),
    ((zc.prototype = Object.create(Bc.prototype)).constructor = zc),
    ((Gc.prototype = Object.create(Fc.prototype)).constructor = Gc),
    ((Hc.prototype = Object.create(Rn.prototype)).constructor = Hc),
    ((Vc.prototype = Object.create($n.prototype)).constructor = Vc);
  var kc = Object.freeze({
    WireframeGeometry: Os,
    ParametricGeometry: Is,
    ParametricBufferGeometry: Ns,
    TetrahedronGeometry: Bs,
    TetrahedronBufferGeometry: Fs,
    OctahedronGeometry: zs,
    OctahedronBufferGeometry: Gs,
    IcosahedronGeometry: Hs,
    IcosahedronBufferGeometry: Vs,
    DodecahedronGeometry: ks,
    DodecahedronBufferGeometry: js,
    PolyhedronGeometry: Ds,
    PolyhedronBufferGeometry: Us,
    TubeGeometry: Ws,
    TubeBufferGeometry: Xs,
    TorusKnotGeometry: qs,
    TorusKnotBufferGeometry: Ys,
    TorusGeometry: Js,
    TorusBufferGeometry: Zs,
    TextGeometry: Tc,
    TextBufferGeometry: Sc,
    SphereGeometry: Ac,
    SphereBufferGeometry: Lc,
    RingGeometry: Rc,
    RingBufferGeometry: Pc,
    PlaneGeometry: ir,
    PlaneBufferGeometry: nr,
    LatheGeometry: Cc,
    LatheBufferGeometry: Oc,
    ShapeGeometry: Ic,
    ShapeBufferGeometry: Nc,
    ExtrudeGeometry: _c,
    ExtrudeBufferGeometry: wc,
    EdgesGeometry: Uc,
    ConeGeometry: zc,
    ConeBufferGeometry: Gc,
    CylinderGeometry: Bc,
    CylinderBufferGeometry: Fc,
    CircleGeometry: Hc,
    CircleBufferGeometry: Vc,
    BoxGeometry: tr,
    BoxBufferGeometry: er
  });
  function jc(t) {
    jr.call(this),
      (this.type = 'ShadowMaterial'),
      (this.color = new Hi(0)),
      (this.transparent = !0),
      this.setValues(t);
  }
  function Wc(t) {
    Wr.call(this, t), (this.type = 'RawShaderMaterial');
  }
  function Xc(t) {
    jr.call(this),
      (this.defines = { STANDARD: '' }),
      (this.type = 'MeshStandardMaterial'),
      (this.color = new Hi(16777215)),
      (this.roughness = 0.5),
      (this.metalness = 0.5),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Hi(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Fe),
      (this.normalScale = new He(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(t);
  }
  function qc(t) {
    Xc.call(this),
      (this.defines = { PHYSICAL: '' }),
      (this.type = 'MeshPhysicalMaterial'),
      (this.reflectivity = 0.5),
      (this.clearCoat = 0),
      (this.clearCoatRoughness = 0),
      this.setValues(t);
  }
  function Yc(t) {
    jr.call(this),
      (this.type = 'MeshPhongMaterial'),
      (this.color = new Hi(16777215)),
      (this.specular = new Hi(1118481)),
      (this.shininess = 30),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Hi(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Fe),
      (this.normalScale = new He(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = k),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(t);
  }
  function Jc(t) {
    Yc.call(this),
      (this.defines = { TOON: '' }),
      (this.type = 'MeshToonMaterial'),
      (this.gradientMap = null),
      this.setValues(t);
  }
  function Zc(t) {
    jr.call(this),
      (this.type = 'MeshNormalMaterial'),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Fe),
      (this.normalScale = new He(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(t);
  }
  function Qc(t) {
    jr.call(this),
      (this.type = 'MeshLambertMaterial'),
      (this.color = new Hi(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Hi(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = k),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = 'round'),
      (this.wireframeLinejoin = 'round'),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      this.setValues(t);
  }
  function Kc(t) {
    if (
      (jr.call(this),
      (this.defines = { MATCAP: '' }),
      (this.type = 'MeshMatcapMaterial'),
      (this.color = new Hi(16777215)),
      (this.matcap = null),
      (this.map = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = Fe),
      (this.normalScale = new He(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.alphaMap = null),
      (this.skinning = !1),
      (this.morphTargets = !1),
      (this.morphNormals = !1),
      (this.lights = !1),
      this.setValues(t),
      null === this.matcap)
    ) {
      var e = document.createElement('canvas');
      (e.width = 1), (e.height = 1);
      var i = e.getContext('2d');
      (i.fillStyle = '#fff'),
        i.fillRect(0, 0, 1, 1),
        (this.matcap = new THREE.CanvasTexture(e));
    }
  }
  function $c(t) {
    ws.call(this),
      (this.type = 'LineDashedMaterial'),
      (this.scale = 1),
      (this.dashSize = 3),
      (this.gapSize = 1),
      this.setValues(t);
  }
  (((jc.prototype = Object.create(
    jr.prototype
  )).constructor = jc).prototype.isShadowMaterial = !0),
    (jc.prototype.copy = function (t) {
      return jr.prototype.copy.call(this, t), this.color.copy(t.color), this;
    }),
    (((Wc.prototype = Object.create(
      Wr.prototype
    )).constructor = Wc).prototype.isRawShaderMaterial = !0),
    (((Xc.prototype = Object.create(
      jr.prototype
    )).constructor = Xc).prototype.isMeshStandardMaterial = !0),
    (Xc.prototype.copy = function (t) {
      return (
        jr.prototype.copy.call(this, t),
        (this.defines = { STANDARD: '' }),
        this.color.copy(t.color),
        (this.roughness = t.roughness),
        (this.metalness = t.metalness),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.roughnessMap = t.roughnessMap),
        (this.metalnessMap = t.metalnessMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.envMapIntensity = t.envMapIntensity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        this
      );
    }),
    (((qc.prototype = Object.create(
      Xc.prototype
    )).constructor = qc).prototype.isMeshPhysicalMaterial = !0),
    (qc.prototype.copy = function (t) {
      return (
        Xc.prototype.copy.call(this, t),
        (this.defines = { PHYSICAL: '' }),
        (this.reflectivity = t.reflectivity),
        (this.clearCoat = t.clearCoat),
        (this.clearCoatRoughness = t.clearCoatRoughness),
        this
      );
    }),
    (((Yc.prototype = Object.create(
      jr.prototype
    )).constructor = Yc).prototype.isMeshPhongMaterial = !0),
    (Yc.prototype.copy = function (t) {
      return (
        jr.prototype.copy.call(this, t),
        this.color.copy(t.color),
        this.specular.copy(t.specular),
        (this.shininess = t.shininess),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        this
      );
    }),
    (((Jc.prototype = Object.create(
      Yc.prototype
    )).constructor = Jc).prototype.isMeshToonMaterial = !0),
    (Jc.prototype.copy = function (t) {
      return Yc.prototype.copy.call(this, t), (this.gradientMap = t.gradientMap), this;
    }),
    (((Zc.prototype = Object.create(
      jr.prototype
    )).constructor = Zc).prototype.isMeshNormalMaterial = !0),
    (Zc.prototype.copy = function (t) {
      return (
        jr.prototype.copy.call(this, t),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        this
      );
    }),
    (((Qc.prototype = Object.create(
      jr.prototype
    )).constructor = Qc).prototype.isMeshLambertMaterial = !0),
    (Qc.prototype.copy = function (t) {
      return (
        jr.prototype.copy.call(this, t),
        this.color.copy(t.color),
        (this.map = t.map),
        (this.lightMap = t.lightMap),
        (this.lightMapIntensity = t.lightMapIntensity),
        (this.aoMap = t.aoMap),
        (this.aoMapIntensity = t.aoMapIntensity),
        this.emissive.copy(t.emissive),
        (this.emissiveMap = t.emissiveMap),
        (this.emissiveIntensity = t.emissiveIntensity),
        (this.specularMap = t.specularMap),
        (this.alphaMap = t.alphaMap),
        (this.envMap = t.envMap),
        (this.combine = t.combine),
        (this.reflectivity = t.reflectivity),
        (this.refractionRatio = t.refractionRatio),
        (this.wireframe = t.wireframe),
        (this.wireframeLinewidth = t.wireframeLinewidth),
        (this.wireframeLinecap = t.wireframeLinecap),
        (this.wireframeLinejoin = t.wireframeLinejoin),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        this
      );
    }),
    (((Kc.prototype = Object.create(
      jr.prototype
    )).constructor = Kc).prototype.isMeshMatcapMaterial = !0),
    (Kc.prototype.copy = function (t) {
      return (
        jr.prototype.copy.call(this, t),
        (this.defines = { MATCAP: '' }),
        this.color.copy(t.color),
        (this.matcap = t.matcap),
        (this.map = t.map),
        (this.bumpMap = t.bumpMap),
        (this.bumpScale = t.bumpScale),
        (this.normalMap = t.normalMap),
        (this.normalMapType = t.normalMapType),
        this.normalScale.copy(t.normalScale),
        (this.displacementMap = t.displacementMap),
        (this.displacementScale = t.displacementScale),
        (this.displacementBias = t.displacementBias),
        (this.alphaMap = t.alphaMap),
        (this.skinning = t.skinning),
        (this.morphTargets = t.morphTargets),
        (this.morphNormals = t.morphNormals),
        this
      );
    }),
    ((($c.prototype = Object.create(
      ws.prototype
    )).constructor = $c).prototype.isLineDashedMaterial = !0),
    ($c.prototype.copy = function (t) {
      return (
        ws.prototype.copy.call(this, t),
        (this.scale = t.scale),
        (this.dashSize = t.dashSize),
        (this.gapSize = t.gapSize),
        this
      );
    });
  var th = Object.freeze({
      ShadowMaterial: jc,
      SpriteMaterial: ms,
      RawShaderMaterial: Wc,
      ShaderMaterial: Wr,
      PointsMaterial: Ss,
      MeshPhysicalMaterial: qc,
      MeshStandardMaterial: Xc,
      MeshPhongMaterial: Yc,
      MeshToonMaterial: Jc,
      MeshNormalMaterial: Zc,
      MeshLambertMaterial: Qc,
      MeshDepthMaterial: Qo,
      MeshDistanceMaterial: Ko,
      MeshBasicMaterial: Yr,
      MeshMatcapMaterial: Kc,
      LineDashedMaterial: $c,
      LineBasicMaterial: ws,
      Material: jr
    }),
    eh = {
      enabled: !1,
      files: {},
      add: function (t, e) {
        !1 !== this.enabled && (this.files[t] = e);
      },
      get: function (t) {
        if (!1 !== this.enabled) return this.files[t];
      },
      remove: function (t) {
        delete this.files[t];
      },
      clear: function () {
        this.files = {};
      }
    };
  function ih(t, e, i) {
    var n = this,
      r = !1,
      a = 0,
      o = 0,
      s = void 0;
    (this.onStart = void 0),
      (this.onLoad = t),
      (this.onProgress = e),
      (this.onError = i),
      (this.itemStart = function (t) {
        o++, !1 === r && void 0 !== n.onStart && n.onStart(t, a, o), (r = !0);
      }),
      (this.itemEnd = function (t) {
        a++,
          void 0 !== n.onProgress && n.onProgress(t, a, o),
          a === o && ((r = !1), void 0 !== n.onLoad && n.onLoad());
      }),
      (this.itemError = function (t) {
        void 0 !== n.onError && n.onError(t);
      }),
      (this.resolveURL = function (t) {
        return s ? s(t) : t;
      }),
      (this.setURLModifier = function (t) {
        return (s = t), this;
      });
  }
  var nh = new ih(),
    rh = {};
  function ah(t) {
    this.manager = void 0 !== t ? t : nh;
  }
  function oh(t) {
    (this.manager = void 0 !== t ? t : nh), (this._parser = null);
  }
  function sh(t) {
    (this.manager = void 0 !== t ? t : nh), (this._parser = null);
  }
  function ch(t) {
    this.manager = void 0 !== t ? t : nh;
  }
  function hh(t) {
    this.manager = void 0 !== t ? t : nh;
  }
  function lh(t) {
    this.manager = void 0 !== t ? t : nh;
  }
  function uh() {
    (this.type = 'Curve'), (this.arcLengthDivisions = 200);
  }
  function ph(t, e, i, n, r, a, o, s) {
    uh.call(this),
      (this.type = 'EllipseCurve'),
      (this.aX = t || 0),
      (this.aY = e || 0),
      (this.xRadius = i || 1),
      (this.yRadius = n || 1),
      (this.aStartAngle = r || 0),
      (this.aEndAngle = a || 2 * Math.PI),
      (this.aClockwise = o || !1),
      (this.aRotation = s || 0);
  }
  function dh(t, e, i, n, r, a) {
    ph.call(this, t, e, i, i, n, r, a), (this.type = 'ArcCurve');
  }
  function fh() {
    var r = 0,
      a = 0,
      o = 0,
      s = 0;
    function h(t, e, i, n) {
      (o = -3 * (r = t) + 3 * e - 2 * (a = i) - n), (s = 2 * t - 2 * e + i + n);
    }
    return {
      initCatmullRom: function (t, e, i, n, r) {
        h(e, i, r * (i - t), r * (n - e));
      },
      initNonuniformCatmullRom: function (t, e, i, n, r, a, o) {
        var s = (e - t) / r - (i - t) / (r + a) + (i - e) / a,
          c = (i - e) / a - (n - e) / (a + o) + (n - i) / o;
        h(e, i, (s *= a), (c *= a));
      },
      calc: function (t) {
        var e = t * t;
        return r + a * t + o * e + s * (e * t);
      }
    };
  }
  Object.assign(ah.prototype, {
    load: function (o, t, e, i) {
      void 0 === o && (o = ''),
        void 0 !== this.path && (o = this.path + o),
        (o = this.manager.resolveURL(o));
      var s = this,
        n = eh.get(o);
      if (void 0 !== n)
        return (
          s.manager.itemStart(o),
          setTimeout(function () {
            t && t(n), s.manager.itemEnd(o);
          }, 0),
          n
        );
      if (void 0 === rh[o]) {
        var r = o.match(/^data:(.*?)(;base64)?,(.*)$/);
        if (r) {
          var a = r[1],
            c = !!r[2],
            h = r[3];
          (h = window.decodeURIComponent(h)), c && (h = window.atob(h));
          try {
            var l,
              u = (this.responseType || '').toLowerCase();
            switch (u) {
              case 'arraybuffer':
              case 'blob':
                for (var p = new Uint8Array(h.length), d = 0; d < h.length; d++)
                  p[d] = h.charCodeAt(d);
                l = 'blob' === u ? new Blob([p.buffer], { type: a }) : p.buffer;
                break;
              case 'document':
                var f = new DOMParser();
                l = f.parseFromString(h, a);
                break;
              case 'json':
                l = JSON.parse(h);
                break;
              default:
                l = h;
            }
            window.setTimeout(function () {
              t && t(l), s.manager.itemEnd(o);
            }, 0);
          } catch (t) {
            window.setTimeout(function () {
              i && i(t), s.manager.itemEnd(o), s.manager.itemError(o);
            }, 0);
          }
        } else {
          (rh[o] = []), rh[o].push({ onLoad: t, onProgress: e, onError: i });
          var m = new XMLHttpRequest();
          for (var g in (m.open('GET', o, !0),
          m.addEventListener(
            'load',
            function (t) {
              var e = this.response;
              eh.add(o, e);
              var i = rh[o];
              if ((delete rh[o], 200 === this.status || 0 === this.status)) {
                0 === this.status &&
                  console.warn('THREE.FileLoader: HTTP Status 0 received.');
                for (var n = 0, r = i.length; n < r; n++) {
                  (a = i[n]).onLoad && a.onLoad(e);
                }
                s.manager.itemEnd(o);
              } else {
                for (n = 0, r = i.length; n < r; n++) {
                  var a;
                  (a = i[n]).onError && a.onError(t);
                }
                s.manager.itemEnd(o), s.manager.itemError(o);
              }
            },
            !1
          ),
          m.addEventListener(
            'progress',
            function (t) {
              for (var e = rh[o], i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                r.onProgress && r.onProgress(t);
              }
            },
            !1
          ),
          m.addEventListener(
            'error',
            function (t) {
              var e = rh[o];
              delete rh[o];
              for (var i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                r.onError && r.onError(t);
              }
              s.manager.itemEnd(o), s.manager.itemError(o);
            },
            !1
          ),
          m.addEventListener(
            'abort',
            function (t) {
              var e = rh[o];
              delete rh[o];
              for (var i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                r.onError && r.onError(t);
              }
              s.manager.itemEnd(o), s.manager.itemError(o);
            },
            !1
          ),
          void 0 !== this.responseType && (m.responseType = this.responseType),
          void 0 !== this.withCredentials && (m.withCredentials = this.withCredentials),
          m.overrideMimeType &&
            m.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : 'text/plain'),
          this.requestHeader))
            m.setRequestHeader(g, this.requestHeader[g]);
          m.send(null);
        }
        return s.manager.itemStart(o), m;
      }
      rh[o].push({ onLoad: t, onProgress: e, onError: i });
    },
    setPath: function (t) {
      return (this.path = t), this;
    },
    setResponseType: function (t) {
      return (this.responseType = t), this;
    },
    setWithCredentials: function (t) {
      return (this.withCredentials = t), this;
    },
    setMimeType: function (t) {
      return (this.mimeType = t), this;
    },
    setRequestHeader: function (t) {
      return (this.requestHeader = t), this;
    }
  }),
    Object.assign(oh.prototype, {
      load: function (t, a, e, n) {
        var o = this,
          s = [],
          c = new Rs();
        c.image = s;
        var r = new ah(this.manager);
        function i(i) {
          r.load(
            t[i],
            function (t) {
              var e = o._parser(t, !0);
              (s[i] = {
                width: e.width,
                height: e.height,
                format: e.format,
                mipmaps: e.mipmaps
              }),
                6 === (h += 1) &&
                  (1 === e.mipmapCount && (c.minFilter = Pt),
                  (c.format = e.format),
                  (c.needsUpdate = !0),
                  a && a(c));
            },
            e,
            n
          );
        }
        if ((r.setPath(this.path), r.setResponseType('arraybuffer'), Array.isArray(t)))
          for (var h = 0, l = 0, u = t.length; l < u; ++l) i(l);
        else
          r.load(
            t,
            function (t) {
              var e = o._parser(t, !0);
              if (e.isCubemap)
                for (var i = e.mipmaps.length / e.mipmapCount, n = 0; n < i; n++) {
                  s[n] = { mipmaps: [] };
                  for (var r = 0; r < e.mipmapCount; r++)
                    s[n].mipmaps.push(e.mipmaps[n * e.mipmapCount + r]),
                      (s[n].format = e.format),
                      (s[n].width = e.width),
                      (s[n].height = e.height);
                }
              else
                (c.image.width = e.width),
                  (c.image.height = e.height),
                  (c.mipmaps = e.mipmaps);
              1 === e.mipmapCount && (c.minFilter = Pt),
                (c.format = e.format),
                (c.needsUpdate = !0),
                a && a(c);
            },
            e,
            n
          );
        return c;
      },
      setPath: function (t) {
        return (this.path = t), this;
      }
    }),
    Object.assign(sh.prototype, {
      load: function (t, i, e, n) {
        var r = this,
          a = new Li(),
          o = new ah(this.manager);
        return (
          o.setResponseType('arraybuffer'),
          o.load(
            t,
            function (t) {
              var e = r._parser(t);
              e &&
                (void 0 !== e.image
                  ? (a.image = e.image)
                  : void 0 !== e.data &&
                    ((a.image.width = e.width),
                    (a.image.height = e.height),
                    (a.image.data = e.data)),
                (a.wrapS = void 0 !== e.wrapS ? e.wrapS : Tt),
                (a.wrapT = void 0 !== e.wrapT ? e.wrapT : Tt),
                (a.magFilter = void 0 !== e.magFilter ? e.magFilter : Pt),
                (a.minFilter = void 0 !== e.minFilter ? e.minFilter : Ot),
                (a.anisotropy = void 0 !== e.anisotropy ? e.anisotropy : 1),
                void 0 !== e.format && (a.format = e.format),
                void 0 !== e.type && (a.type = e.type),
                void 0 !== e.mipmaps && (a.mipmaps = e.mipmaps),
                1 === e.mipmapCount && (a.minFilter = Pt),
                (a.needsUpdate = !0),
                i && i(a, e));
            },
            e,
            n
          ),
          a
        );
      }
    }),
    Object.assign(ch.prototype, {
      crossOrigin: 'anonymous',
      load: function (e, t, i, n) {
        void 0 === e && (e = ''),
          void 0 !== this.path && (e = this.path + e),
          (e = this.manager.resolveURL(e));
        var r = this,
          a = eh.get(e);
        if (void 0 !== a)
          return (
            r.manager.itemStart(e),
            setTimeout(function () {
              t && t(a), r.manager.itemEnd(e);
            }, 0),
            a
          );
        var o = document.createElementNS('http://www.w3.org/1999/xhtml', 'img');
        function s() {
          o.removeEventListener('load', s, !1),
            o.removeEventListener('error', c, !1),
            eh.add(e, this),
            t && t(this),
            r.manager.itemEnd(e);
        }
        function c(t) {
          o.removeEventListener('load', s, !1),
            o.removeEventListener('error', c, !1),
            n && n(t),
            r.manager.itemEnd(e),
            r.manager.itemError(e);
        }
        return (
          o.addEventListener('load', s, !1),
          o.addEventListener('error', c, !1),
          'data:' !== e.substr(0, 5) &&
            void 0 !== this.crossOrigin &&
            (o.crossOrigin = this.crossOrigin),
          r.manager.itemStart(e),
          (o.src = e),
          o
        );
      },
      setCrossOrigin: function (t) {
        return (this.crossOrigin = t), this;
      },
      setPath: function (t) {
        return (this.path = t), this;
      }
    }),
    Object.assign(hh.prototype, {
      crossOrigin: 'anonymous',
      load: function (t, i, e, n) {
        var r = new ha(),
          a = new ch(this.manager);
        a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
        var o = 0;
        function s(e) {
          a.load(
            t[e],
            function (t) {
              (r.images[e] = t), 6 === ++o && ((r.needsUpdate = !0), i && i(r));
            },
            void 0,
            n
          );
        }
        for (var c = 0; c < t.length; ++c) s(c);
        return r;
      },
      setCrossOrigin: function (t) {
        return (this.crossOrigin = t), this;
      },
      setPath: function (t) {
        return (this.path = t), this;
      }
    }),
    Object.assign(lh.prototype, {
      crossOrigin: 'anonymous',
      load: function (i, n, t, e) {
        var r = new Ei(),
          a = new ch(this.manager);
        return (
          a.setCrossOrigin(this.crossOrigin),
          a.setPath(this.path),
          a.load(
            i,
            function (t) {
              r.image = t;
              var e = 0 < i.search(/\.jpe?g$/i) || 0 === i.search(/^data\:image\/jpeg/);
              (r.format = e ? Xt : qt), (r.needsUpdate = !0), void 0 !== n && n(r);
            },
            t,
            e
          ),
          r
        );
      },
      setCrossOrigin: function (t) {
        return (this.crossOrigin = t), this;
      },
      setPath: function (t) {
        return (this.path = t), this;
      }
    }),
    Object.assign(uh.prototype, {
      getPoint: function () {
        return console.warn('THREE.Curve: .getPoint() not implemented.'), null;
      },
      getPointAt: function (t, e) {
        var i = this.getUtoTmapping(t);
        return this.getPoint(i, e);
      },
      getPoints: function (t) {
        void 0 === t && (t = 5);
        for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
        return e;
      },
      getSpacedPoints: function (t) {
        void 0 === t && (t = 5);
        for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
        return e;
      },
      getLength: function () {
        var t = this.getLengths();
        return t[t.length - 1];
      },
      getLengths: function (t) {
        if (
          (void 0 === t && (t = this.arcLengthDivisions),
          this.cacheArcLengths &&
            this.cacheArcLengths.length === t + 1 &&
            !this.needsUpdate)
        )
          return this.cacheArcLengths;
        this.needsUpdate = !1;
        var e,
          i,
          n = [],
          r = this.getPoint(0),
          a = 0;
        for (n.push(0), i = 1; i <= t; i++)
          (a += (e = this.getPoint(i / t)).distanceTo(r)), n.push(a), (r = e);
        return (this.cacheArcLengths = n);
      },
      updateArcLengths: function () {
        (this.needsUpdate = !0), this.getLengths();
      },
      getUtoTmapping: function (t, e) {
        var i,
          n = this.getLengths(),
          r = 0,
          a = n.length;
        i = e || t * n[a - 1];
        for (var o, s = 0, c = a - 1; s <= c; )
          if ((o = n[(r = Math.floor(s + (c - s) / 2))] - i) < 0) s = r + 1;
          else {
            if (!(0 < o)) {
              c = r;
              break;
            }
            c = r - 1;
          }
        if (n[(r = c)] === i) return r / (a - 1);
        var h = n[r];
        return (r + (i - h) / (n[r + 1] - h)) / (a - 1);
      },
      getTangent: function (t) {
        var e = t - 1e-4,
          i = t + 1e-4;
        e < 0 && (e = 0), 1 < i && (i = 1);
        var n = this.getPoint(e);
        return this.getPoint(i).clone().sub(n).normalize();
      },
      getTangentAt: function (t) {
        var e = this.getUtoTmapping(t);
        return this.getTangent(e);
      },
      computeFrenetFrames: function (t, e) {
        var i,
          n,
          r,
          a = new je(),
          o = [],
          s = [],
          c = [],
          h = new je(),
          l = new Ve();
        for (i = 0; i <= t; i++)
          (n = i / t), (o[i] = this.getTangentAt(n)), o[i].normalize();
        (s[0] = new je()), (c[0] = new je());
        var u = Number.MAX_VALUE,
          p = Math.abs(o[0].x),
          d = Math.abs(o[0].y),
          f = Math.abs(o[0].z);
        for (
          p <= u && ((u = p), a.set(1, 0, 0)),
            d <= u && ((u = d), a.set(0, 1, 0)),
            f <= u && a.set(0, 0, 1),
            h.crossVectors(o[0], a).normalize(),
            s[0].crossVectors(o[0], h),
            c[0].crossVectors(o[0], s[0]),
            i = 1;
          i <= t;
          i++
        )
          (s[i] = s[i - 1].clone()),
            (c[i] = c[i - 1].clone()),
            h.crossVectors(o[i - 1], o[i]),
            h.length() > Number.EPSILON &&
              (h.normalize(),
              (r = Math.acos(Ge.clamp(o[i - 1].dot(o[i]), -1, 1))),
              s[i].applyMatrix4(l.makeRotationAxis(h, r))),
            c[i].crossVectors(o[i], s[i]);
        if (!0 === e)
          for (
            r = Math.acos(Ge.clamp(s[0].dot(s[t]), -1, 1)),
              r /= t,
              0 < o[0].dot(h.crossVectors(s[0], s[t])) && (r = -r),
              i = 1;
            i <= t;
            i++
          )
            s[i].applyMatrix4(l.makeRotationAxis(o[i], r * i)),
              c[i].crossVectors(o[i], s[i]);
        return { tangents: o, normals: s, binormals: c };
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (this.arcLengthDivisions = t.arcLengthDivisions), this;
      },
      toJSON: function () {
        var t = { metadata: { version: 4.5, type: 'Curve', generator: 'Curve.toJSON' } };
        return (t.arcLengthDivisions = this.arcLengthDivisions), (t.type = this.type), t;
      },
      fromJSON: function (t) {
        return (this.arcLengthDivisions = t.arcLengthDivisions), this;
      }
    }),
    (((ph.prototype = Object.create(
      uh.prototype
    )).constructor = ph).prototype.isEllipseCurve = !0),
    (ph.prototype.getPoint = function (t, e) {
      for (
        var i = e || new He(),
          n = 2 * Math.PI,
          r = this.aEndAngle - this.aStartAngle,
          a = Math.abs(r) < Number.EPSILON;
        r < 0;

      )
        r += n;
      for (; n < r; ) r -= n;
      r < Number.EPSILON && (r = a ? 0 : n),
        !0 !== this.aClockwise || a || (r === n ? (r = -n) : (r -= n));
      var o = this.aStartAngle + t * r,
        s = this.aX + this.xRadius * Math.cos(o),
        c = this.aY + this.yRadius * Math.sin(o);
      if (0 !== this.aRotation) {
        var h = Math.cos(this.aRotation),
          l = Math.sin(this.aRotation),
          u = s - this.aX,
          p = c - this.aY;
        (s = u * h - p * l + this.aX), (c = u * l + p * h + this.aY);
      }
      return i.set(s, c);
    }),
    (ph.prototype.copy = function (t) {
      return (
        uh.prototype.copy.call(this, t),
        (this.aX = t.aX),
        (this.aY = t.aY),
        (this.xRadius = t.xRadius),
        (this.yRadius = t.yRadius),
        (this.aStartAngle = t.aStartAngle),
        (this.aEndAngle = t.aEndAngle),
        (this.aClockwise = t.aClockwise),
        (this.aRotation = t.aRotation),
        this
      );
    }),
    (ph.prototype.toJSON = function () {
      var t = uh.prototype.toJSON.call(this);
      return (
        (t.aX = this.aX),
        (t.aY = this.aY),
        (t.xRadius = this.xRadius),
        (t.yRadius = this.yRadius),
        (t.aStartAngle = this.aStartAngle),
        (t.aEndAngle = this.aEndAngle),
        (t.aClockwise = this.aClockwise),
        (t.aRotation = this.aRotation),
        t
      );
    }),
    (ph.prototype.fromJSON = function (t) {
      return (
        uh.prototype.fromJSON.call(this, t),
        (this.aX = t.aX),
        (this.aY = t.aY),
        (this.xRadius = t.xRadius),
        (this.yRadius = t.yRadius),
        (this.aStartAngle = t.aStartAngle),
        (this.aEndAngle = t.aEndAngle),
        (this.aClockwise = t.aClockwise),
        (this.aRotation = t.aRotation),
        this
      );
    }),
    (((dh.prototype = Object.create(
      ph.prototype
    )).constructor = dh).prototype.isArcCurve = !0);
  var mh = new je(),
    gh = new fh(),
    vh = new fh(),
    yh = new fh();
  function xh(t, e, i, n) {
    uh.call(this),
      (this.type = 'CatmullRomCurve3'),
      (this.points = t || []),
      (this.closed = e || !1),
      (this.curveType = i || 'centripetal'),
      (this.tension = n || 0.5);
  }
  function bh(t, e, i, n, r) {
    var a = 0.5 * (n - e),
      o = 0.5 * (r - i),
      s = t * t;
    return (
      (2 * i - 2 * n + a + o) * (t * s) + (-3 * i + 3 * n - 2 * a - o) * s + a * t + i
    );
  }
  function _h(t, e, i, n) {
    return (o = 1 - t) * o * e + 2 * (1 - (a = t)) * a * i + (r = t) * r * n;
    var r, a, o;
  }
  function wh(t, e, i, n, r) {
    return (
      (h = 1 - t) * h * h * e +
      3 * (c = 1 - (s = t)) * c * s * i +
      3 * (1 - (o = t)) * o * o * n +
      (a = t) * a * a * r
    );
    var a, o, s, c, h;
  }
  function Mh(t, e, i, n) {
    uh.call(this),
      (this.type = 'CubicBezierCurve'),
      (this.v0 = t || new He()),
      (this.v1 = e || new He()),
      (this.v2 = i || new He()),
      (this.v3 = n || new He());
  }
  function Eh(t, e, i, n) {
    uh.call(this),
      (this.type = 'CubicBezierCurve3'),
      (this.v0 = t || new je()),
      (this.v1 = e || new je()),
      (this.v2 = i || new je()),
      (this.v3 = n || new je());
  }
  function Th(t, e) {
    uh.call(this),
      (this.type = 'LineCurve'),
      (this.v1 = t || new He()),
      (this.v2 = e || new He());
  }
  function Sh(t, e) {
    uh.call(this),
      (this.type = 'LineCurve3'),
      (this.v1 = t || new je()),
      (this.v2 = e || new je());
  }
  function Ah(t, e, i) {
    uh.call(this),
      (this.type = 'QuadraticBezierCurve'),
      (this.v0 = t || new He()),
      (this.v1 = e || new He()),
      (this.v2 = i || new He());
  }
  function Lh(t, e, i) {
    uh.call(this),
      (this.type = 'QuadraticBezierCurve3'),
      (this.v0 = t || new je()),
      (this.v1 = e || new je()),
      (this.v2 = i || new je());
  }
  function Rh(t) {
    uh.call(this), (this.type = 'SplineCurve'), (this.points = t || []);
  }
  (((xh.prototype = Object.create(
    uh.prototype
  )).constructor = xh).prototype.isCatmullRomCurve3 = !0),
    (xh.prototype.getPoint = function (t, e) {
      var i,
        n,
        r,
        a,
        o = e || new je(),
        s = this.points,
        c = s.length,
        h = (c - (this.closed ? 0 : 1)) * t,
        l = Math.floor(h),
        u = h - l;
      if (
        (this.closed
          ? (l += 0 < l ? 0 : (Math.floor(Math.abs(l) / c) + 1) * c)
          : 0 === u && l === c - 1 && ((l = c - 2), (u = 1)),
        (i =
          this.closed || 0 < l
            ? s[(l - 1) % c]
            : (mh.subVectors(s[0], s[1]).add(s[0]), mh)),
        (n = s[l % c]),
        (r = s[(l + 1) % c]),
        (a =
          this.closed || l + 2 < c
            ? s[(l + 2) % c]
            : (mh.subVectors(s[c - 1], s[c - 2]).add(s[c - 1]), mh)),
        'centripetal' === this.curveType || 'chordal' === this.curveType)
      ) {
        var p = 'chordal' === this.curveType ? 0.5 : 0.25,
          d = Math.pow(i.distanceToSquared(n), p),
          f = Math.pow(n.distanceToSquared(r), p),
          m = Math.pow(r.distanceToSquared(a), p);
        f < 1e-4 && (f = 1),
          d < 1e-4 && (d = f),
          m < 1e-4 && (m = f),
          gh.initNonuniformCatmullRom(i.x, n.x, r.x, a.x, d, f, m),
          vh.initNonuniformCatmullRom(i.y, n.y, r.y, a.y, d, f, m),
          yh.initNonuniformCatmullRom(i.z, n.z, r.z, a.z, d, f, m);
      } else
        'catmullrom' === this.curveType &&
          (gh.initCatmullRom(i.x, n.x, r.x, a.x, this.tension),
          vh.initCatmullRom(i.y, n.y, r.y, a.y, this.tension),
          yh.initCatmullRom(i.z, n.z, r.z, a.z, this.tension));
      return o.set(gh.calc(u), vh.calc(u), yh.calc(u)), o;
    }),
    (xh.prototype.copy = function (t) {
      uh.prototype.copy.call(this, t), (this.points = []);
      for (var e = 0, i = t.points.length; e < i; e++) {
        var n = t.points[e];
        this.points.push(n.clone());
      }
      return (
        (this.closed = t.closed),
        (this.curveType = t.curveType),
        (this.tension = t.tension),
        this
      );
    }),
    (xh.prototype.toJSON = function () {
      var t = uh.prototype.toJSON.call(this);
      t.points = [];
      for (var e = 0, i = this.points.length; e < i; e++) {
        var n = this.points[e];
        t.points.push(n.toArray());
      }
      return (
        (t.closed = this.closed),
        (t.curveType = this.curveType),
        (t.tension = this.tension),
        t
      );
    }),
    (xh.prototype.fromJSON = function (t) {
      uh.prototype.fromJSON.call(this, t), (this.points = []);
      for (var e = 0, i = t.points.length; e < i; e++) {
        var n = t.points[e];
        this.points.push(new je().fromArray(n));
      }
      return (
        (this.closed = t.closed),
        (this.curveType = t.curveType),
        (this.tension = t.tension),
        this
      );
    }),
    (((Mh.prototype = Object.create(
      uh.prototype
    )).constructor = Mh).prototype.isCubicBezierCurve = !0),
    (Mh.prototype.getPoint = function (t, e) {
      var i = e || new He(),
        n = this.v0,
        r = this.v1,
        a = this.v2,
        o = this.v3;
      return i.set(wh(t, n.x, r.x, a.x, o.x), wh(t, n.y, r.y, a.y, o.y)), i;
    }),
    (Mh.prototype.copy = function (t) {
      return (
        uh.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
      );
    }),
    (Mh.prototype.toJSON = function () {
      var t = uh.prototype.toJSON.call(this);
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        (t.v3 = this.v3.toArray()),
        t
      );
    }),
    (Mh.prototype.fromJSON = function (t) {
      return (
        uh.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
      );
    }),
    (((Eh.prototype = Object.create(
      uh.prototype
    )).constructor = Eh).prototype.isCubicBezierCurve3 = !0),
    (Eh.prototype.getPoint = function (t, e) {
      var i = e || new je(),
        n = this.v0,
        r = this.v1,
        a = this.v2,
        o = this.v3;
      return (
        i.set(
          wh(t, n.x, r.x, a.x, o.x),
          wh(t, n.y, r.y, a.y, o.y),
          wh(t, n.z, r.z, a.z, o.z)
        ),
        i
      );
    }),
    (Eh.prototype.copy = function (t) {
      return (
        uh.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this.v3.copy(t.v3),
        this
      );
    }),
    (Eh.prototype.toJSON = function () {
      var t = uh.prototype.toJSON.call(this);
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        (t.v3 = this.v3.toArray()),
        t
      );
    }),
    (Eh.prototype.fromJSON = function (t) {
      return (
        uh.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this.v3.fromArray(t.v3),
        this
      );
    }),
    (((Th.prototype = Object.create(
      uh.prototype
    )).constructor = Th).prototype.isLineCurve = !0),
    (Th.prototype.getPoint = function (t, e) {
      var i = e || new He();
      return (
        1 === t
          ? i.copy(this.v2)
          : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)),
        i
      );
    }),
    (Th.prototype.getPointAt = function (t, e) {
      return this.getPoint(t, e);
    }),
    (Th.prototype.getTangent = function () {
      return this.v2.clone().sub(this.v1).normalize();
    }),
    (Th.prototype.copy = function (t) {
      return (
        uh.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
      );
    }),
    (Th.prototype.toJSON = function () {
      var t = uh.prototype.toJSON.call(this);
      return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
    }),
    (Th.prototype.fromJSON = function (t) {
      return (
        uh.prototype.fromJSON.call(this, t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      );
    }),
    (((Sh.prototype = Object.create(
      uh.prototype
    )).constructor = Sh).prototype.isLineCurve3 = !0),
    (Sh.prototype.getPoint = function (t, e) {
      var i = e || new je();
      return (
        1 === t
          ? i.copy(this.v2)
          : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(t).add(this.v1)),
        i
      );
    }),
    (Sh.prototype.getPointAt = function (t, e) {
      return this.getPoint(t, e);
    }),
    (Sh.prototype.copy = function (t) {
      return (
        uh.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
      );
    }),
    (Sh.prototype.toJSON = function () {
      var t = uh.prototype.toJSON.call(this);
      return (t.v1 = this.v1.toArray()), (t.v2 = this.v2.toArray()), t;
    }),
    (Sh.prototype.fromJSON = function (t) {
      return (
        uh.prototype.fromJSON.call(this, t),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      );
    }),
    (((Ah.prototype = Object.create(
      uh.prototype
    )).constructor = Ah).prototype.isQuadraticBezierCurve = !0),
    (Ah.prototype.getPoint = function (t, e) {
      var i = e || new He(),
        n = this.v0,
        r = this.v1,
        a = this.v2;
      return i.set(_h(t, n.x, r.x, a.x), _h(t, n.y, r.y, a.y)), i;
    }),
    (Ah.prototype.copy = function (t) {
      return (
        uh.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
      );
    }),
    (Ah.prototype.toJSON = function () {
      var t = uh.prototype.toJSON.call(this);
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        t
      );
    }),
    (Ah.prototype.fromJSON = function (t) {
      return (
        uh.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      );
    }),
    (((Lh.prototype = Object.create(
      uh.prototype
    )).constructor = Lh).prototype.isQuadraticBezierCurve3 = !0),
    (Lh.prototype.getPoint = function (t, e) {
      var i = e || new je(),
        n = this.v0,
        r = this.v1,
        a = this.v2;
      return i.set(_h(t, n.x, r.x, a.x), _h(t, n.y, r.y, a.y), _h(t, n.z, r.z, a.z)), i;
    }),
    (Lh.prototype.copy = function (t) {
      return (
        uh.prototype.copy.call(this, t),
        this.v0.copy(t.v0),
        this.v1.copy(t.v1),
        this.v2.copy(t.v2),
        this
      );
    }),
    (Lh.prototype.toJSON = function () {
      var t = uh.prototype.toJSON.call(this);
      return (
        (t.v0 = this.v0.toArray()),
        (t.v1 = this.v1.toArray()),
        (t.v2 = this.v2.toArray()),
        t
      );
    }),
    (Lh.prototype.fromJSON = function (t) {
      return (
        uh.prototype.fromJSON.call(this, t),
        this.v0.fromArray(t.v0),
        this.v1.fromArray(t.v1),
        this.v2.fromArray(t.v2),
        this
      );
    }),
    (((Rh.prototype = Object.create(
      uh.prototype
    )).constructor = Rh).prototype.isSplineCurve = !0),
    (Rh.prototype.getPoint = function (t, e) {
      var i = e || new He(),
        n = this.points,
        r = (n.length - 1) * t,
        a = Math.floor(r),
        o = r - a,
        s = n[0 === a ? a : a - 1],
        c = n[a],
        h = n[a > n.length - 2 ? n.length - 1 : a + 1],
        l = n[a > n.length - 3 ? n.length - 1 : a + 2];
      return i.set(bh(o, s.x, c.x, h.x, l.x), bh(o, s.y, c.y, h.y, l.y)), i;
    }),
    (Rh.prototype.copy = function (t) {
      uh.prototype.copy.call(this, t), (this.points = []);
      for (var e = 0, i = t.points.length; e < i; e++) {
        var n = t.points[e];
        this.points.push(n.clone());
      }
      return this;
    }),
    (Rh.prototype.toJSON = function () {
      var t = uh.prototype.toJSON.call(this);
      t.points = [];
      for (var e = 0, i = this.points.length; e < i; e++) {
        var n = this.points[e];
        t.points.push(n.toArray());
      }
      return t;
    }),
    (Rh.prototype.fromJSON = function (t) {
      uh.prototype.fromJSON.call(this, t), (this.points = []);
      for (var e = 0, i = t.points.length; e < i; e++) {
        var n = t.points[e];
        this.points.push(new He().fromArray(n));
      }
      return this;
    });
  var Ph = Object.freeze({
    ArcCurve: dh,
    CatmullRomCurve3: xh,
    CubicBezierCurve: Mh,
    CubicBezierCurve3: Eh,
    EllipseCurve: ph,
    LineCurve: Th,
    LineCurve3: Sh,
    QuadraticBezierCurve: Ah,
    QuadraticBezierCurve3: Lh,
    SplineCurve: Rh
  });
  function Ch() {
    uh.call(this), (this.type = 'CurvePath'), (this.curves = []), (this.autoClose = !1);
  }
  function Oh(t) {
    Ch.call(this),
      (this.type = 'Path'),
      (this.currentPoint = new He()),
      t && this.setFromPoints(t);
  }
  function Ih(t) {
    Oh.call(this, t),
      (this.uuid = Ge.generateUUID()),
      (this.type = 'Shape'),
      (this.holes = []);
  }
  function Nh(t, e) {
    bn.call(this),
      (this.type = 'Light'),
      (this.color = new Hi(t)),
      (this.intensity = void 0 !== e ? e : 1),
      (this.receiveShadow = void 0);
  }
  function Dh(t, e, i) {
    Nh.call(this, t, i),
      (this.type = 'HemisphereLight'),
      (this.castShadow = void 0),
      this.position.copy(bn.DefaultUp),
      this.updateMatrix(),
      (this.groundColor = new Hi(e));
  }
  function Uh(t) {
    (this.camera = t),
      (this.bias = 0),
      (this.radius = 1),
      (this.mapSize = new He(512, 512)),
      (this.map = null),
      (this.matrix = new Ve());
  }
  function Bh() {
    Uh.call(this, new as(50, 1, 0.5, 500));
  }
  function Fh(t, e, i, n, r, a) {
    Nh.call(this, t, e),
      (this.type = 'SpotLight'),
      this.position.copy(bn.DefaultUp),
      this.updateMatrix(),
      (this.target = new bn()),
      Object.defineProperty(this, 'power', {
        get: function () {
          return this.intensity * Math.PI;
        },
        set: function (t) {
          this.intensity = t / Math.PI;
        }
      }),
      (this.distance = void 0 !== i ? i : 0),
      (this.angle = void 0 !== n ? n : Math.PI / 3),
      (this.penumbra = void 0 !== r ? r : 0),
      (this.decay = void 0 !== a ? a : 1),
      (this.shadow = new Bh());
  }
  function zh(t, e, i, n) {
    Nh.call(this, t, e),
      (this.type = 'PointLight'),
      Object.defineProperty(this, 'power', {
        get: function () {
          return 4 * this.intensity * Math.PI;
        },
        set: function (t) {
          this.intensity = t / (4 * Math.PI);
        }
      }),
      (this.distance = void 0 !== i ? i : 0),
      (this.decay = void 0 !== n ? n : 1),
      (this.shadow = new Uh(new as(90, 1, 0.5, 500)));
  }
  function Gh(t, e, i, n, r, a) {
    rs.call(this),
      (this.type = 'OrthographicCamera'),
      (this.zoom = 1),
      (this.view = null),
      (this.left = t),
      (this.right = e),
      (this.top = i),
      (this.bottom = n),
      (this.near = void 0 !== r ? r : 0.1),
      (this.far = void 0 !== a ? a : 2e3),
      this.updateProjectionMatrix();
  }
  function Hh() {
    Uh.call(this, new Gh(-5, 5, 5, -5, 0.5, 500));
  }
  function Vh(t, e) {
    Nh.call(this, t, e),
      (this.type = 'DirectionalLight'),
      this.position.copy(bn.DefaultUp),
      this.updateMatrix(),
      (this.target = new bn()),
      (this.shadow = new Hh());
  }
  function kh(t, e) {
    Nh.call(this, t, e), (this.type = 'AmbientLight'), (this.castShadow = void 0);
  }
  function jh(t, e, i, n) {
    Nh.call(this, t, e),
      (this.type = 'RectAreaLight'),
      (this.width = void 0 !== i ? i : 10),
      (this.height = void 0 !== n ? n : 10);
  }
  (Ch.prototype = Object.assign(Object.create(uh.prototype), {
    constructor: Ch,
    add: function (t) {
      this.curves.push(t);
    },
    closePath: function () {
      var t = this.curves[0].getPoint(0),
        e = this.curves[this.curves.length - 1].getPoint(1);
      t.equals(e) || this.curves.push(new Th(e, t));
    },
    getPoint: function (t) {
      for (
        var e = t * this.getLength(), i = this.getCurveLengths(), n = 0;
        n < i.length;

      ) {
        if (i[n] >= e) {
          var r = i[n] - e,
            a = this.curves[n],
            o = a.getLength(),
            s = 0 === o ? 0 : 1 - r / o;
          return a.getPointAt(s);
        }
        n++;
      }
      return null;
    },
    getLength: function () {
      var t = this.getCurveLengths();
      return t[t.length - 1];
    },
    updateArcLengths: function () {
      (this.needsUpdate = !0), (this.cacheLengths = null), this.getCurveLengths();
    },
    getCurveLengths: function () {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
        return this.cacheLengths;
      for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++)
        (e += this.curves[i].getLength()), t.push(e);
      return (this.cacheLengths = t);
    },
    getSpacedPoints: function (t) {
      void 0 === t && (t = 40);
      for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
      return this.autoClose && e.push(e[0]), e;
    },
    getPoints: function (t) {
      t = t || 12;
      for (var e, i = [], n = 0, r = this.curves; n < r.length; n++)
        for (
          var a = r[n],
            o =
              a && a.isEllipseCurve
                ? 2 * t
                : a && (a.isLineCurve || a.isLineCurve3)
                ? 1
                : a && a.isSplineCurve
                ? t * a.points.length
                : t,
            s = a.getPoints(o),
            c = 0;
          c < s.length;
          c++
        ) {
          var h = s[c];
          (e && e.equals(h)) || (i.push(h), (e = h));
        }
      return (
        this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i
      );
    },
    copy: function (t) {
      uh.prototype.copy.call(this, t), (this.curves = []);
      for (var e = 0, i = t.curves.length; e < i; e++) {
        var n = t.curves[e];
        this.curves.push(n.clone());
      }
      return (this.autoClose = t.autoClose), this;
    },
    toJSON: function () {
      var t = uh.prototype.toJSON.call(this);
      (t.autoClose = this.autoClose), (t.curves = []);
      for (var e = 0, i = this.curves.length; e < i; e++) {
        var n = this.curves[e];
        t.curves.push(n.toJSON());
      }
      return t;
    },
    fromJSON: function (t) {
      uh.prototype.fromJSON.call(this, t),
        (this.autoClose = t.autoClose),
        (this.curves = []);
      for (var e = 0, i = t.curves.length; e < i; e++) {
        var n = t.curves[e];
        this.curves.push(new Ph[n.type]().fromJSON(n));
      }
      return this;
    }
  })),
    (Oh.prototype = Object.assign(Object.create(Ch.prototype), {
      constructor: Oh,
      setFromPoints: function (t) {
        this.moveTo(t[0].x, t[0].y);
        for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y);
      },
      moveTo: function (t, e) {
        this.currentPoint.set(t, e);
      },
      lineTo: function (t, e) {
        var i = new Th(this.currentPoint.clone(), new He(t, e));
        this.curves.push(i), this.currentPoint.set(t, e);
      },
      quadraticCurveTo: function (t, e, i, n) {
        var r = new Ah(this.currentPoint.clone(), new He(t, e), new He(i, n));
        this.curves.push(r), this.currentPoint.set(i, n);
      },
      bezierCurveTo: function (t, e, i, n, r, a) {
        var o = new Mh(
          this.currentPoint.clone(),
          new He(t, e),
          new He(i, n),
          new He(r, a)
        );
        this.curves.push(o), this.currentPoint.set(r, a);
      },
      splineThru: function (t) {
        var e = new Rh([this.currentPoint.clone()].concat(t));
        this.curves.push(e), this.currentPoint.copy(t[t.length - 1]);
      },
      arc: function (t, e, i, n, r, a) {
        var o = this.currentPoint.x,
          s = this.currentPoint.y;
        this.absarc(t + o, e + s, i, n, r, a);
      },
      absarc: function (t, e, i, n, r, a) {
        this.absellipse(t, e, i, i, n, r, a);
      },
      ellipse: function (t, e, i, n, r, a, o, s) {
        var c = this.currentPoint.x,
          h = this.currentPoint.y;
        this.absellipse(t + c, e + h, i, n, r, a, o, s);
      },
      absellipse: function (t, e, i, n, r, a, o, s) {
        var c = new ph(t, e, i, n, r, a, o, s);
        if (0 < this.curves.length) {
          var h = c.getPoint(0);
          h.equals(this.currentPoint) || this.lineTo(h.x, h.y);
        }
        this.curves.push(c);
        var l = c.getPoint(1);
        this.currentPoint.copy(l);
      },
      copy: function (t) {
        return (
          Ch.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
        );
      },
      toJSON: function () {
        var t = Ch.prototype.toJSON.call(this);
        return (t.currentPoint = this.currentPoint.toArray()), t;
      },
      fromJSON: function (t) {
        return (
          Ch.prototype.fromJSON.call(this, t),
          this.currentPoint.fromArray(t.currentPoint),
          this
        );
      }
    })),
    (Ih.prototype = Object.assign(Object.create(Oh.prototype), {
      constructor: Ih,
      getPointsHoles: function (t) {
        for (var e = [], i = 0, n = this.holes.length; i < n; i++)
          e[i] = this.holes[i].getPoints(t);
        return e;
      },
      extractPoints: function (t) {
        return { shape: this.getPoints(t), holes: this.getPointsHoles(t) };
      },
      copy: function (t) {
        Oh.prototype.copy.call(this, t), (this.holes = []);
        for (var e = 0, i = t.holes.length; e < i; e++) {
          var n = t.holes[e];
          this.holes.push(n.clone());
        }
        return this;
      },
      toJSON: function () {
        var t = Oh.prototype.toJSON.call(this);
        (t.uuid = this.uuid), (t.holes = []);
        for (var e = 0, i = this.holes.length; e < i; e++) {
          var n = this.holes[e];
          t.holes.push(n.toJSON());
        }
        return t;
      },
      fromJSON: function (t) {
        Oh.prototype.fromJSON.call(this, t), (this.uuid = t.uuid), (this.holes = []);
        for (var e = 0, i = t.holes.length; e < i; e++) {
          var n = t.holes[e];
          this.holes.push(new Oh().fromJSON(n));
        }
        return this;
      }
    })),
    (Nh.prototype = Object.assign(Object.create(bn.prototype), {
      constructor: Nh,
      isLight: !0,
      copy: function (t) {
        return (
          bn.prototype.copy.call(this, t),
          this.color.copy(t.color),
          (this.intensity = t.intensity),
          this
        );
      },
      toJSON: function (t) {
        var e = bn.prototype.toJSON.call(this, t);
        return (
          (e.object.color = this.color.getHex()),
          (e.object.intensity = this.intensity),
          void 0 !== this.groundColor &&
            (e.object.groundColor = this.groundColor.getHex()),
          void 0 !== this.distance && (e.object.distance = this.distance),
          void 0 !== this.angle && (e.object.angle = this.angle),
          void 0 !== this.decay && (e.object.decay = this.decay),
          void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
          void 0 !== this.shadow && (e.object.shadow = this.shadow.toJSON()),
          e
        );
      }
    })),
    (Dh.prototype = Object.assign(Object.create(Nh.prototype), {
      constructor: Dh,
      isHemisphereLight: !0,
      copy: function (t) {
        return (
          Nh.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
        );
      }
    })),
    Object.assign(Uh.prototype, {
      copy: function (t) {
        return (
          (this.camera = t.camera.clone()),
          (this.bias = t.bias),
          (this.radius = t.radius),
          this.mapSize.copy(t.mapSize),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      toJSON: function () {
        var t = {};
        return (
          0 !== this.bias && (t.bias = this.bias),
          1 !== this.radius && (t.radius = this.radius),
          (512 === this.mapSize.x && 512 === this.mapSize.y) ||
            (t.mapSize = this.mapSize.toArray()),
          (t.camera = this.camera.toJSON(!1).object),
          delete t.camera.matrix,
          t
        );
      }
    }),
    (Bh.prototype = Object.assign(Object.create(Uh.prototype), {
      constructor: Bh,
      isSpotLightShadow: !0,
      update: function (t) {
        var e = this.camera,
          i = 2 * Ge.RAD2DEG * t.angle,
          n = this.mapSize.width / this.mapSize.height,
          r = t.distance || e.far;
        (i === e.fov && n === e.aspect && r === e.far) ||
          ((e.fov = i), (e.aspect = n), (e.far = r), e.updateProjectionMatrix());
      }
    })),
    (Fh.prototype = Object.assign(Object.create(Nh.prototype), {
      constructor: Fh,
      isSpotLight: !0,
      copy: function (t) {
        return (
          Nh.prototype.copy.call(this, t),
          (this.distance = t.distance),
          (this.angle = t.angle),
          (this.penumbra = t.penumbra),
          (this.decay = t.decay),
          (this.target = t.target.clone()),
          (this.shadow = t.shadow.clone()),
          this
        );
      }
    })),
    (zh.prototype = Object.assign(Object.create(Nh.prototype), {
      constructor: zh,
      isPointLight: !0,
      copy: function (t) {
        return (
          Nh.prototype.copy.call(this, t),
          (this.distance = t.distance),
          (this.decay = t.decay),
          (this.shadow = t.shadow.clone()),
          this
        );
      }
    })),
    (Gh.prototype = Object.assign(Object.create(rs.prototype), {
      constructor: Gh,
      isOrthographicCamera: !0,
      copy: function (t, e) {
        return (
          rs.prototype.copy.call(this, t, e),
          (this.left = t.left),
          (this.right = t.right),
          (this.top = t.top),
          (this.bottom = t.bottom),
          (this.near = t.near),
          (this.far = t.far),
          (this.zoom = t.zoom),
          (this.view = null === t.view ? null : Object.assign({}, t.view)),
          this
        );
      },
      setViewOffset: function (t, e, i, n, r, a) {
        null === this.view &&
          (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          }),
          (this.view.enabled = !0),
          (this.view.fullWidth = t),
          (this.view.fullHeight = e),
          (this.view.offsetX = i),
          (this.view.offsetY = n),
          (this.view.width = r),
          (this.view.height = a),
          this.updateProjectionMatrix();
      },
      clearViewOffset: function () {
        null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix();
      },
      updateProjectionMatrix: function () {
        var t = (this.right - this.left) / (2 * this.zoom),
          e = (this.top - this.bottom) / (2 * this.zoom),
          i = (this.right + this.left) / 2,
          n = (this.top + this.bottom) / 2,
          r = i - t,
          a = i + t,
          o = n + e,
          s = n - e;
        if (null !== this.view && this.view.enabled) {
          var c = this.zoom / (this.view.width / this.view.fullWidth),
            h = this.zoom / (this.view.height / this.view.fullHeight),
            l = (this.right - this.left) / this.view.width,
            u = (this.top - this.bottom) / this.view.height;
          (a = (r += l * (this.view.offsetX / c)) + l * (this.view.width / c)),
            (s = (o -= u * (this.view.offsetY / h)) - u * (this.view.height / h));
        }
        this.projectionMatrix.makeOrthographic(r, a, o, s, this.near, this.far),
          this.projectionMatrixInverse.getInverse(this.projectionMatrix);
      },
      toJSON: function (t) {
        var e = bn.prototype.toJSON.call(this, t);
        return (
          (e.object.zoom = this.zoom),
          (e.object.left = this.left),
          (e.object.right = this.right),
          (e.object.top = this.top),
          (e.object.bottom = this.bottom),
          (e.object.near = this.near),
          (e.object.far = this.far),
          null !== this.view && (e.object.view = Object.assign({}, this.view)),
          e
        );
      }
    })),
    (Hh.prototype = Object.assign(Object.create(Uh.prototype), { constructor: Hh })),
    (Vh.prototype = Object.assign(Object.create(Nh.prototype), {
      constructor: Vh,
      isDirectionalLight: !0,
      copy: function (t) {
        return (
          Nh.prototype.copy.call(this, t),
          (this.target = t.target.clone()),
          (this.shadow = t.shadow.clone()),
          this
        );
      }
    })),
    (kh.prototype = Object.assign(Object.create(Nh.prototype), {
      constructor: kh,
      isAmbientLight: !0
    })),
    (jh.prototype = Object.assign(Object.create(Nh.prototype), {
      constructor: jh,
      isRectAreaLight: !0,
      copy: function (t) {
        return (
          Nh.prototype.copy.call(this, t),
          (this.width = t.width),
          (this.height = t.height),
          this
        );
      },
      toJSON: function (t) {
        var e = Nh.prototype.toJSON.call(this, t);
        return (e.object.width = this.width), (e.object.height = this.height), e;
      }
    }));
  var Wh = {
    arraySlice: function (t, e, i) {
      return Wh.isTypedArray(t)
        ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length))
        : t.slice(e, i);
    },
    convertArray: function (t, e, i) {
      return !t || (!i && t.constructor === e)
        ? t
        : 'number' == typeof e.BYTES_PER_ELEMENT
        ? new e(t)
        : Array.prototype.slice.call(t);
    },
    isTypedArray: function (t) {
      return ArrayBuffer.isView(t) && !(t instanceof DataView);
    },
    getKeyframeOrder: function (i) {
      for (var t = i.length, e = new Array(t), n = 0; n !== t; ++n) e[n] = n;
      return (
        e.sort(function (t, e) {
          return i[t] - i[e];
        }),
        e
      );
    },
    sortedArray: function (t, e, i) {
      for (var n = t.length, r = new t.constructor(n), a = 0, o = 0; o !== n; ++a)
        for (var s = i[a] * e, c = 0; c !== e; ++c) r[o++] = t[s + c];
      return r;
    },
    flattenJSON: function (t, e, i, n) {
      for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[n]; ) a = t[r++];
      if (void 0 !== a) {
        var o = a[n];
        if (void 0 !== o)
          if (Array.isArray(o))
            for (
              ;
              void 0 !== (o = a[n]) && (e.push(a.time), i.push.apply(i, o)),
                void 0 !== (a = t[r++]);

            );
          else if (void 0 !== o.toArray)
            for (
              ;
              void 0 !== (o = a[n]) && (e.push(a.time), o.toArray(i, i.length)),
                void 0 !== (a = t[r++]);

            );
          else
            for (
              ;
              void 0 !== (o = a[n]) && (e.push(a.time), i.push(o)),
                void 0 !== (a = t[r++]);

            );
      }
    }
  };
  function Xh(t, e, i, n) {
    (this.parameterPositions = t),
      (this._cachedIndex = 0),
      (this.resultBuffer = void 0 !== n ? n : new e.constructor(i)),
      (this.sampleValues = e),
      (this.valueSize = i);
  }
  function qh(t, e, i, n) {
    Xh.call(this, t, e, i, n),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0);
  }
  function Yh(t, e, i, n) {
    Xh.call(this, t, e, i, n);
  }
  function Jh(t, e, i, n) {
    Xh.call(this, t, e, i, n);
  }
  function Zh(t, e, i, n) {
    if (void 0 === t) throw new Error('THREE.KeyframeTrack: track name is undefined');
    if (void 0 === e || 0 === e.length)
      throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + t);
    (this.name = t),
      (this.times = Wh.convertArray(e, this.TimeBufferType)),
      (this.values = Wh.convertArray(i, this.ValueBufferType)),
      this.setInterpolation(n || this.DefaultInterpolation);
  }
  function Qh(t, e, i) {
    Zh.call(this, t, e, i);
  }
  function Kh(t, e, i, n) {
    Zh.call(this, t, e, i, n);
  }
  function $h(t, e, i, n) {
    Zh.call(this, t, e, i, n);
  }
  function tl(t, e, i, n) {
    Xh.call(this, t, e, i, n);
  }
  function el(t, e, i, n) {
    Zh.call(this, t, e, i, n);
  }
  function il(t, e, i, n) {
    Zh.call(this, t, e, i, n);
  }
  function nl(t, e, i, n) {
    Zh.call(this, t, e, i, n);
  }
  function rl(t, e, i) {
    (this.name = t),
      (this.tracks = i),
      (this.duration = void 0 !== e ? e : -1),
      (this.uuid = Ge.generateUUID()),
      this.duration < 0 && this.resetDuration();
  }
  function al(t) {
    if (void 0 === t.type)
      throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
    var e = (function (t) {
      switch (t.toLowerCase()) {
        case 'scalar':
        case 'double':
        case 'float':
        case 'number':
        case 'integer':
          return $h;
        case 'vector':
        case 'vector2':
        case 'vector3':
        case 'vector4':
          return nl;
        case 'color':
          return Kh;
        case 'quaternion':
          return el;
        case 'bool':
        case 'boolean':
          return Qh;
        case 'string':
          return il;
      }
      throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + t);
    })(t.type);
    if (void 0 === t.times) {
      var i = [],
        n = [];
      Wh.flattenJSON(t.keys, i, n, 'value'), (t.times = i), (t.values = n);
    }
    return void 0 !== e.parse
      ? e.parse(t)
      : new e(t.name, t.times, t.values, t.interpolation);
  }
  function ol(t) {
    (this.manager = void 0 !== t ? t : nh), (this.textures = {});
  }
  function sl(t) {
    this.manager = void 0 !== t ? t : nh;
  }
  Object.assign(Xh.prototype, {
    evaluate: function (t) {
      var e = this.parameterPositions,
        i = this._cachedIndex,
        n = e[i],
        r = e[i - 1];
      t: {
        e: {
          var a;
          i: {
            n: if (!(t < n)) {
              for (var o = i + 2; ; ) {
                if (void 0 === n) {
                  if (t < r) break n;
                  return (
                    (i = e.length), (this._cachedIndex = i), this.afterEnd_(i - 1, t, r)
                  );
                }
                if (i === o) break;
                if (((r = n), t < (n = e[++i]))) break e;
              }
              a = e.length;
              break i;
            }
            if (r <= t) break t;
            var s = e[1];
            t < s && ((i = 2), (r = s));
            for (o = i - 2; ; ) {
              if (void 0 === r)
                return (this._cachedIndex = 0), this.beforeStart_(0, t, n);
              if (i === o) break;
              if (((n = r), (r = e[--i - 1]) <= t)) break e;
            }
            (a = i), (i = 0);
          }
          for (; i < a; ) {
            var c = (i + a) >>> 1;
            t < e[c] ? (a = c) : (i = 1 + c);
          }
          if (((n = e[i]), void 0 === (r = e[i - 1])))
            return (this._cachedIndex = 0), this.beforeStart_(0, t, n);
          if (void 0 === n)
            return (i = e.length), (this._cachedIndex = i), this.afterEnd_(i - 1, r, t);
        }
        (this._cachedIndex = i), this.intervalChanged_(i, r, n);
      }
      return this.interpolate_(i, r, t, n);
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function () {
      return this.settings || this.DefaultSettings_;
    },
    copySampleValue_: function (t) {
      for (
        var e = this.resultBuffer,
          i = this.sampleValues,
          n = this.valueSize,
          r = t * n,
          a = 0;
        a !== n;
        ++a
      )
        e[a] = i[r + a];
      return e;
    },
    interpolate_: function () {
      throw new Error('call to abstract method');
    },
    intervalChanged_: function () {}
  }),
    Object.assign(Xh.prototype, {
      beforeStart_: Xh.prototype.copySampleValue_,
      afterEnd_: Xh.prototype.copySampleValue_
    }),
    (qh.prototype = Object.assign(Object.create(Xh.prototype), {
      constructor: qh,
      DefaultSettings_: { endingStart: Te, endingEnd: Te },
      intervalChanged_: function (t, e, i) {
        var n = this.parameterPositions,
          r = t - 2,
          a = t + 1,
          o = n[r],
          s = n[a];
        if (void 0 === o)
          switch (this.getSettings_().endingStart) {
            case Se:
              (r = t), (o = 2 * e - i);
              break;
            case Ae:
              o = e + n[(r = n.length - 2)] - n[r + 1];
              break;
            default:
              (r = t), (o = i);
          }
        if (void 0 === s)
          switch (this.getSettings_().endingEnd) {
            case Se:
              (a = t), (s = 2 * i - e);
              break;
            case Ae:
              s = i + n[(a = 1)] - n[0];
              break;
            default:
              (a = t - 1), (s = e);
          }
        var c = 0.5 * (i - e),
          h = this.valueSize;
        (this._weightPrev = c / (e - o)),
          (this._weightNext = c / (s - i)),
          (this._offsetPrev = r * h),
          (this._offsetNext = a * h);
      },
      interpolate_: function (t, e, i, n) {
        for (
          var r = this.resultBuffer,
            a = this.sampleValues,
            o = this.valueSize,
            s = t * o,
            c = s - o,
            h = this._offsetPrev,
            l = this._offsetNext,
            u = this._weightPrev,
            p = this._weightNext,
            d = (i - e) / (n - e),
            f = d * d,
            m = f * d,
            g = -u * m + 2 * u * f - u * d,
            v = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * d + 1,
            y = (-1 - p) * m + (1.5 + p) * f + 0.5 * d,
            x = p * m - p * f,
            b = 0;
          b !== o;
          ++b
        )
          r[b] = g * a[h + b] + v * a[c + b] + y * a[s + b] + x * a[l + b];
        return r;
      }
    })),
    (Yh.prototype = Object.assign(Object.create(Xh.prototype), {
      constructor: Yh,
      interpolate_: function (t, e, i, n) {
        for (
          var r = this.resultBuffer,
            a = this.sampleValues,
            o = this.valueSize,
            s = t * o,
            c = s - o,
            h = (i - e) / (n - e),
            l = 1 - h,
            u = 0;
          u !== o;
          ++u
        )
          r[u] = a[c + u] * l + a[s + u] * h;
        return r;
      }
    })),
    (Jh.prototype = Object.assign(Object.create(Xh.prototype), {
      constructor: Jh,
      interpolate_: function (t) {
        return this.copySampleValue_(t - 1);
      }
    })),
    Object.assign(Zh, {
      toJSON: function (t) {
        var e,
          i = t.constructor;
        if (void 0 !== i.toJSON) e = i.toJSON(t);
        else {
          e = {
            name: t.name,
            times: Wh.convertArray(t.times, Array),
            values: Wh.convertArray(t.values, Array)
          };
          var n = t.getInterpolation();
          n !== t.DefaultInterpolation && (e.interpolation = n);
        }
        return (e.type = t.ValueTypeName), e;
      }
    }),
    Object.assign(Zh.prototype, {
      constructor: Zh,
      TimeBufferType: Float32Array,
      ValueBufferType: Float32Array,
      DefaultInterpolation: Ee,
      InterpolantFactoryMethodDiscrete: function (t) {
        return new Jh(this.times, this.values, this.getValueSize(), t);
      },
      InterpolantFactoryMethodLinear: function (t) {
        return new Yh(this.times, this.values, this.getValueSize(), t);
      },
      InterpolantFactoryMethodSmooth: function (t) {
        return new qh(this.times, this.values, this.getValueSize(), t);
      },
      setInterpolation: function (t) {
        var e;
        switch (t) {
          case Me:
            e = this.InterpolantFactoryMethodDiscrete;
            break;
          case Ee:
            e = this.InterpolantFactoryMethodLinear;
            break;
          case 2302:
            e = this.InterpolantFactoryMethodSmooth;
        }
        if (void 0 !== e) return (this.createInterpolant = e), this;
        var i =
          'unsupported interpolation for ' +
          this.ValueTypeName +
          ' keyframe track named ' +
          this.name;
        if (void 0 === this.createInterpolant) {
          if (t === this.DefaultInterpolation) throw new Error(i);
          this.setInterpolation(this.DefaultInterpolation);
        }
        return console.warn('THREE.KeyframeTrack:', i), this;
      },
      getInterpolation: function () {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return Me;
          case this.InterpolantFactoryMethodLinear:
            return Ee;
          case this.InterpolantFactoryMethodSmooth:
            return 2302;
        }
      },
      getValueSize: function () {
        return this.values.length / this.times.length;
      },
      shift: function (t) {
        if (0 !== t)
          for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
        return this;
      },
      scale: function (t) {
        if (1 !== t)
          for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
        return this;
      },
      trim: function (t, e) {
        for (var i = this.times, n = i.length, r = 0, a = n - 1; r !== n && i[r] < t; )
          ++r;
        for (; -1 !== a && i[a] > e; ) --a;
        if ((++a, 0 !== r || a !== n)) {
          a <= r && (r = (a = Math.max(a, 1)) - 1);
          var o = this.getValueSize();
          (this.times = Wh.arraySlice(i, r, a)),
            (this.values = Wh.arraySlice(this.values, r * o, a * o));
        }
        return this;
      },
      validate: function () {
        var t = !0,
          e = this.getValueSize();
        e - Math.floor(e) != 0 &&
          (console.error('THREE.KeyframeTrack: Invalid value size in track.', this),
          (t = !1));
        var i = this.times,
          n = this.values,
          r = i.length;
        0 === r &&
          (console.error('THREE.KeyframeTrack: Track is empty.', this), (t = !1));
        for (var a = null, o = 0; o !== r; o++) {
          var s = i[o];
          if ('number' == typeof s && isNaN(s)) {
            console.error('THREE.KeyframeTrack: Time is not a valid number.', this, o, s),
              (t = !1);
            break;
          }
          if (null !== a && s < a) {
            console.error('THREE.KeyframeTrack: Out of order keys.', this, o, s, a),
              (t = !1);
            break;
          }
          a = s;
        }
        if (void 0 !== n && Wh.isTypedArray(n)) {
          o = 0;
          for (var c = n.length; o !== c; ++o) {
            var h = n[o];
            if (isNaN(h)) {
              console.error(
                'THREE.KeyframeTrack: Value is not a valid number.',
                this,
                o,
                h
              ),
                (t = !1);
              break;
            }
          }
        }
        return t;
      },
      optimize: function () {
        for (
          var t = this.times,
            e = this.values,
            i = this.getValueSize(),
            n = 2302 === this.getInterpolation(),
            r = 1,
            a = t.length - 1,
            o = 1;
          o < a;
          ++o
        ) {
          var s = !1,
            c = t[o];
          if (c !== t[o + 1] && (1 !== o || c !== c[0]))
            if (n) s = !0;
            else
              for (var h = o * i, l = h - i, u = h + i, p = 0; p !== i; ++p) {
                var d = e[h + p];
                if (d !== e[l + p] || d !== e[u + p]) {
                  s = !0;
                  break;
                }
              }
          if (s) {
            if (o !== r) {
              t[r] = t[o];
              var f = o * i,
                m = r * i;
              for (p = 0; p !== i; ++p) e[m + p] = e[f + p];
            }
            ++r;
          }
        }
        if (0 < a) {
          t[r] = t[a];
          for (f = a * i, m = r * i, p = 0; p !== i; ++p) e[m + p] = e[f + p];
          ++r;
        }
        return (
          r !== t.length &&
            ((this.times = Wh.arraySlice(t, 0, r)),
            (this.values = Wh.arraySlice(e, 0, r * i))),
          this
        );
      }
    }),
    (Qh.prototype = Object.assign(Object.create(Zh.prototype), {
      constructor: Qh,
      ValueTypeName: 'bool',
      ValueBufferType: Array,
      DefaultInterpolation: Me,
      InterpolantFactoryMethodLinear: void 0,
      InterpolantFactoryMethodSmooth: void 0
    })),
    (Kh.prototype = Object.assign(Object.create(Zh.prototype), {
      constructor: Kh,
      ValueTypeName: 'color'
    })),
    ($h.prototype = Object.assign(Object.create(Zh.prototype), {
      constructor: $h,
      ValueTypeName: 'number'
    })),
    (tl.prototype = Object.assign(Object.create(Xh.prototype), {
      constructor: tl,
      interpolate_: function (t, e, i, n) {
        for (
          var r = this.resultBuffer,
            a = this.sampleValues,
            o = this.valueSize,
            s = t * o,
            c = (i - e) / (n - e),
            h = s + o;
          s !== h;
          s += 4
        )
          ke.slerpFlat(r, 0, a, s - o, a, s, c);
        return r;
      }
    })),
    (el.prototype = Object.assign(Object.create(Zh.prototype), {
      constructor: el,
      ValueTypeName: 'quaternion',
      DefaultInterpolation: Ee,
      InterpolantFactoryMethodLinear: function (t) {
        return new tl(this.times, this.values, this.getValueSize(), t);
      },
      InterpolantFactoryMethodSmooth: void 0
    })),
    (il.prototype = Object.assign(Object.create(Zh.prototype), {
      constructor: il,
      ValueTypeName: 'string',
      ValueBufferType: Array,
      DefaultInterpolation: Me,
      InterpolantFactoryMethodLinear: void 0,
      InterpolantFactoryMethodSmooth: void 0
    })),
    (nl.prototype = Object.assign(Object.create(Zh.prototype), {
      constructor: nl,
      ValueTypeName: 'vector'
    })),
    Object.assign(rl, {
      parse: function (t) {
        for (
          var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, a = i.length;
          r !== a;
          ++r
        )
          e.push(al(i[r]).scale(n));
        return new rl(t.name, t.duration, e);
      },
      toJSON: function (t) {
        for (
          var e = [],
            i = t.tracks,
            n = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid },
            r = 0,
            a = i.length;
          r !== a;
          ++r
        )
          e.push(Zh.toJSON(i[r]));
        return n;
      },
      CreateFromMorphTargetSequence: function (t, e, i, n) {
        for (var r = e.length, a = [], o = 0; o < r; o++) {
          var s = [],
            c = [];
          s.push((o + r - 1) % r, o, (o + 1) % r), c.push(0, 1, 0);
          var h = Wh.getKeyframeOrder(s);
          (s = Wh.sortedArray(s, 1, h)),
            (c = Wh.sortedArray(c, 1, h)),
            n || 0 !== s[0] || (s.push(r), c.push(c[0])),
            a.push(
              new $h('.morphTargetInfluences[' + e[o].name + ']', s, c).scale(1 / i)
            );
        }
        return new rl(t, -1, a);
      },
      findByName: function (t, e) {
        var i = t;
        if (!Array.isArray(t)) {
          i = (t.geometry && t.geometry.animations) || t.animations;
        }
        for (var n = 0; n < i.length; n++) if (i[n].name === e) return i[n];
        return null;
      },
      CreateClipsFromMorphTargetSequences: function (t, e, i) {
        for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) {
          var s = t[a],
            c = s.name.match(r);
          if (c && 1 < c.length) {
            var h = n[(u = c[1])];
            h || (n[u] = h = []), h.push(s);
          }
        }
        var l = [];
        for (var u in n) l.push(rl.CreateFromMorphTargetSequence(u, n[u], e, i));
        return l;
      },
      parseAnimation: function (t, e) {
        if (!t)
          return (
            console.error('THREE.AnimationClip: No animation in JSONLoader data.'), null
          );
        for (
          var i = function (t, e, i, n, r) {
              if (0 !== i.length) {
                var a = [],
                  o = [];
                Wh.flattenJSON(i, a, o, n), 0 !== a.length && r.push(new t(e, a, o));
              }
            },
            n = [],
            r = t.name || 'default',
            a = t.length || -1,
            o = t.fps || 30,
            s = t.hierarchy || [],
            c = 0;
          c < s.length;
          c++
        ) {
          var h = s[c].keys;
          if (h && 0 !== h.length)
            if (h[0].morphTargets) {
              for (var l = {}, u = 0; u < h.length; u++)
                if (h[u].morphTargets)
                  for (var p = 0; p < h[u].morphTargets.length; p++)
                    l[h[u].morphTargets[p]] = -1;
              for (var d in l) {
                var f = [],
                  m = [];
                for (p = 0; p !== h[u].morphTargets.length; ++p) {
                  var g = h[u];
                  f.push(g.time), m.push(g.morphTarget === d ? 1 : 0);
                }
                n.push(new $h('.morphTargetInfluence[' + d + ']', f, m));
              }
              a = l.length * (o || 1);
            } else {
              var v = '.bones[' + e[c].name + ']';
              i(nl, v + '.position', h, 'pos', n),
                i(el, v + '.quaternion', h, 'rot', n),
                i(nl, v + '.scale', h, 'scl', n);
            }
        }
        return 0 === n.length ? null : new rl(r, a, n);
      }
    }),
    Object.assign(rl.prototype, {
      resetDuration: function () {
        for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
          var n = this.tracks[e];
          t = Math.max(t, n.times[n.times.length - 1]);
        }
        return (this.duration = t), this;
      },
      trim: function () {
        for (var t = 0; t < this.tracks.length; t++)
          this.tracks[t].trim(0, this.duration);
        return this;
      },
      validate: function () {
        for (var t = !0, e = 0; e < this.tracks.length; e++)
          t = t && this.tracks[e].validate();
        return t;
      },
      optimize: function () {
        for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
        return this;
      }
    }),
    Object.assign(ol.prototype, {
      load: function (t, e, i, n) {
        var r = this;
        new ah(r.manager).load(
          t,
          function (t) {
            e(r.parse(JSON.parse(t)));
          },
          i,
          n
        );
      },
      setTextures: function (t) {
        this.textures = t;
      },
      parse: function (t) {
        var e = this.textures;
        function i(t) {
          return (
            void 0 === e[t] && console.warn('THREE.MaterialLoader: Undefined texture', t),
            e[t]
          );
        }
        var n = new th[t.type]();
        if (
          (void 0 !== t.uuid && (n.uuid = t.uuid),
          void 0 !== t.name && (n.name = t.name),
          void 0 !== t.color && n.color.setHex(t.color),
          void 0 !== t.roughness && (n.roughness = t.roughness),
          void 0 !== t.metalness && (n.metalness = t.metalness),
          void 0 !== t.emissive && n.emissive.setHex(t.emissive),
          void 0 !== t.specular && n.specular.setHex(t.specular),
          void 0 !== t.shininess && (n.shininess = t.shininess),
          void 0 !== t.clearCoat && (n.clearCoat = t.clearCoat),
          void 0 !== t.clearCoatRoughness &&
            (n.clearCoatRoughness = t.clearCoatRoughness),
          void 0 !== t.vertexColors && (n.vertexColors = t.vertexColors),
          void 0 !== t.fog && (n.fog = t.fog),
          void 0 !== t.flatShading && (n.flatShading = t.flatShading),
          void 0 !== t.blending && (n.blending = t.blending),
          void 0 !== t.combine && (n.combine = t.combine),
          void 0 !== t.side && (n.side = t.side),
          void 0 !== t.opacity && (n.opacity = t.opacity),
          void 0 !== t.transparent && (n.transparent = t.transparent),
          void 0 !== t.alphaTest && (n.alphaTest = t.alphaTest),
          void 0 !== t.depthTest && (n.depthTest = t.depthTest),
          void 0 !== t.depthWrite && (n.depthWrite = t.depthWrite),
          void 0 !== t.colorWrite && (n.colorWrite = t.colorWrite),
          void 0 !== t.wireframe && (n.wireframe = t.wireframe),
          void 0 !== t.wireframeLinewidth &&
            (n.wireframeLinewidth = t.wireframeLinewidth),
          void 0 !== t.wireframeLinecap && (n.wireframeLinecap = t.wireframeLinecap),
          void 0 !== t.wireframeLinejoin && (n.wireframeLinejoin = t.wireframeLinejoin),
          void 0 !== t.rotation && (n.rotation = t.rotation),
          1 !== t.linewidth && (n.linewidth = t.linewidth),
          void 0 !== t.dashSize && (n.dashSize = t.dashSize),
          void 0 !== t.gapSize && (n.gapSize = t.gapSize),
          void 0 !== t.scale && (n.scale = t.scale),
          void 0 !== t.polygonOffset && (n.polygonOffset = t.polygonOffset),
          void 0 !== t.polygonOffsetFactor &&
            (n.polygonOffsetFactor = t.polygonOffsetFactor),
          void 0 !== t.polygonOffsetUnits &&
            (n.polygonOffsetUnits = t.polygonOffsetUnits),
          void 0 !== t.skinning && (n.skinning = t.skinning),
          void 0 !== t.morphTargets && (n.morphTargets = t.morphTargets),
          void 0 !== t.dithering && (n.dithering = t.dithering),
          void 0 !== t.visible && (n.visible = t.visible),
          void 0 !== t.userData && (n.userData = t.userData),
          void 0 !== t.uniforms)
        )
          for (var r in t.uniforms) {
            var a = t.uniforms[r];
            switch (((n.uniforms[r] = {}), a.type)) {
              case 't':
                n.uniforms[r].value = i(a.value);
                break;
              case 'c':
                n.uniforms[r].value = new Hi().setHex(a.value);
                break;
              case 'v2':
                n.uniforms[r].value = new He().fromArray(a.value);
                break;
              case 'v3':
                n.uniforms[r].value = new je().fromArray(a.value);
                break;
              case 'v4':
                n.uniforms[r].value = new Ti().fromArray(a.value);
                break;
              case 'm4':
                n.uniforms[r].value = new Ve().fromArray(a.value);
                break;
              default:
                n.uniforms[r].value = a.value;
            }
          }
        if (
          (void 0 !== t.defines && (n.defines = t.defines),
          void 0 !== t.vertexShader && (n.vertexShader = t.vertexShader),
          void 0 !== t.fragmentShader && (n.fragmentShader = t.fragmentShader),
          void 0 !== t.shading && (n.flatShading = 1 === t.shading),
          void 0 !== t.size && (n.size = t.size),
          void 0 !== t.sizeAttenuation && (n.sizeAttenuation = t.sizeAttenuation),
          void 0 !== t.map && (n.map = i(t.map)),
          void 0 !== t.alphaMap && ((n.alphaMap = i(t.alphaMap)), (n.transparent = !0)),
          void 0 !== t.bumpMap && (n.bumpMap = i(t.bumpMap)),
          void 0 !== t.bumpScale && (n.bumpScale = t.bumpScale),
          void 0 !== t.normalMap && (n.normalMap = i(t.normalMap)),
          void 0 !== t.normalMapType && (n.normalMapType = t.normalMapType),
          void 0 !== t.normalScale)
        ) {
          var o = t.normalScale;
          !1 === Array.isArray(o) && (o = [o, o]),
            (n.normalScale = new He().fromArray(o));
        }
        return (
          void 0 !== t.displacementMap && (n.displacementMap = i(t.displacementMap)),
          void 0 !== t.displacementScale && (n.displacementScale = t.displacementScale),
          void 0 !== t.displacementBias && (n.displacementBias = t.displacementBias),
          void 0 !== t.roughnessMap && (n.roughnessMap = i(t.roughnessMap)),
          void 0 !== t.metalnessMap && (n.metalnessMap = i(t.metalnessMap)),
          void 0 !== t.emissiveMap && (n.emissiveMap = i(t.emissiveMap)),
          void 0 !== t.emissiveIntensity && (n.emissiveIntensity = t.emissiveIntensity),
          void 0 !== t.specularMap && (n.specularMap = i(t.specularMap)),
          void 0 !== t.envMap && (n.envMap = i(t.envMap)),
          void 0 !== t.envMapIntensity && (n.envMapIntensity = t.envMapIntensity),
          void 0 !== t.reflectivity && (n.reflectivity = t.reflectivity),
          void 0 !== t.lightMap && (n.lightMap = i(t.lightMap)),
          void 0 !== t.lightMapIntensity && (n.lightMapIntensity = t.lightMapIntensity),
          void 0 !== t.aoMap && (n.aoMap = i(t.aoMap)),
          void 0 !== t.aoMapIntensity && (n.aoMapIntensity = t.aoMapIntensity),
          void 0 !== t.gradientMap && (n.gradientMap = i(t.gradientMap)),
          n
        );
      }
    }),
    Object.assign(sl.prototype, {
      load: function (t, e, i, n) {
        var r = this;
        new ah(r.manager).load(
          t,
          function (t) {
            e(r.parse(JSON.parse(t)));
          },
          i,
          n
        );
      },
      parse: function (t) {
        var e = new $n(),
          i = t.data.index;
        if (void 0 !== i) {
          var n = new pl[i.type](i.array);
          e.setIndex(new Pn(n, 1));
        }
        var r = t.data.attributes;
        for (var a in r) {
          var o = r[a];
          n = new pl[o.type](o.array);
          e.addAttribute(a, new Pn(n, o.itemSize, o.normalized));
        }
        var s = t.data.groups || t.data.drawcalls || t.data.offsets;
        if (void 0 !== s)
          for (var c = 0, h = s.length; c !== h; ++c) {
            var l = s[c];
            e.addGroup(l.start, l.count, l.materialIndex);
          }
        var u = t.data.boundingSphere;
        if (void 0 !== u) {
          var p = new je();
          void 0 !== u.center && p.fromArray(u.center),
            (e.boundingSphere = new Oi(p, u.radius));
        }
        return e;
      }
    });
  var cl,
    hl,
    ll,
    ul,
    pl = {
      Int8Array: Int8Array,
      Uint8Array: Uint8Array,
      Uint8ClampedArray:
        'undefined' != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
      Int16Array: Int16Array,
      Uint16Array: Uint16Array,
      Int32Array: Int32Array,
      Uint32Array: Uint32Array,
      Float32Array: Float32Array,
      Float64Array: Float64Array
    };
  function dl() {}
  (dl.Handlers = {
    handlers: [],
    add: function (t, e) {
      this.handlers.push(t, e);
    },
    get: function (t) {
      for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
        var r = e[i],
          a = e[i + 1];
        if (r.test(t)) return a;
      }
      return null;
    }
  }),
    Object.assign(dl.prototype, {
      crossOrigin: 'anonymous',
      onLoadStart: function () {},
      onLoadProgress: function () {},
      onLoadComplete: function () {},
      initMaterials: function (t, e, i) {
        for (var n = [], r = 0; r < t.length; ++r) n[r] = this.createMaterial(t[r], e, i);
        return n;
      },
      createMaterial:
        ((cl = {
          NoBlending: Z,
          NormalBlending: Q,
          AdditiveBlending: K,
          SubtractiveBlending: $,
          MultiplyBlending: tt,
          CustomBlending: et
        }),
        (hl = new Hi()),
        (ll = new lh()),
        (ul = new ol()),
        function (t, h, l) {
          var u = {};
          function e(t, e, i, n, r) {
            var a,
              o = h + t,
              s = dl.Handlers.get(o);
            (a = null !== s ? s.load(o) : (ll.setCrossOrigin(l), ll.load(o))),
              void 0 !== e &&
                (a.repeat.fromArray(e),
                1 !== e[0] && (a.wrapS = Et),
                1 !== e[1] && (a.wrapT = Et)),
              void 0 !== i && a.offset.fromArray(i),
              void 0 !== n &&
                ('repeat' === n[0] && (a.wrapS = Et),
                'mirror' === n[0] && (a.wrapS = St),
                'repeat' === n[1] && (a.wrapT = Et),
                'mirror' === n[1] && (a.wrapT = St)),
              void 0 !== r && (a.anisotropy = r);
            var c = Ge.generateUUID();
            return (u[c] = a), c;
          }
          var i = { uuid: Ge.generateUUID(), type: 'MeshLambertMaterial' };
          for (var n in t) {
            var r = t[n];
            switch (n) {
              case 'DbgColor':
              case 'DbgIndex':
              case 'opticalDensity':
              case 'illumination':
                break;
              case 'DbgName':
                i.name = r;
                break;
              case 'blending':
                i.blending = cl[r];
                break;
              case 'colorAmbient':
              case 'mapAmbient':
                console.warn(
                  'THREE.Loader.createMaterial:',
                  n,
                  'is no longer supported.'
                );
                break;
              case 'colorDiffuse':
                i.color = hl.fromArray(r).getHex();
                break;
              case 'colorSpecular':
                i.specular = hl.fromArray(r).getHex();
                break;
              case 'colorEmissive':
                i.emissive = hl.fromArray(r).getHex();
                break;
              case 'specularCoef':
                i.shininess = r;
                break;
              case 'shading':
                'basic' === r.toLowerCase() && (i.type = 'MeshBasicMaterial'),
                  'phong' === r.toLowerCase() && (i.type = 'MeshPhongMaterial'),
                  'standard' === r.toLowerCase() && (i.type = 'MeshStandardMaterial');
                break;
              case 'mapDiffuse':
                i.map = e(
                  r,
                  t.mapDiffuseRepeat,
                  t.mapDiffuseOffset,
                  t.mapDiffuseWrap,
                  t.mapDiffuseAnisotropy
                );
                break;
              case 'mapDiffuseRepeat':
              case 'mapDiffuseOffset':
              case 'mapDiffuseWrap':
              case 'mapDiffuseAnisotropy':
                break;
              case 'mapEmissive':
                i.emissiveMap = e(
                  r,
                  t.mapEmissiveRepeat,
                  t.mapEmissiveOffset,
                  t.mapEmissiveWrap,
                  t.mapEmissiveAnisotropy
                );
                break;
              case 'mapEmissiveRepeat':
              case 'mapEmissiveOffset':
              case 'mapEmissiveWrap':
              case 'mapEmissiveAnisotropy':
                break;
              case 'mapLight':
                i.lightMap = e(
                  r,
                  t.mapLightRepeat,
                  t.mapLightOffset,
                  t.mapLightWrap,
                  t.mapLightAnisotropy
                );
                break;
              case 'mapLightRepeat':
              case 'mapLightOffset':
              case 'mapLightWrap':
              case 'mapLightAnisotropy':
                break;
              case 'mapAO':
                i.aoMap = e(
                  r,
                  t.mapAORepeat,
                  t.mapAOOffset,
                  t.mapAOWrap,
                  t.mapAOAnisotropy
                );
                break;
              case 'mapAORepeat':
              case 'mapAOOffset':
              case 'mapAOWrap':
              case 'mapAOAnisotropy':
                break;
              case 'mapBump':
                i.bumpMap = e(
                  r,
                  t.mapBumpRepeat,
                  t.mapBumpOffset,
                  t.mapBumpWrap,
                  t.mapBumpAnisotropy
                );
                break;
              case 'mapBumpScale':
                i.bumpScale = r;
                break;
              case 'mapBumpRepeat':
              case 'mapBumpOffset':
              case 'mapBumpWrap':
              case 'mapBumpAnisotropy':
                break;
              case 'mapNormal':
                i.normalMap = e(
                  r,
                  t.mapNormalRepeat,
                  t.mapNormalOffset,
                  t.mapNormalWrap,
                  t.mapNormalAnisotropy
                );
                break;
              case 'mapNormalFactor':
                i.normalScale = r;
                break;
              case 'mapNormalRepeat':
              case 'mapNormalOffset':
              case 'mapNormalWrap':
              case 'mapNormalAnisotropy':
                break;
              case 'mapSpecular':
                i.specularMap = e(
                  r,
                  t.mapSpecularRepeat,
                  t.mapSpecularOffset,
                  t.mapSpecularWrap,
                  t.mapSpecularAnisotropy
                );
                break;
              case 'mapSpecularRepeat':
              case 'mapSpecularOffset':
              case 'mapSpecularWrap':
              case 'mapSpecularAnisotropy':
                break;
              case 'mapMetalness':
                i.metalnessMap = e(
                  r,
                  t.mapMetalnessRepeat,
                  t.mapMetalnessOffset,
                  t.mapMetalnessWrap,
                  t.mapMetalnessAnisotropy
                );
                break;
              case 'mapMetalnessRepeat':
              case 'mapMetalnessOffset':
              case 'mapMetalnessWrap':
              case 'mapMetalnessAnisotropy':
                break;
              case 'mapRoughness':
                i.roughnessMap = e(
                  r,
                  t.mapRoughnessRepeat,
                  t.mapRoughnessOffset,
                  t.mapRoughnessWrap,
                  t.mapRoughnessAnisotropy
                );
                break;
              case 'mapRoughnessRepeat':
              case 'mapRoughnessOffset':
              case 'mapRoughnessWrap':
              case 'mapRoughnessAnisotropy':
                break;
              case 'mapAlpha':
                i.alphaMap = e(
                  r,
                  t.mapAlphaRepeat,
                  t.mapAlphaOffset,
                  t.mapAlphaWrap,
                  t.mapAlphaAnisotropy
                );
                break;
              case 'mapAlphaRepeat':
              case 'mapAlphaOffset':
              case 'mapAlphaWrap':
              case 'mapAlphaAnisotropy':
                break;
              case 'flipSided':
                i.side = wt;
                break;
              case 'doubleSided':
                i.side = J;
                break;
              case 'transparency':
                console.warn(
                  'THREE.Loader.createMaterial: transparency has been renamed to opacity'
                ),
                  (i.opacity = r);
                break;
              case 'depthTest':
              case 'depthWrite':
              case 'colorWrite':
              case 'opacity':
              case 'reflectivity':
              case 'transparent':
              case 'visible':
              case 'wireframe':
                i[n] = r;
                break;
              case 'vertexColors':
                !0 === r && (i.vertexColors = E), 'face' === r && (i.vertexColors = 1);
                break;
              default:
                console.error('THREE.Loader.createMaterial: Unsupported', n, r);
            }
          }
          return (
            'MeshBasicMaterial' === i.type && delete i.emissive,
            'MeshPhongMaterial' !== i.type && delete i.specular,
            i.opacity < 1 && (i.transparent = !0),
            ul.setTextures(u),
            ul.parse(i)
          );
        })
    });
  var fl = {
    decodeText: function (t) {
      if ('undefined' != typeof TextDecoder) return new TextDecoder().decode(t);
      for (var e = '', i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
      return decodeURIComponent(escape(e));
    },
    extractUrlBase: function (t) {
      var e = t.lastIndexOf('/');
      return -1 === e ? './' : t.substr(0, e + 1);
    }
  };
  function ml(t) {
    'boolean' == typeof t &&
      (console.warn(
        'THREE.JSONLoader: showStatus parameter has been removed from constructor.'
      ),
      (t = void 0)),
      (this.manager = void 0 !== t ? t : nh),
      (this.withCredentials = !1);
  }
  function gl(t) {
    (this.manager = void 0 !== t ? t : nh), (this.texturePath = '');
  }
  Object.assign(ml.prototype, {
    crossOrigin: 'anonymous',
    load: function (a, o, t, e) {
      var s = this,
        c = void 0 === this.path ? fl.extractUrlBase(a) : this.path,
        i = new ah(this.manager);
      i.setPath(this.path),
        i.setWithCredentials(this.withCredentials),
        i.load(
          a,
          function (t) {
            var e = JSON.parse(t),
              i = e.metadata;
            if (void 0 !== i) {
              var n = i.type;
              if (void 0 !== n && 'object' === n.toLowerCase())
                return void console.error(
                  'THREE.JSONLoader: ' +
                    a +
                    ' should be loaded with THREE.ObjectLoader instead.'
                );
            }
            var r = s.parse(e, c);
            o(r.geometry, r.materials);
          },
          t,
          e
        );
    },
    setPath: function (t) {
      return (this.path = t), this;
    },
    setResourcePath: function (t) {
      return (this.resourcePath = t), this;
    },
    setCrossOrigin: function (t) {
      return (this.crossOrigin = t), this;
    },
    parse: function (t, e) {
      void 0 !== t.data && (t = t.data),
        void 0 !== t.scale ? (t.scale = 1 / t.scale) : (t.scale = 1);
      var i = new Rn();
      return (
        (function (t, e) {
          function i(t, e) {
            return t & (1 << e);
          }
          var n,
            r,
            a,
            o,
            s,
            c,
            h,
            l,
            u,
            p,
            d,
            f,
            m,
            g,
            v,
            y,
            x,
            b,
            _,
            w,
            M,
            E,
            T,
            S,
            A,
            L = t.faces,
            R = t.vertices,
            P = t.normals,
            C = t.colors,
            O = t.scale,
            I = 0;
          if (void 0 !== t.uvs) {
            for (n = 0; n < t.uvs.length; n++) t.uvs[n].length && I++;
            for (n = 0; n < I; n++) e.faceVertexUvs[n] = [];
          }
          for (o = 0, s = R.length; o < s; )
            ((b = new je()).x = R[o++] * O),
              (b.y = R[o++] * O),
              (b.z = R[o++] * O),
              e.vertices.push(b);
          for (o = 0, s = L.length; o < s; )
            if (
              ((d = i((p = L[o++]), 0)),
              (f = i(p, 1)),
              (m = i(p, 3)),
              (g = i(p, 4)),
              (v = i(p, 5)),
              (y = i(p, 6)),
              (x = i(p, 7)),
              d)
            ) {
              if (
                (((w = new Qi()).a = L[o]),
                (w.b = L[o + 1]),
                (w.c = L[o + 3]),
                ((M = new Qi()).a = L[o + 1]),
                (M.b = L[o + 2]),
                (M.c = L[o + 3]),
                (o += 4),
                f && ((u = L[o++]), (w.materialIndex = u), (M.materialIndex = u)),
                (a = e.faces.length),
                m)
              )
                for (n = 0; n < I; n++)
                  for (
                    S = t.uvs[n],
                      e.faceVertexUvs[n][a] = [],
                      e.faceVertexUvs[n][a + 1] = [],
                      r = 0;
                    r < 4;
                    r++
                  )
                    (A = new He(S[2 * (l = L[o++])], S[2 * l + 1])),
                      2 !== r && e.faceVertexUvs[n][a].push(A),
                      0 !== r && e.faceVertexUvs[n][a + 1].push(A);
              if (
                (g &&
                  ((h = 3 * L[o++]),
                  w.normal.set(P[h++], P[h++], P[h]),
                  M.normal.copy(w.normal)),
                v)
              )
                for (n = 0; n < 4; n++)
                  (h = 3 * L[o++]),
                    (T = new je(P[h++], P[h++], P[h])),
                    2 !== n && w.vertexNormals.push(T),
                    0 !== n && M.vertexNormals.push(T);
              if ((y && ((E = C[(c = L[o++])]), w.color.setHex(E), M.color.setHex(E)), x))
                for (n = 0; n < 4; n++)
                  (E = C[(c = L[o++])]),
                    2 !== n && w.vertexColors.push(new Hi(E)),
                    0 !== n && M.vertexColors.push(new Hi(E));
              e.faces.push(w), e.faces.push(M);
            } else {
              if (
                (((_ = new Qi()).a = L[o++]),
                (_.b = L[o++]),
                (_.c = L[o++]),
                f && ((u = L[o++]), (_.materialIndex = u)),
                (a = e.faces.length),
                m)
              )
                for (n = 0; n < I; n++)
                  for (S = t.uvs[n], e.faceVertexUvs[n][a] = [], r = 0; r < 3; r++)
                    (A = new He(S[2 * (l = L[o++])], S[2 * l + 1])),
                      e.faceVertexUvs[n][a].push(A);
              if ((g && ((h = 3 * L[o++]), _.normal.set(P[h++], P[h++], P[h])), v))
                for (n = 0; n < 3; n++)
                  (h = 3 * L[o++]),
                    (T = new je(P[h++], P[h++], P[h])),
                    _.vertexNormals.push(T);
              if ((y && ((c = L[o++]), _.color.setHex(C[c])), x))
                for (n = 0; n < 3; n++) (c = L[o++]), _.vertexColors.push(new Hi(C[c]));
              e.faces.push(_);
            }
        })(t, i),
        (function (t, e) {
          var i = void 0 !== t.influencesPerVertex ? t.influencesPerVertex : 2;
          if (t.skinWeights)
            for (var n = 0, r = t.skinWeights.length; n < r; n += i) {
              var a = t.skinWeights[n],
                o = 1 < i ? t.skinWeights[n + 1] : 0,
                s = 2 < i ? t.skinWeights[n + 2] : 0,
                c = 3 < i ? t.skinWeights[n + 3] : 0;
              e.skinWeights.push(new Ti(a, o, s, c));
            }
          if (t.skinIndices)
            for (n = 0, r = t.skinIndices.length; n < r; n += i) {
              var h = t.skinIndices[n],
                l = 1 < i ? t.skinIndices[n + 1] : 0,
                u = 2 < i ? t.skinIndices[n + 2] : 0,
                p = 3 < i ? t.skinIndices[n + 3] : 0;
              e.skinIndices.push(new Ti(h, l, u, p));
            }
          (e.bones = t.bones),
            e.bones &&
              0 < e.bones.length &&
              (e.skinWeights.length !== e.skinIndices.length ||
                e.skinIndices.length !== e.vertices.length) &&
              console.warn(
                'When skinning, number of vertices (' +
                  e.vertices.length +
                  '), skinIndices (' +
                  e.skinIndices.length +
                  '), and skinWeights (' +
                  e.skinWeights.length +
                  ') should match.'
              );
        })(t, i),
        (function (t, e) {
          var i = t.scale;
          if (void 0 !== t.morphTargets)
            for (var n = 0, r = t.morphTargets.length; n < r; n++) {
              (e.morphTargets[n] = {}),
                (e.morphTargets[n].name = t.morphTargets[n].name),
                (e.morphTargets[n].vertices = []);
              for (
                var a = e.morphTargets[n].vertices,
                  o = t.morphTargets[n].vertices,
                  s = 0,
                  c = o.length;
                s < c;
                s += 3
              ) {
                var h = new je();
                (h.x = o[s] * i), (h.y = o[s + 1] * i), (h.z = o[s + 2] * i), a.push(h);
              }
            }
          if (void 0 !== t.morphColors && 0 < t.morphColors.length) {
            console.warn(
              'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'
            );
            var l = e.faces,
              u = t.morphColors[0].colors;
            for (n = 0, r = l.length; n < r; n++) l[n].color.fromArray(u, 3 * n);
          }
        })(t, i),
        (function (t, e) {
          var i = [],
            n = [];
          void 0 !== t.animation && n.push(t.animation),
            void 0 !== t.animations &&
              (t.animations.length ? (n = n.concat(t.animations)) : n.push(t.animations));
          for (var r = 0; r < n.length; r++) {
            var a = rl.parseAnimation(n[r], e.bones);
            a && i.push(a);
          }
          if (e.morphTargets) {
            var o = rl.CreateClipsFromMorphTargetSequences(e.morphTargets, 10);
            i = i.concat(o);
          }
          0 < i.length && (e.animations = i);
        })(t, i),
        i.computeFaceNormals(),
        i.computeBoundingSphere(),
        void 0 === t.materials || 0 === t.materials.length
          ? { geometry: i }
          : {
              geometry: i,
              materials: dl.prototype.initMaterials(
                t.materials,
                this.resourcePath || e,
                this.crossOrigin
              )
            }
      );
    }
  }),
    Object.assign(gl.prototype, {
      crossOrigin: 'anonymous',
      load: function (n, r, t, a) {
        '' === this.texturePath &&
          (this.texturePath = n.substring(0, n.lastIndexOf('/') + 1));
        var o = this;
        new ah(o.manager).load(
          n,
          function (t) {
            var e = null;
            try {
              e = JSON.parse(t);
            } catch (t) {
              return (
                void 0 !== a && a(t),
                void console.error(
                  "THREE:ObjectLoader: Can't parse " + n + '.',
                  t.message
                )
              );
            }
            var i = e.metadata;
            void 0 !== i && void 0 !== i.type && 'geometry' !== i.type.toLowerCase()
              ? o.parse(e, r)
              : console.error(
                  "THREE.ObjectLoader: Can't load " +
                    n +
                    '. Use THREE.JSONLoader instead.'
                );
          },
          t,
          a
        );
      },
      setTexturePath: function (t) {
        return (this.texturePath = t), this;
      },
      setCrossOrigin: function (t) {
        return (this.crossOrigin = t), this;
      },
      parse: function (t, e) {
        var i = this.parseShape(t.shapes),
          n = this.parseGeometries(t.geometries, i),
          r = this.parseImages(t.images, function () {
            void 0 !== e && e(s);
          }),
          a = this.parseTextures(t.textures, r),
          o = this.parseMaterials(t.materials, a),
          s = this.parseObject(t.object, n, o);
        return (
          t.animations && (s.animations = this.parseAnimations(t.animations)),
          (void 0 !== t.images && 0 !== t.images.length) || (void 0 !== e && e(s)),
          s
        );
      },
      parseShape: function (t) {
        var e = {};
        if (void 0 !== t)
          for (var i = 0, n = t.length; i < n; i++) {
            var r = new Ih().fromJSON(t[i]);
            e[r.uuid] = r;
          }
        return e;
      },
      parseGeometries: function (t, e) {
        var i = {};
        if (void 0 !== t)
          for (var n = new ml(), r = new sl(), a = 0, o = t.length; a < o; a++) {
            var s,
              c = t[a];
            switch (c.type) {
              case 'PlaneGeometry':
              case 'PlaneBufferGeometry':
                s = new kc[c.type](c.width, c.height, c.widthSegments, c.heightSegments);
                break;
              case 'BoxGeometry':
              case 'BoxBufferGeometry':
              case 'CubeGeometry':
                s = new kc[c.type](
                  c.width,
                  c.height,
                  c.depth,
                  c.widthSegments,
                  c.heightSegments,
                  c.depthSegments
                );
                break;
              case 'CircleGeometry':
              case 'CircleBufferGeometry':
                s = new kc[c.type](c.radius, c.segments, c.thetaStart, c.thetaLength);
                break;
              case 'CylinderGeometry':
              case 'CylinderBufferGeometry':
                s = new kc[c.type](
                  c.radiusTop,
                  c.radiusBottom,
                  c.height,
                  c.radialSegments,
                  c.heightSegments,
                  c.openEnded,
                  c.thetaStart,
                  c.thetaLength
                );
                break;
              case 'ConeGeometry':
              case 'ConeBufferGeometry':
                s = new kc[c.type](
                  c.radius,
                  c.height,
                  c.radialSegments,
                  c.heightSegments,
                  c.openEnded,
                  c.thetaStart,
                  c.thetaLength
                );
                break;
              case 'SphereGeometry':
              case 'SphereBufferGeometry':
                s = new kc[c.type](
                  c.radius,
                  c.widthSegments,
                  c.heightSegments,
                  c.phiStart,
                  c.phiLength,
                  c.thetaStart,
                  c.thetaLength
                );
                break;
              case 'DodecahedronGeometry':
              case 'DodecahedronBufferGeometry':
              case 'IcosahedronGeometry':
              case 'IcosahedronBufferGeometry':
              case 'OctahedronGeometry':
              case 'OctahedronBufferGeometry':
              case 'TetrahedronGeometry':
              case 'TetrahedronBufferGeometry':
                s = new kc[c.type](c.radius, c.detail);
                break;
              case 'RingGeometry':
              case 'RingBufferGeometry':
                s = new kc[c.type](
                  c.innerRadius,
                  c.outerRadius,
                  c.thetaSegments,
                  c.phiSegments,
                  c.thetaStart,
                  c.thetaLength
                );
                break;
              case 'TorusGeometry':
              case 'TorusBufferGeometry':
                s = new kc[c.type](
                  c.radius,
                  c.tube,
                  c.radialSegments,
                  c.tubularSegments,
                  c.arc
                );
                break;
              case 'TorusKnotGeometry':
              case 'TorusKnotBufferGeometry':
                s = new kc[c.type](
                  c.radius,
                  c.tube,
                  c.tubularSegments,
                  c.radialSegments,
                  c.p,
                  c.q
                );
                break;
              case 'LatheGeometry':
              case 'LatheBufferGeometry':
                s = new kc[c.type](c.points, c.segments, c.phiStart, c.phiLength);
                break;
              case 'PolyhedronGeometry':
              case 'PolyhedronBufferGeometry':
                s = new kc[c.type](c.vertices, c.indices, c.radius, c.details);
                break;
              case 'ShapeGeometry':
              case 'ShapeBufferGeometry':
                for (var h = [], l = 0, u = c.shapes.length; l < u; l++) {
                  var p = e[c.shapes[l]];
                  h.push(p);
                }
                s = new kc[c.type](h, c.curveSegments);
                break;
              case 'ExtrudeGeometry':
              case 'ExtrudeBufferGeometry':
                for (h = [], l = 0, u = c.shapes.length; l < u; l++) {
                  p = e[c.shapes[l]];
                  h.push(p);
                }
                var d = c.options.extrudePath;
                void 0 !== d && (c.options.extrudePath = new Ph[d.type]().fromJSON(d)),
                  (s = new kc[c.type](h, c.options));
                break;
              case 'BufferGeometry':
                s = r.parse(c);
                break;
              case 'Geometry':
                s = n.parse(c, this.texturePath).geometry;
                break;
              default:
                console.warn(
                  'THREE.ObjectLoader: Unsupported geometry type "' + c.type + '"'
                );
                continue;
            }
            (s.uuid = c.uuid),
              void 0 !== c.name && (s.name = c.name),
              !0 === s.isBufferGeometry &&
                void 0 !== c.userData &&
                (s.userData = c.userData),
              (i[c.uuid] = s);
          }
        return i;
      },
      parseMaterials: function (t, e) {
        var i = {};
        if (void 0 !== t) {
          var n = new ol();
          n.setTextures(e);
          for (var r = 0, a = t.length; r < a; r++) {
            var o = t[r];
            if ('MultiMaterial' === o.type) {
              for (var s = [], c = 0; c < o.materials.length; c++)
                s.push(n.parse(o.materials[c]));
              i[o.uuid] = s;
            } else i[o.uuid] = n.parse(o);
          }
        }
        return i;
      },
      parseAnimations: function (t) {
        for (var e = [], i = 0; i < t.length; i++) {
          var n = t[i],
            r = rl.parse(n);
          void 0 !== n.uuid && (r.uuid = n.uuid), e.push(r);
        }
        return e;
      },
      parseImages: function (t, e) {
        var i = this,
          n = {};
        function r(t) {
          return (
            i.manager.itemStart(t),
            a.load(
              t,
              function () {
                i.manager.itemEnd(t);
              },
              void 0,
              function () {
                i.manager.itemEnd(t), i.manager.itemError(t);
              }
            )
          );
        }
        if (void 0 !== t && 0 < t.length) {
          var a = new ch(new ih(e));
          a.setCrossOrigin(this.crossOrigin);
          for (var o = 0, s = t.length; o < s; o++) {
            var c = t[o],
              h = c.url;
            if (Array.isArray(h)) {
              n[c.uuid] = [];
              for (var l = 0, u = h.length; l < u; l++) {
                var p = h[l],
                  d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(p) ? p : i.texturePath + p;
                n[c.uuid].push(r(d));
              }
            } else {
              d = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c.url) ? c.url : i.texturePath + c.url;
              n[c.uuid] = r(d);
            }
          }
        }
        return n;
      },
      parseTextures: function (t, e) {
        function i(t, e) {
          return 'number' == typeof t
            ? t
            : (console.warn(
                'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',
                t
              ),
              e[t]);
        }
        var n = {};
        if (void 0 !== t)
          for (var r = 0, a = t.length; r < a; r++) {
            var o,
              s = t[r];
            void 0 === s.image &&
              console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid),
              void 0 === e[s.image] &&
                console.warn('THREE.ObjectLoader: Undefined image', s.image),
              ((o = new (Array.isArray(e[s.image]) ? ha : Ei)(
                e[s.image]
              )).needsUpdate = !0),
              (o.uuid = s.uuid),
              void 0 !== s.name && (o.name = s.name),
              void 0 !== s.mapping && (o.mapping = i(s.mapping, yl)),
              void 0 !== s.offset && o.offset.fromArray(s.offset),
              void 0 !== s.repeat && o.repeat.fromArray(s.repeat),
              void 0 !== s.center && o.center.fromArray(s.center),
              void 0 !== s.rotation && (o.rotation = s.rotation),
              void 0 !== s.wrap &&
                ((o.wrapS = i(s.wrap[0], xl)), (o.wrapT = i(s.wrap[1], xl))),
              void 0 !== s.format && (o.format = s.format),
              void 0 !== s.minFilter && (o.minFilter = i(s.minFilter, bl)),
              void 0 !== s.magFilter && (o.magFilter = i(s.magFilter, bl)),
              void 0 !== s.anisotropy && (o.anisotropy = s.anisotropy),
              void 0 !== s.flipY && (o.flipY = s.flipY),
              (n[s.uuid] = o);
          }
        return n;
      },
      parseObject: function (t, e, a) {
        var i;
        function n(t) {
          return (
            void 0 === e[t] && console.warn('THREE.ObjectLoader: Undefined geometry', t),
            e[t]
          );
        }
        function r(t) {
          if (void 0 !== t) {
            if (Array.isArray(t)) {
              for (var e = [], i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                void 0 === a[r] &&
                  console.warn('THREE.ObjectLoader: Undefined material', r),
                  e.push(a[r]);
              }
              return e;
            }
            return (
              void 0 === a[t] &&
                console.warn('THREE.ObjectLoader: Undefined material', t),
              a[t]
            );
          }
        }
        switch (t.type) {
          case 'Scene':
            (i = new ps()),
              void 0 !== t.background &&
                Number.isInteger(t.background) &&
                (i.background = new Hi(t.background)),
              void 0 !== t.fog &&
                ('Fog' === t.fog.type
                  ? (i.fog = new us(t.fog.color, t.fog.near, t.fog.far))
                  : 'FogExp2' === t.fog.type &&
                    (i.fog = new ls(t.fog.color, t.fog.density)));
            break;
          case 'PerspectiveCamera':
            (i = new as(t.fov, t.aspect, t.near, t.far)),
              void 0 !== t.focus && (i.focus = t.focus),
              void 0 !== t.zoom && (i.zoom = t.zoom),
              void 0 !== t.filmGauge && (i.filmGauge = t.filmGauge),
              void 0 !== t.filmOffset && (i.filmOffset = t.filmOffset),
              void 0 !== t.view && (i.view = Object.assign({}, t.view));
            break;
          case 'OrthographicCamera':
            (i = new Gh(t.left, t.right, t.top, t.bottom, t.near, t.far)),
              void 0 !== t.zoom && (i.zoom = t.zoom),
              void 0 !== t.view && (i.view = Object.assign({}, t.view));
            break;
          case 'AmbientLight':
            i = new kh(t.color, t.intensity);
            break;
          case 'DirectionalLight':
            i = new Vh(t.color, t.intensity);
            break;
          case 'PointLight':
            i = new zh(t.color, t.intensity, t.distance, t.decay);
            break;
          case 'RectAreaLight':
            i = new jh(t.color, t.intensity, t.width, t.height);
            break;
          case 'SpotLight':
            i = new Fh(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
            break;
          case 'HemisphereLight':
            i = new Dh(t.color, t.groundColor, t.intensity);
            break;
          case 'SkinnedMesh':
            console.warn(
              'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.'
            );
          case 'Mesh':
            var o = n(t.geometry),
              s = r(t.material);
            i = new (o.bones && 0 < o.bones.length ? _s : Jr)(o, s);
            break;
          case 'LOD':
            i = new ys();
            break;
          case 'Line':
            i = new Ms(n(t.geometry), r(t.material), t.mode);
            break;
          case 'LineLoop':
            i = new Ts(n(t.geometry), r(t.material));
            break;
          case 'LineSegments':
            i = new Es(n(t.geometry), r(t.material));
            break;
          case 'PointCloud':
          case 'Points':
            i = new As(n(t.geometry), r(t.material));
            break;
          case 'Sprite':
            i = new gs(r(t.material));
            break;
          case 'Group':
            i = new ns();
            break;
          default:
            i = new bn();
        }
        if (
          ((i.uuid = t.uuid),
          void 0 !== t.name && (i.name = t.name),
          void 0 !== t.matrix
            ? (i.matrix.fromArray(t.matrix),
              void 0 !== t.matrixAutoUpdate && (i.matrixAutoUpdate = t.matrixAutoUpdate),
              i.matrixAutoUpdate && i.matrix.decompose(i.position, i.quaternion, i.scale))
            : (void 0 !== t.position && i.position.fromArray(t.position),
              void 0 !== t.rotation && i.rotation.fromArray(t.rotation),
              void 0 !== t.quaternion && i.quaternion.fromArray(t.quaternion),
              void 0 !== t.scale && i.scale.fromArray(t.scale)),
          void 0 !== t.castShadow && (i.castShadow = t.castShadow),
          void 0 !== t.receiveShadow && (i.receiveShadow = t.receiveShadow),
          t.shadow &&
            (void 0 !== t.shadow.bias && (i.shadow.bias = t.shadow.bias),
            void 0 !== t.shadow.radius && (i.shadow.radius = t.shadow.radius),
            void 0 !== t.shadow.mapSize && i.shadow.mapSize.fromArray(t.shadow.mapSize),
            void 0 !== t.shadow.camera &&
              (i.shadow.camera = this.parseObject(t.shadow.camera))),
          void 0 !== t.visible && (i.visible = t.visible),
          void 0 !== t.frustumCulled && (i.frustumCulled = t.frustumCulled),
          void 0 !== t.renderOrder && (i.renderOrder = t.renderOrder),
          void 0 !== t.userData && (i.userData = t.userData),
          void 0 !== t.layers && (i.layers.mask = t.layers),
          void 0 !== t.children)
        )
          for (var c = t.children, h = 0; h < c.length; h++)
            i.add(this.parseObject(c[h], e, a));
        if ('LOD' === t.type)
          for (var l = t.levels, u = 0; u < l.length; u++) {
            var p = l[u],
              d = i.getObjectByProperty('uuid', p.object);
            void 0 !== d && i.addLevel(d, p.distance);
          }
        return i;
      }
    });
  var vl,
    yl = {
      UVMapping: 300,
      CubeReflectionMapping: mt,
      CubeRefractionMapping: gt,
      EquirectangularReflectionMapping: vt,
      EquirectangularRefractionMapping: yt,
      SphericalReflectionMapping: xt,
      CubeUVReflectionMapping: bt,
      CubeUVRefractionMapping: _t
    },
    xl = { RepeatWrapping: Et, ClampToEdgeWrapping: Tt, MirroredRepeatWrapping: St },
    bl = {
      NearestFilter: At,
      NearestMipMapNearestFilter: Lt,
      NearestMipMapLinearFilter: Rt,
      LinearFilter: Pt,
      LinearMipMapNearestFilter: Ct,
      LinearMipMapLinearFilter: Ot
    };
  function _l(t) {
    'undefined' == typeof createImageBitmap &&
      console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.'),
      'undefined' == typeof fetch &&
        console.warn('THREE.ImageBitmapLoader: fetch() not supported.'),
      (this.manager = void 0 !== t ? t : nh),
      (this.options = void 0);
  }
  function wl() {
    (this.type = 'ShapePath'),
      (this.color = new Hi()),
      (this.subPaths = []),
      (this.currentPath = null);
  }
  function Ml(t) {
    (this.type = 'Font'), (this.data = t);
  }
  function El(t, e, i, n, r) {
    var a = r.glyphs[t] || r.glyphs['?'];
    if (a) {
      var o,
        s,
        c,
        h,
        l,
        u,
        p,
        d,
        f = new wl();
      if (a.o)
        for (
          var m = a._cachedOutline || (a._cachedOutline = a.o.split(' ')),
            g = 0,
            v = m.length;
          g < v;

        ) {
          switch (m[g++]) {
            case 'm':
              (o = m[g++] * e + i), (s = m[g++] * e + n), f.moveTo(o, s);
              break;
            case 'l':
              (o = m[g++] * e + i), (s = m[g++] * e + n), f.lineTo(o, s);
              break;
            case 'q':
              (c = m[g++] * e + i),
                (h = m[g++] * e + n),
                (l = m[g++] * e + i),
                (u = m[g++] * e + n),
                f.quadraticCurveTo(l, u, c, h);
              break;
            case 'b':
              (c = m[g++] * e + i),
                (h = m[g++] * e + n),
                (l = m[g++] * e + i),
                (u = m[g++] * e + n),
                (p = m[g++] * e + i),
                (d = m[g++] * e + n),
                f.bezierCurveTo(l, u, p, d, c, h);
          }
        }
      return { offsetX: a.ha * e, path: f };
    }
  }
  function Tl(t) {
    this.manager = void 0 !== t ? t : nh;
  }
  (_l.prototype = {
    constructor: _l,
    setOptions: function (t) {
      return (this.options = t), this;
    },
    load: function (e, i, t, n) {
      void 0 === e && (e = ''),
        void 0 !== this.path && (e = this.path + e),
        (e = this.manager.resolveURL(e));
      var r = this,
        a = eh.get(e);
      if (void 0 !== a)
        return (
          r.manager.itemStart(e),
          setTimeout(function () {
            i && i(a), r.manager.itemEnd(e);
          }, 0),
          a
        );
      fetch(e)
        .then(function (t) {
          return t.blob();
        })
        .then(function (t) {
          return createImageBitmap(t, r.options);
        })
        .then(function (t) {
          eh.add(e, t), i && i(t), r.manager.itemEnd(e);
        })
        .catch(function (t) {
          n && n(t), r.manager.itemEnd(e), r.manager.itemError(e);
        });
    },
    setCrossOrigin: function () {
      return this;
    },
    setPath: function (t) {
      return (this.path = t), this;
    }
  }),
    Object.assign(wl.prototype, {
      moveTo: function (t, e) {
        (this.currentPath = new Oh()),
          this.subPaths.push(this.currentPath),
          this.currentPath.moveTo(t, e);
      },
      lineTo: function (t, e) {
        this.currentPath.lineTo(t, e);
      },
      quadraticCurveTo: function (t, e, i, n) {
        this.currentPath.quadraticCurveTo(t, e, i, n);
      },
      bezierCurveTo: function (t, e, i, n, r, a) {
        this.currentPath.bezierCurveTo(t, e, i, n, r, a);
      },
      splineThru: function (t) {
        this.currentPath.splineThru(t);
      },
      toShapes: function (t, e) {
        function i(t) {
          for (var e = [], i = 0, n = t.length; i < n; i++) {
            var r = t[i],
              a = new Ih();
            (a.curves = r.curves), e.push(a);
          }
          return e;
        }
        function n(t, e) {
          for (var i = e.length, n = !1, r = i - 1, a = 0; a < i; r = a++) {
            var o = e[r],
              s = e[a],
              c = s.x - o.x,
              h = s.y - o.y;
            if (Math.abs(h) > Number.EPSILON) {
              if (
                (h < 0 && ((o = e[a]), (c = -c), (s = e[r]), (h = -h)),
                t.y < o.y || t.y > s.y)
              )
                continue;
              if (t.y === o.y) {
                if (t.x === o.x) return 1;
              } else {
                var l = h * (t.x - o.x) - c * (t.y - o.y);
                if (0 == l) return 1;
                if (l < 0) continue;
                n = !n;
              }
            } else {
              if (t.y !== o.y) continue;
              if ((s.x <= t.x && t.x <= o.x) || (o.x <= t.x && t.x <= s.x)) return 1;
            }
          }
          return n;
        }
        var r = yc.isClockWise,
          a = this.subPaths;
        if (0 === a.length) return [];
        if (!0 === e) return i(a);
        var o,
          s,
          c,
          h = [];
        if (1 === a.length)
          return (s = a[0]), ((c = new Ih()).curves = s.curves), h.push(c), h;
        var l = !r(a[0].getPoints());
        l = t ? !l : l;
        var u,
          p,
          d = [],
          f = [],
          m = [],
          g = 0;
        (f[g] = void 0), (m[g] = []);
        for (var v = 0, y = a.length; v < y; v++)
          (o = r((u = (s = a[v]).getPoints()))),
            (o = t ? !o : o)
              ? (!l && f[g] && g++,
                (f[g] = { s: new Ih(), p: u }),
                (f[g].s.curves = s.curves),
                l && g++,
                (m[g] = []))
              : m[g].push({ h: s, p: u[0] });
        if (!f[0]) return i(a);
        if (1 < f.length) {
          for (var x = !1, b = [], _ = 0, w = f.length; _ < w; _++) d[_] = [];
          for (_ = 0, w = f.length; _ < w; _++)
            for (var M = m[_], E = 0; E < M.length; E++) {
              for (var T = M[E], S = !0, A = 0; A < f.length; A++)
                n(T.p, f[A].p) &&
                  (_ !== A && b.push({ froms: _, tos: A, hole: E }),
                  S ? ((S = !1), d[A].push(T)) : (x = !0));
              S && d[_].push(T);
            }
          0 < b.length && (x || (m = d));
        }
        v = 0;
        for (var L = f.length; v < L; v++) {
          (c = f[v].s), h.push(c);
          for (var R = 0, P = (p = m[v]).length; R < P; R++) c.holes.push(p[R].h);
        }
        return h;
      }
    }),
    Object.assign(Ml.prototype, {
      isFont: !0,
      generateShapes: function (t, e) {
        void 0 === e && (e = 100);
        for (
          var i = [],
            n = (function (t, e, i) {
              for (
                var n = Array.from ? Array.from(t) : String(t).split(''),
                  r = e / i.resolution,
                  a =
                    (i.boundingBox.yMax - i.boundingBox.yMin + i.underlineThickness) * r,
                  o = [],
                  s = 0,
                  c = 0,
                  h = 0;
                h < n.length;
                h++
              ) {
                var l = n[h];
                if ('\n' === l) (s = 0), (c -= a);
                else {
                  var u = El(l, r, s, c, i);
                  (s += u.offsetX), o.push(u.path);
                }
              }
              return o;
            })(t, e, this.data),
            r = 0,
            a = n.length;
          r < a;
          r++
        )
          Array.prototype.push.apply(i, n[r].toShapes());
        return i;
      }
    }),
    Object.assign(Tl.prototype, {
      load: function (t, n, e, i) {
        var r = this,
          a = new ah(this.manager);
        a.setPath(this.path),
          a.load(
            t,
            function (e) {
              var i;
              try {
                i = JSON.parse(e);
              } catch (t) {
                console.warn(
                  'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.'
                ),
                  (i = JSON.parse(e.substring(65, e.length - 2)));
              }
              var t = r.parse(i);
              n && n(t);
            },
            e,
            i
          );
      },
      parse: function (t) {
        return new Ml(t);
      },
      setPath: function (t) {
        return (this.path = t), this;
      }
    });
  var Sl,
    Al,
    Ll,
    Rl,
    Pl,
    Cl,
    Ol,
    Il,
    Nl,
    Dl,
    Ul,
    Bl,
    Fl,
    zl,
    Gl,
    Hl,
    Vl,
    kl,
    jl = {
      getContext: function () {
        return (
          void 0 === vl &&
            (vl = new (window.AudioContext || window.webkitAudioContext)()),
          vl
        );
      },
      setContext: function (t) {
        vl = t;
      }
    };
  function Wl(t) {
    this.manager = void 0 !== t ? t : nh;
  }
  function Xl() {
    (this.type = 'StereoCamera'),
      (this.aspect = 1),
      (this.eyeSep = 0.064),
      (this.cameraL = new as()),
      this.cameraL.layers.enable(1),
      (this.cameraL.matrixAutoUpdate = !1),
      (this.cameraR = new as()),
      this.cameraR.layers.enable(2),
      (this.cameraR.matrixAutoUpdate = !1);
  }
  function ql(t, e, i) {
    bn.call(this), (this.type = 'CubeCamera');
    var r = new as(90, 1, t, e);
    r.up.set(0, -1, 0), r.lookAt(new je(1, 0, 0)), this.add(r);
    var a = new as(90, 1, t, e);
    a.up.set(0, -1, 0), a.lookAt(new je(-1, 0, 0)), this.add(a);
    var o = new as(90, 1, t, e);
    o.up.set(0, 0, 1), o.lookAt(new je(0, 1, 0)), this.add(o);
    var s = new as(90, 1, t, e);
    s.up.set(0, 0, -1), s.lookAt(new je(0, -1, 0)), this.add(s);
    var c = new as(90, 1, t, e);
    c.up.set(0, -1, 0), c.lookAt(new je(0, 0, 1)), this.add(c);
    var h = new as(90, 1, t, e);
    h.up.set(0, -1, 0), h.lookAt(new je(0, 0, -1)), this.add(h);
    var n = { format: Xt, magFilter: Pt, minFilter: Pt };
    (this.renderTarget = new Ai(i, i, n)),
      (this.renderTarget.texture.name = 'CubeCamera'),
      (this.update = function (t, e) {
        null === this.parent && this.updateMatrixWorld();
        var i = this.renderTarget,
          n = i.texture.generateMipmaps;
        (i.texture.generateMipmaps = !1),
          (i.activeCubeFace = 0),
          t.render(e, r, i),
          (i.activeCubeFace = 1),
          t.render(e, a, i),
          (i.activeCubeFace = 2),
          t.render(e, o, i),
          (i.activeCubeFace = 3),
          t.render(e, s, i),
          (i.activeCubeFace = 4),
          t.render(e, c, i),
          (i.texture.generateMipmaps = n),
          (i.activeCubeFace = 5),
          t.render(e, h, i),
          t.setRenderTarget(null);
      }),
      (this.clear = function (t, e, i, n) {
        for (var r = this.renderTarget, a = 0; a < 6; a++)
          (r.activeCubeFace = a), t.setRenderTarget(r), t.clear(e, i, n);
        t.setRenderTarget(null);
      });
  }
  function Yl() {
    bn.call(this),
      (this.type = 'AudioListener'),
      (this.context = jl.getContext()),
      (this.gain = this.context.createGain()),
      this.gain.connect(this.context.destination),
      (this.filter = null);
  }
  function Jl(t) {
    bn.call(this),
      (this.type = 'Audio'),
      (this.context = t.context),
      (this.gain = this.context.createGain()),
      this.gain.connect(t.getInput()),
      (this.autoplay = !1),
      (this.buffer = null),
      (this.loop = !1),
      (this.startTime = 0),
      (this.offset = 0),
      (this.playbackRate = 1),
      (this.isPlaying = !1),
      (this.hasPlaybackControl = !0),
      (this.sourceType = 'empty'),
      (this.filters = []);
  }
  function Zl(t) {
    Jl.call(this, t),
      (this.panner = this.context.createPanner()),
      this.panner.connect(this.gain);
  }
  function Ql(t, e) {
    (this.analyser = t.context.createAnalyser()),
      (this.analyser.fftSize = void 0 !== e ? e : 2048),
      (this.data = new Uint8Array(this.analyser.frequencyBinCount)),
      t.getOutput().connect(this.analyser);
  }
  function Kl(t, e, i) {
    (this.binding = t), (this.valueSize = i);
    var n,
      r = Float64Array;
    switch (e) {
      case 'quaternion':
        n = this._slerp;
        break;
      case 'string':
      case 'bool':
        (r = Array), (n = this._select);
        break;
      default:
        n = this._lerp;
    }
    (this.buffer = new r(4 * i)),
      (this._mixBufferRegion = n),
      (this.cumulativeWeight = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  Object.assign(Wl.prototype, {
    load: function (t, i, e, n) {
      var r = new ah(this.manager);
      r.setResponseType('arraybuffer'),
        r.load(
          t,
          function (t) {
            var e = t.slice(0);
            jl.getContext().decodeAudioData(e, function (t) {
              i(t);
            });
          },
          e,
          n
        );
    }
  }),
    Object.assign(Xl.prototype, {
      update:
        ((Nl = new Ve()),
        (Dl = new Ve()),
        function (t) {
          if (
            Sl !== this ||
            Al !== t.focus ||
            Ll !== t.fov ||
            Rl !== t.aspect * this.aspect ||
            Pl !== t.near ||
            Cl !== t.far ||
            Ol !== t.zoom ||
            Il !== this.eyeSep
          ) {
            (Sl = this),
              (Al = t.focus),
              (Ll = t.fov),
              (Rl = t.aspect * this.aspect),
              (Pl = t.near),
              (Cl = t.far),
              (Ol = t.zoom);
            var e,
              i,
              n = t.projectionMatrix.clone(),
              r = ((Il = this.eyeSep / 2) * Pl) / Al,
              a = (Pl * Math.tan(Ge.DEG2RAD * Ll * 0.5)) / Ol;
            (Dl.elements[12] = -Il),
              (Nl.elements[12] = Il),
              (e = -a * Rl + r),
              (i = a * Rl + r),
              (n.elements[0] = (2 * Pl) / (i - e)),
              (n.elements[8] = (i + e) / (i - e)),
              this.cameraL.projectionMatrix.copy(n),
              (e = -a * Rl - r),
              (i = a * Rl - r),
              (n.elements[0] = (2 * Pl) / (i - e)),
              (n.elements[8] = (i + e) / (i - e)),
              this.cameraR.projectionMatrix.copy(n);
          }
          this.cameraL.matrixWorld.copy(t.matrixWorld).multiply(Dl),
            this.cameraR.matrixWorld.copy(t.matrixWorld).multiply(Nl);
        })
    }),
    ((ql.prototype = Object.create(bn.prototype)).constructor = ql),
    (Yl.prototype = Object.assign(Object.create(bn.prototype), {
      constructor: Yl,
      getInput: function () {
        return this.gain;
      },
      removeFilter: function () {
        return (
          null !== this.filter &&
            (this.gain.disconnect(this.filter),
            this.filter.disconnect(this.context.destination),
            this.gain.connect(this.context.destination),
            (this.filter = null)),
          this
        );
      },
      getFilter: function () {
        return this.filter;
      },
      setFilter: function (t) {
        return (
          null !== this.filter
            ? (this.gain.disconnect(this.filter),
              this.filter.disconnect(this.context.destination))
            : this.gain.disconnect(this.context.destination),
          (this.filter = t),
          this.gain.connect(this.filter),
          this.filter.connect(this.context.destination),
          this
        );
      },
      getMasterVolume: function () {
        return this.gain.gain.value;
      },
      setMasterVolume: function (t) {
        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
      },
      updateMatrixWorld:
        ((Ul = new je()),
        (Bl = new ke()),
        (Fl = new je()),
        (zl = new je()),
        function (t) {
          bn.prototype.updateMatrixWorld.call(this, t);
          var e = this.context.listener,
            i = this.up;
          this.matrixWorld.decompose(Ul, Bl, Fl),
            zl.set(0, 0, -1).applyQuaternion(Bl),
            e.positionX
              ? (e.positionX.setValueAtTime(Ul.x, this.context.currentTime),
                e.positionY.setValueAtTime(Ul.y, this.context.currentTime),
                e.positionZ.setValueAtTime(Ul.z, this.context.currentTime),
                e.forwardX.setValueAtTime(zl.x, this.context.currentTime),
                e.forwardY.setValueAtTime(zl.y, this.context.currentTime),
                e.forwardZ.setValueAtTime(zl.z, this.context.currentTime),
                e.upX.setValueAtTime(i.x, this.context.currentTime),
                e.upY.setValueAtTime(i.y, this.context.currentTime),
                e.upZ.setValueAtTime(i.z, this.context.currentTime))
              : (e.setPosition(Ul.x, Ul.y, Ul.z),
                e.setOrientation(zl.x, zl.y, zl.z, i.x, i.y, i.z));
        })
    })),
    (Jl.prototype = Object.assign(Object.create(bn.prototype), {
      constructor: Jl,
      getOutput: function () {
        return this.gain;
      },
      setNodeSource: function (t) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = 'audioNode'),
          (this.source = t),
          this.connect(),
          this
        );
      },
      setMediaElementSource: function (t) {
        return (
          (this.hasPlaybackControl = !1),
          (this.sourceType = 'mediaNode'),
          (this.source = this.context.createMediaElementSource(t)),
          this.connect(),
          this
        );
      },
      setBuffer: function (t) {
        return (
          (this.buffer = t),
          (this.sourceType = 'buffer'),
          this.autoplay && this.play(),
          this
        );
      },
      play: function () {
        if (!0 !== this.isPlaying) {
          if (!1 !== this.hasPlaybackControl) {
            var t = this.context.createBufferSource();
            return (
              (t.buffer = this.buffer),
              (t.loop = this.loop),
              (t.onended = this.onEnded.bind(this)),
              t.playbackRate.setValueAtTime(this.playbackRate, this.startTime),
              (this.startTime = this.context.currentTime),
              t.start(this.startTime, this.offset),
              (this.isPlaying = !0),
              (this.source = t),
              this.connect()
            );
          }
          console.warn('THREE.Audio: this Audio has no playback control.');
        } else console.warn('THREE.Audio: Audio is already playing.');
      },
      pause: function () {
        if (!1 !== this.hasPlaybackControl)
          return (
            !0 === this.isPlaying &&
              (this.source.stop(),
              (this.source.onended = null),
              (this.offset +=
                (this.context.currentTime - this.startTime) * this.playbackRate),
              (this.isPlaying = !1)),
            this
          );
        console.warn('THREE.Audio: this Audio has no playback control.');
      },
      stop: function () {
        if (!1 !== this.hasPlaybackControl)
          return (
            this.source.stop(),
            (this.source.onended = null),
            (this.offset = 0),
            (this.isPlaying = !1),
            this
          );
        console.warn('THREE.Audio: this Audio has no playback control.');
      },
      connect: function () {
        if (0 < this.filters.length) {
          this.source.connect(this.filters[0]);
          for (var t = 1, e = this.filters.length; t < e; t++)
            this.filters[t - 1].connect(this.filters[t]);
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else this.source.connect(this.getOutput());
        return this;
      },
      disconnect: function () {
        if (0 < this.filters.length) {
          this.source.disconnect(this.filters[0]);
          for (var t = 1, e = this.filters.length; t < e; t++)
            this.filters[t - 1].disconnect(this.filters[t]);
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else this.source.disconnect(this.getOutput());
        return this;
      },
      getFilters: function () {
        return this.filters;
      },
      setFilters: function (t) {
        return (
          (t = t || []),
          !0 === this.isPlaying
            ? (this.disconnect(), (this.filters = t), this.connect())
            : (this.filters = t),
          this
        );
      },
      getFilter: function () {
        return this.getFilters()[0];
      },
      setFilter: function (t) {
        return this.setFilters(t ? [t] : []);
      },
      setPlaybackRate: function (t) {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this.playbackRate = t),
            !0 === this.isPlaying &&
              this.source.playbackRate.setValueAtTime(
                this.playbackRate,
                this.context.currentTime
              ),
            this
          );
        console.warn('THREE.Audio: this Audio has no playback control.');
      },
      getPlaybackRate: function () {
        return this.playbackRate;
      },
      onEnded: function () {
        this.isPlaying = !1;
      },
      getLoop: function () {
        return !1 === this.hasPlaybackControl
          ? (console.warn('THREE.Audio: this Audio has no playback control.'), !1)
          : this.loop;
      },
      setLoop: function (t) {
        if (!1 !== this.hasPlaybackControl)
          return (
            (this.loop = t), !0 === this.isPlaying && (this.source.loop = this.loop), this
          );
        console.warn('THREE.Audio: this Audio has no playback control.');
      },
      getVolume: function () {
        return this.gain.gain.value;
      },
      setVolume: function (t) {
        return this.gain.gain.setTargetAtTime(t, this.context.currentTime, 0.01), this;
      }
    })),
    (Zl.prototype = Object.assign(Object.create(Jl.prototype), {
      constructor: Zl,
      getOutput: function () {
        return this.panner;
      },
      getRefDistance: function () {
        return this.panner.refDistance;
      },
      setRefDistance: function (t) {
        return (this.panner.refDistance = t), this;
      },
      getRolloffFactor: function () {
        return this.panner.rolloffFactor;
      },
      setRolloffFactor: function (t) {
        return (this.panner.rolloffFactor = t), this;
      },
      getDistanceModel: function () {
        return this.panner.distanceModel;
      },
      setDistanceModel: function (t) {
        return (this.panner.distanceModel = t), this;
      },
      getMaxDistance: function () {
        return this.panner.maxDistance;
      },
      setMaxDistance: function (t) {
        return (this.panner.maxDistance = t), this;
      },
      setDirectionalCone: function (t, e, i) {
        return (
          (this.panner.coneInnerAngle = t),
          (this.panner.coneOuterAngle = e),
          (this.panner.coneOuterGain = i),
          this
        );
      },
      updateMatrixWorld:
        ((Gl = new je()),
        (Hl = new ke()),
        (Vl = new je()),
        (kl = new je()),
        function (t) {
          bn.prototype.updateMatrixWorld.call(this, t);
          var e = this.panner;
          this.matrixWorld.decompose(Gl, Hl, Vl),
            kl.set(0, 0, 1).applyQuaternion(Hl),
            e.setPosition(Gl.x, Gl.y, Gl.z),
            e.setOrientation(kl.x, kl.y, kl.z);
        })
    })),
    Object.assign(Ql.prototype, {
      getFrequencyData: function () {
        return this.analyser.getByteFrequencyData(this.data), this.data;
      },
      getAverageFrequency: function () {
        for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
        return t / e.length;
      }
    }),
    Object.assign(Kl.prototype, {
      accumulate: function (t, e) {
        var i = this.buffer,
          n = this.valueSize,
          r = t * n + n,
          a = this.cumulativeWeight;
        if (0 === a) {
          for (var o = 0; o !== n; ++o) i[r + o] = i[o];
          a = e;
        } else {
          var s = e / (a += e);
          this._mixBufferRegion(i, r, 0, s, n);
        }
        this.cumulativeWeight = a;
      },
      apply: function (t) {
        var e = this.valueSize,
          i = this.buffer,
          n = t * e + e,
          r = this.cumulativeWeight,
          a = this.binding;
        if (((this.cumulativeWeight = 0), r < 1)) {
          var o = 3 * e;
          this._mixBufferRegion(i, n, o, 1 - r, e);
        }
        for (var s = e, c = e + e; s !== c; ++s)
          if (i[s] !== i[s + e]) {
            a.setValue(i, n);
            break;
          }
      },
      saveOriginalState: function () {
        var t = this.binding,
          e = this.buffer,
          i = this.valueSize,
          n = 3 * i;
        t.getValue(e, n);
        for (var r = i, a = n; r !== a; ++r) e[r] = e[n + (r % i)];
        this.cumulativeWeight = 0;
      },
      restoreOriginalState: function () {
        var t = 3 * this.valueSize;
        this.binding.setValue(this.buffer, t);
      },
      _select: function (t, e, i, n, r) {
        if (0.5 <= n) for (var a = 0; a !== r; ++a) t[e + a] = t[i + a];
      },
      _slerp: function (t, e, i, n) {
        ke.slerpFlat(t, e, t, e, t, i, n);
      },
      _lerp: function (t, e, i, n, r) {
        for (var a = 1 - n, o = 0; o !== r; ++o) {
          var s = e + o;
          t[s] = t[s] * a + t[i + o] * n;
        }
      }
    });
  var $l,
    tu,
    eu,
    iu,
    nu,
    ru,
    au,
    ou,
    su,
    cu,
    hu,
    lu,
    uu,
    pu,
    du,
    fu,
    mu,
    gu,
    vu,
    yu,
    xu,
    bu,
    _u,
    wu,
    Mu,
    Eu,
    Tu,
    Su,
    Au,
    Lu,
    Ru,
    Pu,
    Cu,
    Ou,
    Iu,
    Nu,
    Du,
    Uu,
    Bu,
    Fu = '\\[\\]\\.:\\/';
  function zu(t, e, i) {
    var n = i || Gu.parseTrackName(e);
    (this._targetGroup = t), (this._bindings = t.subscribe_(e, n));
  }
  function Gu(t, e, i) {
    (this.path = e),
      (this.parsedPath = i || Gu.parseTrackName(e)),
      (this.node = Gu.findNode(t, this.parsedPath.nodeName) || t),
      (this.rootNode = t);
  }
  function Hu() {
    (this.uuid = Ge.generateUUID()),
      (this._objects = Array.prototype.slice.call(arguments)),
      (this.nCachedObjects_ = 0);
    var t = {};
    this._indicesByUUID = t;
    for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
    (this._paths = []),
      (this._parsedPaths = []),
      (this._bindings = []),
      (this._bindingsIndicesByPath = {});
    var n = this;
    this.stats = {
      objects: {
        get total() {
          return n._objects.length;
        },
        get inUse() {
          return this.total - n.nCachedObjects_;
        }
      },
      get bindingsPerObject() {
        return n._bindings.length;
      }
    };
  }
  function Vu(t, e, i) {
    (this._mixer = t), (this._clip = e), (this._localRoot = i || null);
    for (
      var n = e.tracks,
        r = n.length,
        a = new Array(r),
        o = { endingStart: Te, endingEnd: Te },
        s = 0;
      s !== r;
      ++s
    ) {
      var c = n[s].createInterpolant(null);
      (a[s] = c).settings = o;
    }
    (this._interpolantSettings = o),
      (this._interpolants = a),
      (this._propertyBindings = new Array(r)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = 2201),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  function ku(t) {
    (this._root = t),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  function ju(t) {
    'string' == typeof t &&
      (console.warn('THREE.Uniform: Type parameter is no longer needed.'),
      (t = arguments[1])),
      (this.value = t);
  }
  function Wu() {
    $n.call(this),
      (this.type = 'InstancedBufferGeometry'),
      (this.maxInstancedCount = void 0);
  }
  function Xu(t, e, i) {
    ds.call(this, t, e), (this.meshPerAttribute = i || 1);
  }
  function qu(t, e, i, n) {
    'number' == typeof i &&
      ((n = i),
      (i = !1),
      console.error(
        'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.'
      )),
      Pn.call(this, t, e, i),
      (this.meshPerAttribute = n || 1);
  }
  function Yu(t, e, i, n) {
    (this.ray = new Xr(t, e)),
      (this.near = i || 0),
      (this.far = n || 1 / 0),
      (this.params = {
        Mesh: {},
        Line: {},
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {}
      }),
      Object.defineProperties(this.params, {
        PointCloud: {
          get: function () {
            return (
              console.warn(
                'THREE.Raycaster: params.PointCloud has been renamed to params.Points.'
              ),
              this.Points
            );
          }
        }
      });
  }
  function Ju(t, e) {
    return t.distance - e.distance;
  }
  function Zu(t, e, i, n) {
    if (!1 !== t.visible && (t.raycast(e, i), !0 === n))
      for (var r = t.children, a = 0, o = r.length; a < o; a++) Zu(r[a], e, i, !0);
  }
  function Qu(t) {
    (this.autoStart = void 0 === t || t),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  function Ku(t, e, i) {
    return (
      (this.radius = void 0 !== t ? t : 1),
      (this.phi = void 0 !== e ? e : 0),
      (this.theta = void 0 !== i ? i : 0),
      this
    );
  }
  function $u(t, e, i) {
    return (
      (this.radius = void 0 !== t ? t : 1),
      (this.theta = void 0 !== e ? e : 0),
      (this.y = void 0 !== i ? i : 0),
      this
    );
  }
  function tp(t, e) {
    (this.min = void 0 !== t ? t : new He(1 / 0, 1 / 0)),
      (this.max = void 0 !== e ? e : new He(-1 / 0, -1 / 0));
  }
  function ep(t, e) {
    (this.start = void 0 !== t ? t : new je()), (this.end = void 0 !== e ? e : new je());
  }
  function ip(t) {
    bn.call(this), (this.material = t), (this.render = function () {});
  }
  function np(t, e, i, n) {
    (this.object = t), (this.size = void 0 !== e ? e : 1);
    var r = void 0 !== i ? i : 16711680,
      a = void 0 !== n ? n : 1,
      o = 0,
      s = this.object.geometry;
    s && s.isGeometry
      ? (o = 3 * s.faces.length)
      : s && s.isBufferGeometry && (o = s.attributes.normal.count);
    var c = new $n(),
      h = new Fn(2 * o * 3, 3);
    c.addAttribute('position', h),
      Es.call(this, c, new ws({ color: r, linewidth: a })),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  function rp(t, e) {
    bn.call(this),
      (this.light = t),
      this.light.updateMatrixWorld(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = e);
    for (
      var i = new $n(),
        n = [
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          1,
          0,
          1,
          0,
          0,
          0,
          -1,
          0,
          1,
          0,
          0,
          0,
          0,
          1,
          1,
          0,
          0,
          0,
          0,
          -1,
          1
        ],
        r = 0,
        a = 1;
      r < 32;
      r++, a++
    ) {
      var o = (r / 32) * Math.PI * 2,
        s = (a / 32) * Math.PI * 2;
      n.push(Math.cos(o), Math.sin(o), 1, Math.cos(s), Math.sin(s), 1);
    }
    i.addAttribute('position', new Fn(n, 3));
    var c = new ws({ fog: !1 });
    (this.cone = new Es(i, c)), this.add(this.cone), this.update();
  }
  function ap(t) {
    for (
      var e = (function t(e) {
          var i = [];
          e && e.isBone && i.push(e);
          for (var n = 0; n < e.children.length; n++) i.push.apply(i, t(e.children[n]));
          return i;
        })(t),
        i = new $n(),
        n = [],
        r = [],
        a = new Hi(0, 0, 1),
        o = new Hi(0, 1, 0),
        s = 0;
      s < e.length;
      s++
    ) {
      var c = e[s];
      c.parent &&
        c.parent.isBone &&
        (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b));
    }
    i.addAttribute('position', new Fn(n, 3)), i.addAttribute('color', new Fn(r, 3));
    var h = new ws({ vertexColors: E, depthTest: !1, depthWrite: !1, transparent: !0 });
    Es.call(this, i, h),
      (this.root = t),
      (this.bones = e),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1);
  }
  function op(t, e, i) {
    (this.light = t), this.light.updateMatrixWorld(), (this.color = i);
    var n = new Lc(e, 4, 2),
      r = new Yr({ wireframe: !0, fog: !1 });
    Jr.call(this, n, r),
      (this.matrix = this.light.matrixWorld),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  function sp(t, e) {
    bn.call(this),
      (this.light = t),
      this.light.updateMatrixWorld(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = e);
    var i = new ws({ fog: !1 }),
      n = new $n();
    n.addAttribute('position', new Pn(new Float32Array(15), 3)),
      (this.line = new Ms(n, i)),
      this.add(this.line),
      this.update();
  }
  function cp(t, e, i) {
    bn.call(this),
      (this.light = t),
      this.light.updateMatrixWorld(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i);
    var n = new Gs(e);
    n.rotateY(0.5 * Math.PI),
      (this.material = new Yr({ wireframe: !0, fog: !1 })),
      void 0 === this.color && (this.material.vertexColors = E);
    var r = n.getAttribute('position'),
      a = new Float32Array(3 * r.count);
    n.addAttribute('color', new Pn(a, 3)),
      this.add(new Jr(n, this.material)),
      this.update();
  }
  function hp(t, e, i, n) {
    (t = t || 10),
      (e = e || 10),
      (i = new Hi(void 0 !== i ? i : 4473924)),
      (n = new Hi(void 0 !== n ? n : 8947848));
    for (
      var r = e / 2, a = t / e, o = t / 2, s = [], c = [], h = 0, l = 0, u = -o;
      h <= e;
      h++, u += a
    ) {
      s.push(-o, 0, u, o, 0, u), s.push(u, 0, -o, u, 0, o);
      var p = h === r ? i : n;
      p.toArray(c, l),
        (l += 3),
        p.toArray(c, l),
        (l += 3),
        p.toArray(c, l),
        (l += 3),
        p.toArray(c, l),
        (l += 3);
    }
    var d = new $n();
    d.addAttribute('position', new Fn(s, 3)), d.addAttribute('color', new Fn(c, 3));
    var f = new ws({ vertexColors: E });
    Es.call(this, d, f);
  }
  function lp(t, e, i, n, r, a) {
    (t = t || 10),
      (e = e || 16),
      (i = i || 8),
      (n = n || 64),
      (r = new Hi(void 0 !== r ? r : 4473924)),
      (a = new Hi(void 0 !== a ? a : 8947848));
    var o,
      s,
      c,
      h,
      l,
      u,
      p,
      d = [],
      f = [];
    for (h = 0; h <= e; h++)
      (c = (h / e) * (2 * Math.PI)),
        (o = Math.sin(c) * t),
        (s = Math.cos(c) * t),
        d.push(0, 0, 0),
        d.push(o, 0, s),
        (p = 1 & h ? r : a),
        f.push(p.r, p.g, p.b),
        f.push(p.r, p.g, p.b);
    for (h = 0; h <= i; h++)
      for (p = 1 & h ? r : a, u = t - (t / i) * h, l = 0; l < n; l++)
        (c = (l / n) * (2 * Math.PI)),
          (o = Math.sin(c) * u),
          (s = Math.cos(c) * u),
          d.push(o, 0, s),
          f.push(p.r, p.g, p.b),
          (c = ((l + 1) / n) * (2 * Math.PI)),
          (o = Math.sin(c) * u),
          (s = Math.cos(c) * u),
          d.push(o, 0, s),
          f.push(p.r, p.g, p.b);
    var m = new $n();
    m.addAttribute('position', new Fn(d, 3)), m.addAttribute('color', new Fn(f, 3));
    var g = new ws({ vertexColors: E });
    Es.call(this, m, g);
  }
  function up(t, e, i, n) {
    (this.object = t), (this.size = void 0 !== e ? e : 1);
    var r = void 0 !== i ? i : 16776960,
      a = void 0 !== n ? n : 1,
      o = 0,
      s = this.object.geometry;
    s && s.isGeometry
      ? (o = s.faces.length)
      : console.warn(
          'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.'
        );
    var c = new $n(),
      h = new Fn(2 * o * 3, 3);
    c.addAttribute('position', h),
      Es.call(this, c, new ws({ color: r, linewidth: a })),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  function pp(t, e, i) {
    bn.call(this),
      (this.light = t),
      this.light.updateMatrixWorld(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.color = i),
      void 0 === e && (e = 1);
    var n = new $n();
    n.addAttribute(
      'position',
      new Fn([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)
    );
    var r = new ws({ fog: !1 });
    (this.lightPlane = new Ms(n, r)),
      this.add(this.lightPlane),
      (n = new $n()).addAttribute('position', new Fn([0, 0, 0, 0, 0, 1], 3)),
      (this.targetLine = new Ms(n, r)),
      this.add(this.targetLine),
      this.update();
  }
  function dp(t) {
    var e = new $n(),
      i = new ws({ color: 16777215, vertexColors: 1 }),
      n = [],
      r = [],
      a = {},
      o = new Hi(16755200),
      s = new Hi(16711680),
      c = new Hi(43775),
      h = new Hi(16777215),
      l = new Hi(3355443);
    function u(t, e, i) {
      p(t, i), p(e, i);
    }
    function p(t, e) {
      n.push(0, 0, 0),
        r.push(e.r, e.g, e.b),
        void 0 === a[t] && (a[t] = []),
        a[t].push(n.length / 3 - 1);
    }
    u('n1', 'n2', o),
      u('n2', 'n4', o),
      u('n4', 'n3', o),
      u('n3', 'n1', o),
      u('f1', 'f2', o),
      u('f2', 'f4', o),
      u('f4', 'f3', o),
      u('f3', 'f1', o),
      u('n1', 'f1', o),
      u('n2', 'f2', o),
      u('n3', 'f3', o),
      u('n4', 'f4', o),
      u('p', 'n1', s),
      u('p', 'n2', s),
      u('p', 'n3', s),
      u('p', 'n4', s),
      u('u1', 'u2', c),
      u('u2', 'u3', c),
      u('u3', 'u1', c),
      u('c', 't', h),
      u('p', 'c', l),
      u('cn1', 'cn2', l),
      u('cn3', 'cn4', l),
      u('cf1', 'cf2', l),
      u('cf3', 'cf4', l),
      e.addAttribute('position', new Fn(n, 3)),
      e.addAttribute('color', new Fn(r, 3)),
      Es.call(this, e, i),
      (this.camera = t),
      this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(),
      (this.matrix = t.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = a),
      this.update();
  }
  function fp(t, e, i, n) {
    Cu.set(e, i, n).unproject(Ou);
    var r = Pu[t];
    if (void 0 !== r)
      for (var a = Ru.getAttribute('position'), o = 0, s = r.length; o < s; o++)
        a.setXYZ(r[o], Cu.x, Cu.y, Cu.z);
  }
  function mp(t, e) {
    (this.object = t), void 0 === e && (e = 16776960);
    var i = new Uint16Array([
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        0,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        4,
        0,
        4,
        1,
        5,
        2,
        6,
        3,
        7
      ]),
      n = new Float32Array(24),
      r = new $n();
    r.setIndex(new Pn(i, 1)),
      r.addAttribute('position', new Pn(n, 3)),
      Es.call(this, r, new ws({ color: e })),
      (this.matrixAutoUpdate = !1),
      this.update();
  }
  function gp(t, e) {
    (this.type = 'Box3Helper'), (this.box = t);
    var i = void 0 !== e ? e : 16776960,
      n = new Uint16Array([
        0,
        1,
        1,
        2,
        2,
        3,
        3,
        0,
        4,
        5,
        5,
        6,
        6,
        7,
        7,
        4,
        0,
        4,
        1,
        5,
        2,
        6,
        3,
        7
      ]),
      r = new $n();
    r.setIndex(new Pn(n, 1)),
      r.addAttribute(
        'position',
        new Fn(
          [
            1,
            1,
            1,
            -1,
            1,
            1,
            -1,
            -1,
            1,
            1,
            -1,
            1,
            1,
            1,
            -1,
            -1,
            1,
            -1,
            -1,
            -1,
            -1,
            1,
            -1,
            -1
          ],
          3
        )
      ),
      Es.call(this, r, new ws({ color: i })),
      this.geometry.computeBoundingSphere();
  }
  function vp(t, e, i) {
    (this.type = 'PlaneHelper'), (this.plane = t), (this.size = void 0 === e ? 1 : e);
    var n = void 0 !== i ? i : 16776960,
      r = new $n();
    r.addAttribute(
      'position',
      new Fn(
        [
          1,
          -1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          1,
          1,
          -1,
          1,
          1,
          -1,
          -1,
          1,
          1,
          -1,
          1,
          1,
          1,
          1,
          0,
          0,
          1,
          0,
          0,
          0
        ],
        3
      )
    ),
      r.computeBoundingSphere(),
      Ms.call(this, r, new ws({ color: n }));
    var a = new $n();
    a.addAttribute(
      'position',
      new Fn([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)
    ),
      a.computeBoundingSphere(),
      this.add(
        new Jr(a, new Yr({ color: n, opacity: 0.2, transparent: !0, depthWrite: !1 }))
      );
  }
  function yp(t, e, i, n, r, a) {
    bn.call(this),
      void 0 === n && (n = 16776960),
      void 0 === i && (i = 1),
      void 0 === r && (r = 0.2 * i),
      void 0 === a && (a = 0.2 * r),
      void 0 === Nu &&
        ((Nu = new $n()).addAttribute('position', new Fn([0, 0, 0, 0, 1, 0], 3)),
        (Du = new Fc(0, 0.5, 1, 5, 1)).translate(0, -0.5, 0)),
      this.position.copy(e),
      (this.line = new Ms(Nu, new ws({ color: n }))),
      (this.line.matrixAutoUpdate = !1),
      this.add(this.line),
      (this.cone = new Jr(Du, new Yr({ color: n }))),
      (this.cone.matrixAutoUpdate = !1),
      this.add(this.cone),
      this.setDirection(t),
      this.setLength(i, r, a);
  }
  function xp(t) {
    var e = [0, 0, 0, (t = t || 1), 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t],
      i = new $n();
    i.addAttribute('position', new Fn(e, 3)),
      i.addAttribute(
        'color',
        new Fn([1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1], 3)
      );
    var n = new ws({ vertexColors: E });
    Es.call(this, i, n);
  }
  Object.assign(zu.prototype, {
    getValue: function (t, e) {
      this.bind();
      var i = this._targetGroup.nCachedObjects_,
        n = this._bindings[i];
      void 0 !== n && n.getValue(t, e);
    },
    setValue: function (t, e) {
      for (
        var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length;
        n !== r;
        ++n
      )
        i[n].setValue(t, e);
    },
    bind: function () {
      for (
        var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length;
        e !== i;
        ++e
      )
        t[e].bind();
    },
    unbind: function () {
      for (
        var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length;
        e !== i;
        ++e
      )
        t[e].unbind();
    }
  }),
    Object.assign(Gu, {
      Composite: zu,
      create: function (t, e, i) {
        return t && t.isAnimationObjectGroup
          ? new Gu.Composite(t, e, i)
          : new Gu(t, e, i);
      },
      sanitizeNodeName:
        ((su = new RegExp('[' + Fu + ']', 'g')),
        function (t) {
          return t.replace(/\s/g, '_').replace(su, '');
        }),
      parseTrackName:
        (($l = '[^' + Fu + ']'),
        (tu = '[^' + Fu.replace('\\.', '') + ']'),
        (eu = /((?:WC+[\/:])*)/.source.replace('WC', $l)),
        (iu = /(WCOD+)?/.source.replace('WCOD', tu)),
        (nu = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', $l)),
        (ru = /\.(WC+)(?:\[(.+)\])?/.source.replace('WC', $l)),
        (au = new RegExp('^' + eu + iu + nu + ru + '$')),
        (ou = ['material', 'materials', 'bones']),
        function (t) {
          var e = au.exec(t);
          if (!e) throw new Error('PropertyBinding: Cannot parse trackName: ' + t);
          var i = {
              nodeName: e[2],
              objectName: e[3],
              objectIndex: e[4],
              propertyName: e[5],
              propertyIndex: e[6]
            },
            n = i.nodeName && i.nodeName.lastIndexOf('.');
          if (void 0 !== n && -1 !== n) {
            var r = i.nodeName.substring(n + 1);
            -1 !== ou.indexOf(r) &&
              ((i.nodeName = i.nodeName.substring(0, n)), (i.objectName = r));
          }
          if (null === i.propertyName || 0 === i.propertyName.length)
            throw new Error(
              'PropertyBinding: can not parse propertyName from trackName: ' + t
            );
          return i;
        }),
      findNode: function (t, r) {
        if (
          !r ||
          '' === r ||
          'root' === r ||
          '.' === r ||
          -1 === r ||
          r === t.name ||
          r === t.uuid
        )
          return t;
        if (t.skeleton) {
          var e = t.skeleton.getBoneByName(r);
          if (void 0 !== e) return e;
        }
        if (t.children) {
          var a = function (t) {
              for (var e = 0; e < t.length; e++) {
                var i = t[e];
                if (i.name === r || i.uuid === r) return i;
                var n = a(i.children);
                if (n) return n;
              }
              return null;
            },
            i = a(t.children);
          if (i) return i;
        }
        return null;
      }
    }),
    Object.assign(Gu.prototype, {
      _getValue_unavailable: function () {},
      _setValue_unavailable: function () {},
      BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 },
      Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 },
      GetterByBindingType: [
        function (t, e) {
          t[e] = this.node[this.propertyName];
        },
        function (t, e) {
          for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
            t[e++] = i[n];
        },
        function (t, e) {
          t[e] = this.resolvedProperty[this.propertyIndex];
        },
        function (t, e) {
          this.resolvedProperty.toArray(t, e);
        }
      ],
      SetterByBindingTypeAndVersioning: [
        [
          function (t, e) {
            this.targetObject[this.propertyName] = t[e];
          },
          function (t, e) {
            (this.targetObject[this.propertyName] = t[e]),
              (this.targetObject.needsUpdate = !0);
          },
          function (t, e) {
            (this.targetObject[this.propertyName] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
        ],
        [
          function (t, e) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
              i[n] = t[e++];
          },
          function (t, e) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
              i[n] = t[e++];
            this.targetObject.needsUpdate = !0;
          },
          function (t, e) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)
              i[n] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0;
          }
        ],
        [
          function (t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e];
          },
          function (t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.needsUpdate = !0);
          },
          function (t, e) {
            (this.resolvedProperty[this.propertyIndex] = t[e]),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
        ],
        [
          function (t, e) {
            this.resolvedProperty.fromArray(t, e);
          },
          function (t, e) {
            this.resolvedProperty.fromArray(t, e), (this.targetObject.needsUpdate = !0);
          },
          function (t, e) {
            this.resolvedProperty.fromArray(t, e),
              (this.targetObject.matrixWorldNeedsUpdate = !0);
          }
        ]
      ],
      getValue: function (t, e) {
        this.bind(), this.getValue(t, e);
      },
      setValue: function (t, e) {
        this.bind(), this.setValue(t, e);
      },
      bind: function () {
        var t = this.node,
          e = this.parsedPath,
          i = e.objectName,
          n = e.propertyName,
          r = e.propertyIndex;
        if (
          (t ||
            ((t = Gu.findNode(this.rootNode, e.nodeName) || this.rootNode),
            (this.node = t)),
          (this.getValue = this._getValue_unavailable),
          (this.setValue = this._setValue_unavailable),
          t)
        ) {
          if (i) {
            var a = e.objectIndex;
            switch (i) {
              case 'materials':
                if (!t.material)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
                    this
                  );
                if (!t.material.materials)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
                    this
                  );
                t = t.material.materials;
                break;
              case 'bones':
                if (!t.skeleton)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
                    this
                  );
                t = t.skeleton.bones;
                for (var o = 0; o < t.length; o++)
                  if (t[o].name === a) {
                    a = o;
                    break;
                  }
                break;
              default:
                if (void 0 === t[i])
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
                    this
                  );
                t = t[i];
            }
            if (void 0 !== a) {
              if (void 0 === t[a])
                return void console.error(
                  'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
                  this,
                  t
                );
              t = t[a];
            }
          }
          var s = t[n];
          if (void 0 !== s) {
            var c = this.Versioning.None;
            void 0 !== (this.targetObject = t).needsUpdate
              ? (c = this.Versioning.NeedsUpdate)
              : void 0 !== t.matrixWorldNeedsUpdate &&
                (c = this.Versioning.MatrixWorldNeedsUpdate);
            var h = this.BindingType.Direct;
            if (void 0 !== r) {
              if ('morphTargetInfluences' === n) {
                if (!t.geometry)
                  return void console.error(
                    'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
                    this
                  );
                if (t.geometry.isBufferGeometry) {
                  if (!t.geometry.morphAttributes)
                    return void console.error(
                      'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
                      this
                    );
                  for (o = 0; o < this.node.geometry.morphAttributes.position.length; o++)
                    if (t.geometry.morphAttributes.position[o].name === r) {
                      r = o;
                      break;
                    }
                } else {
                  if (!t.geometry.morphTargets)
                    return void console.error(
                      'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.',
                      this
                    );
                  for (o = 0; o < this.node.geometry.morphTargets.length; o++)
                    if (t.geometry.morphTargets[o].name === r) {
                      r = o;
                      break;
                    }
                }
              }
              (h = this.BindingType.ArrayElement),
                (this.resolvedProperty = s),
                (this.propertyIndex = r);
            } else
              void 0 !== s.fromArray && void 0 !== s.toArray
                ? ((h = this.BindingType.HasFromToArray), (this.resolvedProperty = s))
                : Array.isArray(s)
                ? ((h = this.BindingType.EntireArray), (this.resolvedProperty = s))
                : (this.propertyName = n);
            (this.getValue = this.GetterByBindingType[h]),
              (this.setValue = this.SetterByBindingTypeAndVersioning[h][c]);
          } else {
            var l = e.nodeName;
            console.error(
              'THREE.PropertyBinding: Trying to update property for track: ' +
                l +
                '.' +
                n +
                " but it wasn't found.",
              t
            );
          }
        } else
          console.error(
            'THREE.PropertyBinding: Trying to update node for track: ' +
              this.path +
              " but it wasn't found."
          );
      },
      unbind: function () {
        (this.node = null),
          (this.getValue = this._getValue_unbound),
          (this.setValue = this._setValue_unbound);
      }
    }),
    Object.assign(Gu.prototype, {
      _getValue_unbound: Gu.prototype.getValue,
      _setValue_unbound: Gu.prototype.setValue
    }),
    Object.assign(Hu.prototype, {
      isAnimationObjectGroup: !0,
      add: function () {
        for (
          var t = this._objects,
            e = t.length,
            i = this.nCachedObjects_,
            n = this._indicesByUUID,
            r = this._paths,
            a = this._parsedPaths,
            o = this._bindings,
            s = o.length,
            c = void 0,
            h = 0,
            l = arguments.length;
          h !== l;
          ++h
        ) {
          var u = arguments[h],
            p = u.uuid,
            d = n[p];
          if (void 0 === d) {
            (d = e++), (n[p] = d), t.push(u);
            for (var f = 0, m = s; f !== m; ++f) o[f].push(new Gu(u, r[f], a[f]));
          } else if (d < i) {
            c = t[d];
            var g = --i,
              v = t[g];
            (t[(n[v.uuid] = d)] = v), (t[(n[p] = g)] = u);
            for (f = 0, m = s; f !== m; ++f) {
              var y = o[f],
                x = y[g],
                b = y[d];
              (y[d] = x), void 0 === b && (b = new Gu(u, r[f], a[f])), (y[g] = b);
            }
          } else
            t[d] !== c &&
              console.error(
                'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.'
              );
        }
        this.nCachedObjects_ = i;
      },
      remove: function () {
        for (
          var t = this._objects,
            e = this.nCachedObjects_,
            i = this._indicesByUUID,
            n = this._bindings,
            r = n.length,
            a = 0,
            o = arguments.length;
          a !== o;
          ++a
        ) {
          var s = arguments[a],
            c = s.uuid,
            h = i[c];
          if (void 0 !== h && e <= h) {
            var l = e++,
              u = t[l];
            (t[(i[u.uuid] = h)] = u), (t[(i[c] = l)] = s);
            for (var p = 0, d = r; p !== d; ++p) {
              var f = n[p],
                m = f[l],
                g = f[h];
              (f[h] = m), (f[l] = g);
            }
          }
        }
        this.nCachedObjects_ = e;
      },
      uncache: function () {
        for (
          var t = this._objects,
            e = t.length,
            i = this.nCachedObjects_,
            n = this._indicesByUUID,
            r = this._bindings,
            a = r.length,
            o = 0,
            s = arguments.length;
          o !== s;
          ++o
        ) {
          var c = arguments[o].uuid,
            h = n[c];
          if (void 0 !== h)
            if ((delete n[c], h < i)) {
              var l = --i,
                u = t[l],
                p = t[(v = --e)];
              (t[(n[u.uuid] = h)] = u), (t[(n[p.uuid] = l)] = p), t.pop();
              for (var d = 0, f = a; d !== f; ++d) {
                var m = (y = r[d])[l],
                  g = y[v];
                (y[h] = m), (y[l] = g), y.pop();
              }
            } else {
              var v;
              (t[(n[(p = t[(v = --e)]).uuid] = h)] = p), t.pop();
              for (d = 0, f = a; d !== f; ++d) {
                var y;
                ((y = r[d])[h] = y[v]), y.pop();
              }
            }
        }
        this.nCachedObjects_ = i;
      },
      subscribe_: function (t, e) {
        var i = this._bindingsIndicesByPath,
          n = i[t],
          r = this._bindings;
        if (void 0 !== n) return r[n];
        var a = this._paths,
          o = this._parsedPaths,
          s = this._objects,
          c = s.length,
          h = this.nCachedObjects_,
          l = new Array(c);
        (n = r.length), (i[t] = n), a.push(t), o.push(e), r.push(l);
        for (var u = h, p = s.length; u !== p; ++u) {
          var d = s[u];
          l[u] = new Gu(d, t, e);
        }
        return l;
      },
      unsubscribe_: function (t) {
        var e = this._bindingsIndicesByPath,
          i = e[t];
        if (void 0 !== i) {
          var n = this._paths,
            r = this._parsedPaths,
            a = this._bindings,
            o = a.length - 1,
            s = a[o];
          (a[(e[t[o]] = i)] = s), a.pop(), (r[i] = r[o]), r.pop(), (n[i] = n[o]), n.pop();
        }
      }
    }),
    Object.assign(Vu.prototype, {
      play: function () {
        return this._mixer._activateAction(this), this;
      },
      stop: function () {
        return this._mixer._deactivateAction(this), this.reset();
      },
      reset: function () {
        return (
          (this.paused = !1),
          (this.enabled = !0),
          (this.time = 0),
          (this._loopCount = -1),
          (this._startTime = null),
          this.stopFading().stopWarping()
        );
      },
      isRunning: function () {
        return (
          this.enabled &&
          !this.paused &&
          0 !== this.timeScale &&
          null === this._startTime &&
          this._mixer._isActiveAction(this)
        );
      },
      isScheduled: function () {
        return this._mixer._isActiveAction(this);
      },
      startAt: function (t) {
        return (this._startTime = t), this;
      },
      setLoop: function (t, e) {
        return (this.loop = t), (this.repetitions = e), this;
      },
      setEffectiveWeight: function (t) {
        return (
          (this.weight = t),
          (this._effectiveWeight = this.enabled ? t : 0),
          this.stopFading()
        );
      },
      getEffectiveWeight: function () {
        return this._effectiveWeight;
      },
      fadeIn: function (t) {
        return this._scheduleFading(t, 0, 1);
      },
      fadeOut: function (t) {
        return this._scheduleFading(t, 1, 0);
      },
      crossFadeFrom: function (t, e, i) {
        if ((t.fadeOut(e), this.fadeIn(e), i)) {
          var n = this._clip.duration,
            r = t._clip.duration,
            a = r / n,
            o = n / r;
          t.warp(1, a, e), this.warp(o, 1, e);
        }
        return this;
      },
      crossFadeTo: function (t, e, i) {
        return t.crossFadeFrom(this, e, i);
      },
      stopFading: function () {
        var t = this._weightInterpolant;
        return (
          null !== t &&
            ((this._weightInterpolant = null),
            this._mixer._takeBackControlInterpolant(t)),
          this
        );
      },
      setEffectiveTimeScale: function (t) {
        return (
          (this.timeScale = t),
          (this._effectiveTimeScale = this.paused ? 0 : t),
          this.stopWarping()
        );
      },
      getEffectiveTimeScale: function () {
        return this._effectiveTimeScale;
      },
      setDuration: function (t) {
        return (this.timeScale = this._clip.duration / t), this.stopWarping();
      },
      syncWith: function (t) {
        return (this.time = t.time), (this.timeScale = t.timeScale), this.stopWarping();
      },
      halt: function (t) {
        return this.warp(this._effectiveTimeScale, 0, t);
      },
      warp: function (t, e, i) {
        var n = this._mixer,
          r = n.time,
          a = this._timeScaleInterpolant,
          o = this.timeScale;
        null === a &&
          ((a = n._lendControlInterpolant()), (this._timeScaleInterpolant = a));
        var s = a.parameterPositions,
          c = a.sampleValues;
        return (s[0] = r), (s[1] = r + i), (c[0] = t / o), (c[1] = e / o), this;
      },
      stopWarping: function () {
        var t = this._timeScaleInterpolant;
        return (
          null !== t &&
            ((this._timeScaleInterpolant = null),
            this._mixer._takeBackControlInterpolant(t)),
          this
        );
      },
      getMixer: function () {
        return this._mixer;
      },
      getClip: function () {
        return this._clip;
      },
      getRoot: function () {
        return this._localRoot || this._mixer._root;
      },
      _update: function (t, e, i, n) {
        if (this.enabled) {
          var r = this._startTime;
          if (null !== r) {
            var a = (t - r) * i;
            if (a < 0 || 0 === i) return;
            (this._startTime = null), (e = i * a);
          }
          e *= this._updateTimeScale(t);
          var o = this._updateTime(e),
            s = this._updateWeight(t);
          if (0 < s)
            for (
              var c = this._interpolants, h = this._propertyBindings, l = 0, u = c.length;
              l !== u;
              ++l
            )
              c[l].evaluate(o), h[l].accumulate(n, s);
        } else this._updateWeight(t);
      },
      _updateWeight: function (t) {
        var e = 0;
        if (this.enabled) {
          e = this.weight;
          var i = this._weightInterpolant;
          if (null !== i) {
            var n = i.evaluate(t)[0];
            (e *= n),
              t > i.parameterPositions[1] &&
                (this.stopFading(), 0 === n && (this.enabled = !1));
          }
        }
        return (this._effectiveWeight = e);
      },
      _updateTimeScale: function (t) {
        var e = 0;
        if (!this.paused) {
          e = this.timeScale;
          var i = this._timeScaleInterpolant;
          if (null !== i)
            (e *= i.evaluate(t)[0]),
              t > i.parameterPositions[1] &&
                (this.stopWarping(), 0 === e ? (this.paused = !0) : (this.timeScale = e));
        }
        return (this._effectiveTimeScale = e);
      },
      _updateTime: function (t) {
        var e = this.time + t,
          i = this._clip.duration,
          n = this.loop,
          r = this._loopCount,
          a = 2202 === n;
        if (0 === t) return -1 === r ? e : a && 1 == (1 & r) ? i - e : e;
        if (2200 === n) {
          -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
          t: {
            if (i <= e) e = i;
            else {
              if (!(e < 0)) break t;
              e = 0;
            }
            this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
              this._mixer.dispatchEvent({
                type: 'finished',
                action: this,
                direction: t < 0 ? -1 : 1
              });
          }
        } else {
          if (
            (-1 === r &&
              (0 <= t
                ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, a))
                : this._setEndings(0 === this.repetitions, !0, a)),
            i <= e || e < 0)
          ) {
            var o = Math.floor(e / i);
            (e -= i * o), (r += Math.abs(o));
            var s = this.repetitions - r;
            if (s <= 0)
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (e = 0 < t ? i : 0),
                this._mixer.dispatchEvent({
                  type: 'finished',
                  action: this,
                  direction: 0 < t ? 1 : -1
                });
            else {
              if (1 == s) {
                var c = t < 0;
                this._setEndings(c, !c, a);
              } else this._setEndings(!1, !1, a);
              (this._loopCount = r),
                this._mixer.dispatchEvent({ type: 'loop', action: this, loopDelta: o });
            }
          }
          if (a && 1 == (1 & r)) return i - (this.time = e);
        }
        return (this.time = e);
      },
      _setEndings: function (t, e, i) {
        var n = this._interpolantSettings;
        i
          ? ((n.endingStart = Se), (n.endingEnd = Se))
          : ((n.endingStart = t ? (this.zeroSlopeAtStart ? Se : Te) : Ae),
            (n.endingEnd = e ? (this.zeroSlopeAtEnd ? Se : Te) : Ae));
      },
      _scheduleFading: function (t, e, i) {
        var n = this._mixer,
          r = n.time,
          a = this._weightInterpolant;
        null === a && ((a = n._lendControlInterpolant()), (this._weightInterpolant = a));
        var o = a.parameterPositions,
          s = a.sampleValues;
        return (o[0] = r), (s[0] = e), (o[1] = r + t), (s[1] = i), this;
      }
    }),
    (ku.prototype = Object.assign(Object.create(e.prototype), {
      constructor: ku,
      _bindAction: function (t, e) {
        var i = t._localRoot || this._root,
          n = t._clip.tracks,
          r = n.length,
          a = t._propertyBindings,
          o = t._interpolants,
          s = i.uuid,
          c = this._bindingsByRootAndName,
          h = c[s];
        void 0 === h && ((h = {}), (c[s] = h));
        for (var l = 0; l !== r; ++l) {
          var u = n[l],
            p = u.name,
            d = h[p];
          if (void 0 !== d) a[l] = d;
          else {
            if (void 0 !== (d = a[l])) {
              null === d._cacheIndex &&
                (++d.referenceCount, this._addInactiveBinding(d, s, p));
              continue;
            }
            var f = e && e._propertyBindings[l].binding.parsedPath;
            ++(d = new Kl(Gu.create(i, p, f), u.ValueTypeName, u.getValueSize()))
              .referenceCount,
              this._addInactiveBinding(d, s, p),
              (a[l] = d);
          }
          o[l].resultBuffer = d.buffer;
        }
      },
      _activateAction: function (t) {
        if (!this._isActiveAction(t)) {
          if (null === t._cacheIndex) {
            var e = (t._localRoot || this._root).uuid,
              i = t._clip.uuid,
              n = this._actionsByClip[i];
            this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e);
          }
          for (var r = t._propertyBindings, a = 0, o = r.length; a !== o; ++a) {
            var s = r[a];
            0 == s.useCount++ && (this._lendBinding(s), s.saveOriginalState());
          }
          this._lendAction(t);
        }
      },
      _deactivateAction: function (t) {
        if (this._isActiveAction(t)) {
          for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
            var r = e[i];
            0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r));
          }
          this._takeBackAction(t);
        }
      },
      _initMemoryManager: function () {
        (this._actions = []),
          (this._nActiveActions = 0),
          (this._actionsByClip = {}),
          (this._bindings = []),
          (this._nActiveBindings = 0),
          (this._bindingsByRootAndName = {}),
          (this._controlInterpolants = []),
          (this._nActiveControlInterpolants = 0);
        var t = this;
        this.stats = {
          actions: {
            get total() {
              return t._actions.length;
            },
            get inUse() {
              return t._nActiveActions;
            }
          },
          bindings: {
            get total() {
              return t._bindings.length;
            },
            get inUse() {
              return t._nActiveBindings;
            }
          },
          controlInterpolants: {
            get total() {
              return t._controlInterpolants.length;
            },
            get inUse() {
              return t._nActiveControlInterpolants;
            }
          }
        };
      },
      _isActiveAction: function (t) {
        var e = t._cacheIndex;
        return null !== e && e < this._nActiveActions;
      },
      _addInactiveAction: function (t, e, i) {
        var n = this._actions,
          r = this._actionsByClip,
          a = r[e];
        if (void 0 === a)
          (a = { knownActions: [t], actionByRoot: {} }),
            (t._byClipCacheIndex = 0),
            (r[e] = a);
        else {
          var o = a.knownActions;
          (t._byClipCacheIndex = o.length), o.push(t);
        }
        (t._cacheIndex = n.length), n.push(t), (a.actionByRoot[i] = t);
      },
      _removeInactiveAction: function (t) {
        var e = this._actions,
          i = e[e.length - 1],
          n = t._cacheIndex;
        (e[(i._cacheIndex = n)] = i), e.pop(), (t._cacheIndex = null);
        var r = t._clip.uuid,
          a = this._actionsByClip,
          o = a[r],
          s = o.knownActions,
          c = s[s.length - 1],
          h = t._byClipCacheIndex;
        (s[(c._byClipCacheIndex = h)] = c),
          s.pop(),
          (t._byClipCacheIndex = null),
          delete o.actionByRoot[(t._localRoot || this._root).uuid],
          0 === s.length && delete a[r],
          this._removeInactiveBindingsForAction(t);
      },
      _removeInactiveBindingsForAction: function (t) {
        for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
          var r = e[i];
          0 == --r.referenceCount && this._removeInactiveBinding(r);
        }
      },
      _lendAction: function (t) {
        var e = this._actions,
          i = t._cacheIndex,
          n = this._nActiveActions++,
          r = e[n];
        (e[(t._cacheIndex = n)] = t), (e[(r._cacheIndex = i)] = r);
      },
      _takeBackAction: function (t) {
        var e = this._actions,
          i = t._cacheIndex,
          n = --this._nActiveActions,
          r = e[n];
        (e[(t._cacheIndex = n)] = t), (e[(r._cacheIndex = i)] = r);
      },
      _addInactiveBinding: function (t, e, i) {
        var n = this._bindingsByRootAndName,
          r = n[e],
          a = this._bindings;
        void 0 === r && ((r = {}), (n[e] = r)),
          ((r[i] = t)._cacheIndex = a.length),
          a.push(t);
      },
      _removeInactiveBinding: function (t) {
        var e = this._bindings,
          i = t.binding,
          n = i.rootNode.uuid,
          r = i.path,
          a = this._bindingsByRootAndName,
          o = a[n],
          s = e[e.length - 1],
          c = t._cacheIndex;
        (e[(s._cacheIndex = c)] = s), e.pop(), delete o[r];
        t: {
          for (var h in o) break t;
          delete a[n];
        }
      },
      _lendBinding: function (t) {
        var e = this._bindings,
          i = t._cacheIndex,
          n = this._nActiveBindings++,
          r = e[n];
        (e[(t._cacheIndex = n)] = t), (e[(r._cacheIndex = i)] = r);
      },
      _takeBackBinding: function (t) {
        var e = this._bindings,
          i = t._cacheIndex,
          n = --this._nActiveBindings,
          r = e[n];
        (e[(t._cacheIndex = n)] = t), (e[(r._cacheIndex = i)] = r);
      },
      _lendControlInterpolant: function () {
        var t = this._controlInterpolants,
          e = this._nActiveControlInterpolants++,
          i = t[e];
        return (
          void 0 === i &&
            (t[
              ((i = new Yh(
                new Float32Array(2),
                new Float32Array(2),
                1,
                this._controlInterpolantsResultBuffer
              )).__cacheIndex = e)
            ] = i),
          i
        );
      },
      _takeBackControlInterpolant: function (t) {
        var e = this._controlInterpolants,
          i = t.__cacheIndex,
          n = --this._nActiveControlInterpolants,
          r = e[n];
        (e[(t.__cacheIndex = n)] = t), (e[(r.__cacheIndex = i)] = r);
      },
      _controlInterpolantsResultBuffer: new Float32Array(1),
      clipAction: function (t, e) {
        var i = e || this._root,
          n = i.uuid,
          r = 'string' == typeof t ? rl.findByName(i, t) : t,
          a = null !== r ? r.uuid : t,
          o = this._actionsByClip[a],
          s = null;
        if (void 0 !== o) {
          var c = o.actionByRoot[n];
          if (void 0 !== c) return c;
          (s = o.knownActions[0]), null === r && (r = s._clip);
        }
        if (null === r) return null;
        var h = new Vu(this, r, e);
        return this._bindAction(h, s), this._addInactiveAction(h, a, n), h;
      },
      existingAction: function (t, e) {
        var i = e || this._root,
          n = i.uuid,
          r = 'string' == typeof t ? rl.findByName(i, t) : t,
          a = r ? r.uuid : t,
          o = this._actionsByClip[a];
        return (void 0 !== o && o.actionByRoot[n]) || null;
      },
      stopAllAction: function () {
        var t = this._actions,
          e = this._nActiveActions,
          i = this._bindings,
          n = this._nActiveBindings;
        this._nActiveActions = 0;
        for (var r = (this._nActiveBindings = 0); r !== e; ++r) t[r].reset();
        for (r = 0; r !== n; ++r) i[r].useCount = 0;
        return this;
      },
      update: function (t) {
        t *= this.timeScale;
        for (
          var e = this._actions,
            i = this._nActiveActions,
            n = (this.time += t),
            r = Math.sign(t),
            a = (this._accuIndex ^= 1),
            o = 0;
          o !== i;
          ++o
        ) {
          e[o]._update(n, t, r, a);
        }
        var s = this._bindings,
          c = this._nActiveBindings;
        for (o = 0; o !== c; ++o) s[o].apply(a);
        return this;
      },
      getRoot: function () {
        return this._root;
      },
      uncacheClip: function (t) {
        var e = this._actions,
          i = t.uuid,
          n = this._actionsByClip,
          r = n[i];
        if (void 0 !== r) {
          for (var a = r.knownActions, o = 0, s = a.length; o !== s; ++o) {
            var c = a[o];
            this._deactivateAction(c);
            var h = c._cacheIndex,
              l = e[e.length - 1];
            (c._cacheIndex = null),
              (c._byClipCacheIndex = null),
              (e[(l._cacheIndex = h)] = l),
              e.pop(),
              this._removeInactiveBindingsForAction(c);
          }
          delete n[i];
        }
      },
      uncacheRoot: function (t) {
        var e = t.uuid,
          i = this._actionsByClip;
        for (var n in i) {
          var r = i[n].actionByRoot[e];
          void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r));
        }
        var a = this._bindingsByRootAndName[e];
        if (void 0 !== a)
          for (var o in a) {
            var s = a[o];
            s.restoreOriginalState(), this._removeInactiveBinding(s);
          }
      },
      uncacheAction: function (t, e) {
        var i = this.existingAction(t, e);
        null !== i && (this._deactivateAction(i), this._removeInactiveAction(i));
      }
    })),
    (ju.prototype.clone = function () {
      return new ju(void 0 === this.value.clone ? this.value : this.value.clone());
    }),
    (Wu.prototype = Object.assign(Object.create($n.prototype), {
      constructor: Wu,
      isInstancedBufferGeometry: !0,
      copy: function (t) {
        return (
          $n.prototype.copy.call(this, t),
          (this.maxInstancedCount = t.maxInstancedCount),
          this
        );
      },
      clone: function () {
        return new this.constructor().copy(this);
      }
    })),
    (Xu.prototype = Object.assign(Object.create(ds.prototype), {
      constructor: Xu,
      isInstancedInterleavedBuffer: !0,
      copy: function (t) {
        return (
          ds.prototype.copy.call(this, t),
          (this.meshPerAttribute = t.meshPerAttribute),
          this
        );
      }
    })),
    (qu.prototype = Object.assign(Object.create(Pn.prototype), {
      constructor: qu,
      isInstancedBufferAttribute: !0,
      copy: function (t) {
        return (
          Pn.prototype.copy.call(this, t),
          (this.meshPerAttribute = t.meshPerAttribute),
          this
        );
      }
    })),
    Object.assign(Yu.prototype, {
      linePrecision: 1,
      set: function (t, e) {
        this.ray.set(t, e);
      },
      setFromCamera: function (t, e) {
        e && e.isPerspectiveCamera
          ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld),
            this.ray.direction
              .set(t.x, t.y, 0.5)
              .unproject(e)
              .sub(this.ray.origin)
              .normalize())
          : e && e.isOrthographicCamera
          ? (this.ray.origin
              .set(t.x, t.y, (e.near + e.far) / (e.near - e.far))
              .unproject(e),
            this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld))
          : console.error('THREE.Raycaster: Unsupported camera type.');
      },
      intersectObject: function (t, e, i) {
        var n = i || [];
        return Zu(t, this, n, e), n.sort(Ju), n;
      },
      intersectObjects: function (t, e, i) {
        var n = i || [];
        if (!1 === Array.isArray(t))
          return (
            console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.'), n
          );
        for (var r = 0, a = t.length; r < a; r++) Zu(t[r], this, n, e);
        return n.sort(Ju), n;
      }
    }),
    Object.assign(Qu.prototype, {
      start: function () {
        (this.startTime = ('undefined' == typeof performance ? Date : performance).now()),
          (this.oldTime = this.startTime),
          (this.elapsedTime = 0),
          (this.running = !0);
      },
      stop: function () {
        this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
      },
      getElapsedTime: function () {
        return this.getDelta(), this.elapsedTime;
      },
      getDelta: function () {
        var t = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
          var e = ('undefined' == typeof performance ? Date : performance).now();
          (t = (e - this.oldTime) / 1e3), (this.oldTime = e), (this.elapsedTime += t);
        }
        return t;
      }
    }),
    Object.assign(Ku.prototype, {
      set: function (t, e, i) {
        return (this.radius = t), (this.phi = e), (this.theta = i), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (this.radius = t.radius), (this.phi = t.phi), (this.theta = t.theta), this;
      },
      makeSafe: function () {
        return (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this;
      },
      setFromVector3: function (t) {
        return this.setFromCartesianCoords(t.x, t.y, t.z);
      },
      setFromCartesianCoords: function (t, e, i) {
        return (
          (this.radius = Math.sqrt(t * t + e * e + i * i)),
          0 === this.radius
            ? ((this.theta = 0), (this.phi = 0))
            : ((this.theta = Math.atan2(t, i)),
              (this.phi = Math.acos(Ge.clamp(e / this.radius, -1, 1)))),
          this
        );
      }
    }),
    Object.assign($u.prototype, {
      set: function (t, e, i) {
        return (this.radius = t), (this.theta = e), (this.y = i), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return (this.radius = t.radius), (this.theta = t.theta), (this.y = t.y), this;
      },
      setFromVector3: function (t) {
        return this.setFromCartesianCoords(t.x, t.y, t.z);
      },
      setFromCartesianCoords: function (t, e, i) {
        return (
          (this.radius = Math.sqrt(t * t + i * i)),
          (this.theta = Math.atan2(t, i)),
          (this.y = e),
          this
        );
      }
    }),
    Object.assign(tp.prototype, {
      set: function (t, e) {
        return this.min.copy(t), this.max.copy(e), this;
      },
      setFromPoints: function (t) {
        this.makeEmpty();
        for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
        return this;
      },
      setFromCenterAndSize:
        ((hu = new He()),
        function (t, e) {
          var i = hu.copy(e).multiplyScalar(0.5);
          return this.min.copy(t).sub(i), this.max.copy(t).add(i), this;
        }),
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.min.copy(t.min), this.max.copy(t.max), this;
      },
      makeEmpty: function () {
        return (
          (this.min.x = this.min.y = 1 / 0), (this.max.x = this.max.y = -1 / 0), this
        );
      },
      isEmpty: function () {
        return this.max.x < this.min.x || this.max.y < this.min.y;
      },
      getCenter: function (t) {
        return (
          void 0 === t &&
            (console.warn('THREE.Box2: .getCenter() target is now required'),
            (t = new He())),
          this.isEmpty()
            ? t.set(0, 0)
            : t.addVectors(this.min, this.max).multiplyScalar(0.5)
        );
      },
      getSize: function (t) {
        return (
          void 0 === t &&
            (console.warn('THREE.Box2: .getSize() target is now required'),
            (t = new He())),
          this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        );
      },
      expandByPoint: function (t) {
        return this.min.min(t), this.max.max(t), this;
      },
      expandByVector: function (t) {
        return this.min.sub(t), this.max.add(t), this;
      },
      expandByScalar: function (t) {
        return this.min.addScalar(-t), this.max.addScalar(t), this;
      },
      containsPoint: function (t) {
        return !(
          t.x < this.min.x ||
          t.x > this.max.x ||
          t.y < this.min.y ||
          t.y > this.max.y
        );
      },
      containsBox: function (t) {
        return (
          this.min.x <= t.min.x &&
          t.max.x <= this.max.x &&
          this.min.y <= t.min.y &&
          t.max.y <= this.max.y
        );
      },
      getParameter: function (t, e) {
        return (
          void 0 === e &&
            (console.warn('THREE.Box2: .getParameter() target is now required'),
            (e = new He())),
          e.set(
            (t.x - this.min.x) / (this.max.x - this.min.x),
            (t.y - this.min.y) / (this.max.y - this.min.y)
          )
        );
      },
      intersectsBox: function (t) {
        return !(
          t.max.x < this.min.x ||
          t.min.x > this.max.x ||
          t.max.y < this.min.y ||
          t.min.y > this.max.y
        );
      },
      clampPoint: function (t, e) {
        return (
          void 0 === e &&
            (console.warn('THREE.Box2: .clampPoint() target is now required'),
            (e = new He())),
          e.copy(t).clamp(this.min, this.max)
        );
      },
      distanceToPoint:
        ((cu = new He()),
        function (t) {
          return cu.copy(t).clamp(this.min, this.max).sub(t).length();
        }),
      intersect: function (t) {
        return this.min.max(t.min), this.max.min(t.max), this;
      },
      union: function (t) {
        return this.min.min(t.min), this.max.max(t.max), this;
      },
      translate: function (t) {
        return this.min.add(t), this.max.add(t), this;
      },
      equals: function (t) {
        return t.min.equals(this.min) && t.max.equals(this.max);
      }
    }),
    Object.assign(ep.prototype, {
      set: function (t, e) {
        return this.start.copy(t), this.end.copy(e), this;
      },
      clone: function () {
        return new this.constructor().copy(this);
      },
      copy: function (t) {
        return this.start.copy(t.start), this.end.copy(t.end), this;
      },
      getCenter: function (t) {
        return (
          void 0 === t &&
            (console.warn('THREE.Line3: .getCenter() target is now required'),
            (t = new je())),
          t.addVectors(this.start, this.end).multiplyScalar(0.5)
        );
      },
      delta: function (t) {
        return (
          void 0 === t &&
            (console.warn('THREE.Line3: .delta() target is now required'),
            (t = new je())),
          t.subVectors(this.end, this.start)
        );
      },
      distanceSq: function () {
        return this.start.distanceToSquared(this.end);
      },
      distance: function () {
        return this.start.distanceTo(this.end);
      },
      at: function (t, e) {
        return (
          void 0 === e &&
            (console.warn('THREE.Line3: .at() target is now required'), (e = new je())),
          this.delta(e).multiplyScalar(t).add(this.start)
        );
      },
      closestPointToPointParameter:
        ((lu = new je()),
        (uu = new je()),
        function (t, e) {
          lu.subVectors(t, this.start), uu.subVectors(this.end, this.start);
          var i = uu.dot(uu),
            n = uu.dot(lu) / i;
          return e && (n = Ge.clamp(n, 0, 1)), n;
        }),
      closestPointToPoint: function (t, e, i) {
        var n = this.closestPointToPointParameter(t, e);
        return (
          void 0 === i &&
            (console.warn('THREE.Line3: .closestPointToPoint() target is now required'),
            (i = new je())),
          this.delta(i).multiplyScalar(n).add(this.start)
        );
      },
      applyMatrix4: function (t) {
        return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this;
      },
      equals: function (t) {
        return t.start.equals(this.start) && t.end.equals(this.end);
      }
    }),
    (((ip.prototype = Object.create(
      bn.prototype
    )).constructor = ip).prototype.isImmediateRenderObject = !0),
    (((np.prototype = Object.create(Es.prototype)).constructor = np).prototype.update =
      ((pu = new je()),
      (du = new je()),
      (fu = new We()),
      function () {
        var t = ['a', 'b', 'c'];
        this.object.updateMatrixWorld(!0), fu.getNormalMatrix(this.object.matrixWorld);
        var e = this.object.matrixWorld,
          i = this.geometry.attributes.position,
          n = this.object.geometry;
        if (n && n.isGeometry)
          for (var r = n.vertices, a = n.faces, o = 0, s = 0, c = a.length; s < c; s++)
            for (var h = a[s], l = 0, u = h.vertexNormals.length; l < u; l++) {
              var p = r[h[t[l]]],
                d = h.vertexNormals[l];
              pu.copy(p).applyMatrix4(e),
                du.copy(d).applyMatrix3(fu).normalize().multiplyScalar(this.size).add(pu),
                i.setXYZ(o, pu.x, pu.y, pu.z),
                (o += 1),
                i.setXYZ(o, du.x, du.y, du.z),
                (o += 1);
            }
        else if (n && n.isBufferGeometry) {
          var f = n.attributes.position,
            m = n.attributes.normal;
          for (l = o = 0, u = f.count; l < u; l++)
            pu.set(f.getX(l), f.getY(l), f.getZ(l)).applyMatrix4(e),
              du.set(m.getX(l), m.getY(l), m.getZ(l)),
              du.applyMatrix3(fu).normalize().multiplyScalar(this.size).add(pu),
              i.setXYZ(o, pu.x, pu.y, pu.z),
              (o += 1),
              i.setXYZ(o, du.x, du.y, du.z),
              (o += 1);
        }
        i.needsUpdate = !0;
      })),
    (((rp.prototype = Object.create(
      bn.prototype
    )).constructor = rp).prototype.dispose = function () {
      this.cone.geometry.dispose(), this.cone.material.dispose();
    }),
    (rp.prototype.update =
      ((mu = new je()),
      (gu = new je()),
      function () {
        this.light.updateMatrixWorld();
        var t = this.light.distance ? this.light.distance : 1e3,
          e = t * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, t),
          mu.setFromMatrixPosition(this.light.matrixWorld),
          gu.setFromMatrixPosition(this.light.target.matrixWorld),
          this.cone.lookAt(gu.sub(mu)),
          void 0 !== this.color
            ? this.cone.material.color.set(this.color)
            : this.cone.material.color.copy(this.light.color);
      })),
    (((ap.prototype = Object.create(
      Es.prototype
    )).constructor = ap).prototype.updateMatrixWorld =
      ((vu = new je()),
      (yu = new Ve()),
      (xu = new Ve()),
      function (t) {
        var e = this.bones,
          i = this.geometry,
          n = i.getAttribute('position');
        xu.getInverse(this.root.matrixWorld);
        for (var r = 0, a = 0; r < e.length; r++) {
          var o = e[r];
          o.parent &&
            o.parent.isBone &&
            (yu.multiplyMatrices(xu, o.matrixWorld),
            vu.setFromMatrixPosition(yu),
            n.setXYZ(a, vu.x, vu.y, vu.z),
            yu.multiplyMatrices(xu, o.parent.matrixWorld),
            vu.setFromMatrixPosition(yu),
            n.setXYZ(a + 1, vu.x, vu.y, vu.z),
            (a += 2));
        }
        (i.getAttribute('position').needsUpdate = !0),
          bn.prototype.updateMatrixWorld.call(this, t);
      })),
    (((op.prototype = Object.create(
      Jr.prototype
    )).constructor = op).prototype.dispose = function () {
      this.geometry.dispose(), this.material.dispose();
    }),
    (op.prototype.update = function () {
      void 0 !== this.color
        ? this.material.color.set(this.color)
        : this.material.color.copy(this.light.color);
    }),
    (((sp.prototype = Object.create(
      bn.prototype
    )).constructor = sp).prototype.dispose = function () {
      this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }),
    (sp.prototype.update = function () {
      var t = 0.5 * this.light.width,
        e = 0.5 * this.light.height,
        i = this.line.geometry.attributes.position,
        n = i.array;
      (n[0] = t),
        (n[1] = -e),
        (n[2] = 0),
        (n[3] = t),
        (n[4] = e),
        (n[5] = 0),
        (n[6] = -t),
        (n[7] = e),
        (n[8] = 0),
        (n[9] = -t),
        (n[10] = -e),
        (n[11] = 0),
        (n[12] = t),
        (n[13] = -e),
        (n[14] = 0),
        (i.needsUpdate = !0),
        void 0 !== this.color
          ? this.line.material.color.set(this.color)
          : this.line.material.color.copy(this.light.color);
    }),
    (((cp.prototype = Object.create(
      bn.prototype
    )).constructor = cp).prototype.dispose = function () {
      this.children[0].geometry.dispose(), this.children[0].material.dispose();
    }),
    (cp.prototype.update =
      ((bu = new je()),
      (_u = new Hi()),
      (wu = new Hi()),
      function () {
        var t = this.children[0];
        if (void 0 !== this.color) this.material.color.set(this.color);
        else {
          var e = t.geometry.getAttribute('color');
          _u.copy(this.light.color), wu.copy(this.light.groundColor);
          for (var i = 0, n = e.count; i < n; i++) {
            var r = i < n / 2 ? _u : wu;
            e.setXYZ(i, r.r, r.g, r.b);
          }
          e.needsUpdate = !0;
        }
        t.lookAt(bu.setFromMatrixPosition(this.light.matrixWorld).negate());
      })),
    ((hp.prototype = Object.create(Es.prototype)).constructor = hp),
    ((lp.prototype = Object.create(Es.prototype)).constructor = lp),
    (((up.prototype = Object.create(Es.prototype)).constructor = up).prototype.update =
      ((Mu = new je()),
      (Eu = new je()),
      (Tu = new We()),
      function () {
        this.object.updateMatrixWorld(!0), Tu.getNormalMatrix(this.object.matrixWorld);
        for (
          var t = this.object.matrixWorld,
            e = this.geometry.attributes.position,
            i = this.object.geometry,
            n = i.vertices,
            r = i.faces,
            a = 0,
            o = 0,
            s = r.length;
          o < s;
          o++
        ) {
          var c = r[o],
            h = c.normal;
          Mu.copy(n[c.a]).add(n[c.b]).add(n[c.c]).divideScalar(3).applyMatrix4(t),
            Eu.copy(h).applyMatrix3(Tu).normalize().multiplyScalar(this.size).add(Mu),
            e.setXYZ(a, Mu.x, Mu.y, Mu.z),
            (a += 1),
            e.setXYZ(a, Eu.x, Eu.y, Eu.z),
            (a += 1);
        }
        e.needsUpdate = !0;
      })),
    (((pp.prototype = Object.create(
      bn.prototype
    )).constructor = pp).prototype.dispose = function () {
      this.lightPlane.geometry.dispose(),
        this.lightPlane.material.dispose(),
        this.targetLine.geometry.dispose(),
        this.targetLine.material.dispose();
    }),
    (pp.prototype.update =
      ((Su = new je()),
      (Au = new je()),
      (Lu = new je()),
      function () {
        Su.setFromMatrixPosition(this.light.matrixWorld),
          Au.setFromMatrixPosition(this.light.target.matrixWorld),
          Lu.subVectors(Au, Su),
          this.lightPlane.lookAt(Lu),
          void 0 !== this.color
            ? (this.lightPlane.material.color.set(this.color),
              this.targetLine.material.color.set(this.color))
            : (this.lightPlane.material.color.copy(this.light.color),
              this.targetLine.material.color.copy(this.light.color)),
          this.targetLine.lookAt(Lu),
          (this.targetLine.scale.z = Lu.length());
      })),
    (((dp.prototype = Object.create(Es.prototype)).constructor = dp).prototype.update =
      ((Cu = new je()),
      (Ou = new rs()),
      function () {
        (Ru = this.geometry),
          (Pu = this.pointMap),
          Ou.projectionMatrix.copy(this.camera.projectionMatrix),
          fp('c', 0, 0, -1),
          fp('t', 0, 0, 1),
          fp('n1', -1, -1, -1),
          fp('n2', 1, -1, -1),
          fp('n3', -1, 1, -1),
          fp('n4', 1, 1, -1),
          fp('f1', -1, -1, 1),
          fp('f2', 1, -1, 1),
          fp('f3', -1, 1, 1),
          fp('f4', 1, 1, 1),
          fp('u1', 0.7, 1.1, -1),
          fp('u2', -0.7, 1.1, -1),
          fp('u3', 0, 2, -1),
          fp('cf1', -1, 0, 1),
          fp('cf2', 1, 0, 1),
          fp('cf3', 0, -1, 1),
          fp('cf4', 0, 1, 1),
          fp('cn1', -1, 0, -1),
          fp('cn2', 1, 0, -1),
          fp('cn3', 0, -1, -1),
          fp('cn4', 0, 1, -1),
          (Ru.getAttribute('position').needsUpdate = !0);
      })),
    (((mp.prototype = Object.create(Es.prototype)).constructor = mp).prototype.update =
      ((Iu = new Ri()),
      function (t) {
        if (
          (void 0 !== t &&
            console.warn('THREE.BoxHelper: .update() has no longer arguments.'),
          void 0 !== this.object && Iu.setFromObject(this.object),
          !Iu.isEmpty())
        ) {
          var e = Iu.min,
            i = Iu.max,
            n = this.geometry.attributes.position,
            r = n.array;
          (r[0] = i.x),
            (r[1] = i.y),
            (r[2] = i.z),
            (r[3] = e.x),
            (r[4] = i.y),
            (r[5] = i.z),
            (r[6] = e.x),
            (r[7] = e.y),
            (r[8] = i.z),
            (r[9] = i.x),
            (r[10] = e.y),
            (r[11] = i.z),
            (r[12] = i.x),
            (r[13] = i.y),
            (r[14] = e.z),
            (r[15] = e.x),
            (r[16] = i.y),
            (r[17] = e.z),
            (r[18] = e.x),
            (r[19] = e.y),
            (r[20] = e.z),
            (r[21] = i.x),
            (r[22] = e.y),
            (r[23] = e.z),
            (n.needsUpdate = !0),
            this.geometry.computeBoundingSphere();
        }
      })),
    (mp.prototype.setFromObject = function (t) {
      return (this.object = t), this.update(), this;
    }),
    (((gp.prototype = Object.create(
      Es.prototype
    )).constructor = gp).prototype.updateMatrixWorld = function (t) {
      var e = this.box;
      e.isEmpty() ||
        (e.getCenter(this.position),
        e.getSize(this.scale),
        this.scale.multiplyScalar(0.5),
        bn.prototype.updateMatrixWorld.call(this, t));
    }),
    (((vp.prototype = Object.create(
      Ms.prototype
    )).constructor = vp).prototype.updateMatrixWorld = function (t) {
      var e = -this.plane.constant;
      Math.abs(e) < 1e-8 && (e = 1e-8),
        this.scale.set(0.5 * this.size, 0.5 * this.size, e),
        (this.children[0].material.side = e < 0 ? wt : D),
        this.lookAt(this.plane.normal),
        bn.prototype.updateMatrixWorld.call(this, t);
    }),
    (((yp.prototype = Object.create(
      bn.prototype
    )).constructor = yp).prototype.setDirection =
      ((Bu = new je()),
      function (t) {
        0.99999 < t.y
          ? this.quaternion.set(0, 0, 0, 1)
          : t.y < -0.99999
          ? this.quaternion.set(1, 0, 0, 0)
          : (Bu.set(t.z, 0, -t.x).normalize(),
            (Uu = Math.acos(t.y)),
            this.quaternion.setFromAxisAngle(Bu, Uu));
      })),
    (yp.prototype.setLength = function (t, e, i) {
      void 0 === e && (e = 0.2 * t),
        void 0 === i && (i = 0.2 * e),
        this.line.scale.set(1, Math.max(0, t - e), 1),
        this.line.updateMatrix(),
        this.cone.scale.set(i, e, i),
        (this.cone.position.y = t),
        this.cone.updateMatrix();
    }),
    (yp.prototype.setColor = function (t) {
      this.line.material.color.copy(t), this.cone.material.color.copy(t);
    }),
    ((xp.prototype = Object.create(Es.prototype)).constructor = xp);
  var bp;
  function _p(t) {
    console.warn(
      'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.'
    ),
      xh.call(this, t),
      (this.type = 'catmullrom'),
      (this.closed = !0);
  }
  function wp(t) {
    console.warn(
      'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.'
    ),
      xh.call(this, t),
      (this.type = 'catmullrom');
  }
  function Mp(t) {
    console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.'),
      xh.call(this, t),
      (this.type = 'catmullrom');
  }
  (uh.create = function (t, e) {
    return (
      console.log('THREE.Curve.create() has been deprecated'),
      (t.prototype = Object.create(uh.prototype)),
      ((t.prototype.constructor = t).prototype.getPoint = e),
      t
    );
  }),
    Object.assign(Ch.prototype, {
      createPointsGeometry: function (t) {
        console.warn(
          'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'
        );
        var e = this.getPoints(t);
        return this.createGeometry(e);
      },
      createSpacedPointsGeometry: function (t) {
        console.warn(
          'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'
        );
        var e = this.getSpacedPoints(t);
        return this.createGeometry(e);
      },
      createGeometry: function (t) {
        console.warn(
          'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.'
        );
        for (var e = new Rn(), i = 0, n = t.length; i < n; i++) {
          var r = t[i];
          e.vertices.push(new je(r.x, r.y, r.z || 0));
        }
        return e;
      }
    }),
    Object.assign(Oh.prototype, {
      fromPoints: function (t) {
        console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().'),
          this.setFromPoints(t);
      }
    }),
    (_p.prototype = Object.create(xh.prototype)),
    (wp.prototype = Object.create(xh.prototype)),
    (Mp.prototype = Object.create(xh.prototype)),
    Object.assign(Mp.prototype, {
      initFromArray: function () {
        console.error('THREE.Spline: .initFromArray() has been removed.');
      },
      getControlPointsArray: function () {
        console.error('THREE.Spline: .getControlPointsArray() has been removed.');
      },
      reparametrizeByArcLength: function () {
        console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');
      }
    }),
    (hp.prototype.setColors = function () {
      console.error(
        'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.'
      );
    }),
    (ap.prototype.update = function () {
      console.error('THREE.SkeletonHelper: update() no longer needs to be called.');
    }),
    Object.assign(dl.prototype, {
      extractUrlBase: function (t) {
        return (
          console.warn(
            'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.'
          ),
          fl.extractUrlBase(t)
        );
      }
    }),
    Object.assign(ml.prototype, {
      setTexturePath: function (t) {
        return (
          console.warn(
            'THREE.JSONLoader: .setTexturePath() has been renamed to .setResourcePath().'
          ),
          this.setResourcePath(t)
        );
      }
    }),
    Object.assign(tp.prototype, {
      center: function (t) {
        return (
          console.warn('THREE.Box2: .center() has been renamed to .getCenter().'),
          this.getCenter(t)
        );
      },
      empty: function () {
        return (
          console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().'),
          this.isEmpty()
        );
      },
      isIntersectionBox: function (t) {
        return (
          console.warn(
            'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().'
          ),
          this.intersectsBox(t)
        );
      },
      size: function (t) {
        return (
          console.warn('THREE.Box2: .size() has been renamed to .getSize().'),
          this.getSize(t)
        );
      }
    }),
    Object.assign(Ri.prototype, {
      center: function (t) {
        return (
          console.warn('THREE.Box3: .center() has been renamed to .getCenter().'),
          this.getCenter(t)
        );
      },
      empty: function () {
        return (
          console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().'),
          this.isEmpty()
        );
      },
      isIntersectionBox: function (t) {
        return (
          console.warn(
            'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().'
          ),
          this.intersectsBox(t)
        );
      },
      isIntersectionSphere: function (t) {
        return (
          console.warn(
            'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().'
          ),
          this.intersectsSphere(t)
        );
      },
      size: function (t) {
        return (
          console.warn('THREE.Box3: .size() has been renamed to .getSize().'),
          this.getSize(t)
        );
      }
    }),
    (ep.prototype.center = function (t) {
      return (
        console.warn('THREE.Line3: .center() has been renamed to .getCenter().'),
        this.getCenter(t)
      );
    }),
    Object.assign(Ge, {
      random16: function () {
        return (
          console.warn(
            'THREE.Math: .random16() has been deprecated. Use Math.random() instead.'
          ),
          Math.random()
        );
      },
      nearestPowerOfTwo: function (t) {
        return (
          console.warn(
            'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().'
          ),
          Ge.floorPowerOfTwo(t)
        );
      },
      nextPowerOfTwo: function (t) {
        return (
          console.warn(
            'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().'
          ),
          Ge.ceilPowerOfTwo(t)
        );
      }
    }),
    Object.assign(We.prototype, {
      flattenToArrayOffset: function (t, e) {
        return (
          console.warn(
            'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.'
          ),
          this.toArray(t, e)
        );
      },
      multiplyVector3: function (t) {
        return (
          console.warn(
            'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.'
          ),
          t.applyMatrix3(this)
        );
      },
      multiplyVector3Array: function () {
        console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');
      },
      applyToBuffer: function (t) {
        return (
          console.warn(
            'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.'
          ),
          this.applyToBufferAttribute(t)
        );
      },
      applyToVector3Array: function () {
        console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');
      }
    }),
    Object.assign(Ve.prototype, {
      extractPosition: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().'
          ),
          this.copyPosition(t)
        );
      },
      flattenToArrayOffset: function (t, e) {
        return (
          console.warn(
            'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.'
          ),
          this.toArray(t, e)
        );
      },
      getPosition: function () {
        return (
          void 0 === bp && (bp = new je()),
          console.warn(
            'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.'
          ),
          bp.setFromMatrixColumn(this, 3)
        );
      },
      setRotationFromQuaternion: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().'
          ),
          this.makeRotationFromQuaternion(t)
        );
      },
      multiplyToArray: function () {
        console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');
      },
      multiplyVector3: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.'
          ),
          t.applyMatrix4(this)
        );
      },
      multiplyVector4: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.'
          ),
          t.applyMatrix4(this)
        );
      },
      multiplyVector3Array: function () {
        console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');
      },
      rotateAxis: function (t) {
        console.warn(
          'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.'
        ),
          t.transformDirection(this);
      },
      crossVector: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.'
          ),
          t.applyMatrix4(this)
        );
      },
      translate: function () {
        console.error('THREE.Matrix4: .translate() has been removed.');
      },
      rotateX: function () {
        console.error('THREE.Matrix4: .rotateX() has been removed.');
      },
      rotateY: function () {
        console.error('THREE.Matrix4: .rotateY() has been removed.');
      },
      rotateZ: function () {
        console.error('THREE.Matrix4: .rotateZ() has been removed.');
      },
      rotateByAxis: function () {
        console.error('THREE.Matrix4: .rotateByAxis() has been removed.');
      },
      applyToBuffer: function (t) {
        return (
          console.warn(
            'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.'
          ),
          this.applyToBufferAttribute(t)
        );
      },
      applyToVector3Array: function () {
        console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');
      },
      makeFrustum: function (t, e, i, n, r, a) {
        return (
          console.warn(
            'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.'
          ),
          this.makePerspective(t, e, n, i, r, a)
        );
      }
    }),
    (Ii.prototype.isIntersectionLine = function (t) {
      return (
        console.warn(
          'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().'
        ),
        this.intersectsLine(t)
      );
    }),
    (ke.prototype.multiplyVector3 = function (t) {
      return (
        console.warn(
          'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.'
        ),
        t.applyQuaternion(this)
      );
    }),
    Object.assign(Xr.prototype, {
      isIntersectionBox: function (t) {
        return (
          console.warn(
            'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().'
          ),
          this.intersectsBox(t)
        );
      },
      isIntersectionPlane: function (t) {
        return (
          console.warn(
            'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().'
          ),
          this.intersectsPlane(t)
        );
      },
      isIntersectionSphere: function (t) {
        return (
          console.warn(
            'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().'
          ),
          this.intersectsSphere(t)
        );
      }
    }),
    Object.assign(qr.prototype, {
      area: function () {
        return (
          console.warn('THREE.Triangle: .area() has been renamed to .getArea().'),
          this.getArea()
        );
      },
      barycoordFromPoint: function (t, e) {
        return (
          console.warn(
            'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().'
          ),
          this.getBarycoord(t, e)
        );
      },
      midpoint: function (t) {
        return (
          console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().'),
          this.getMidpoint(t)
        );
      },
      normal: function (t) {
        return (
          console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().'),
          this.getNormal(t)
        );
      },
      plane: function (t) {
        return (
          console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().'),
          this.getPlane(t)
        );
      }
    }),
    Object.assign(qr, {
      barycoordFromPoint: function (t, e, i, n, r) {
        return (
          console.warn(
            'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().'
          ),
          qr.getBarycoord(t, e, i, n, r)
        );
      },
      normal: function (t, e, i, n) {
        return (
          console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().'),
          qr.getNormal(t, e, i, n)
        );
      }
    }),
    Object.assign(Ih.prototype, {
      extractAllPoints: function (t) {
        return (
          console.warn(
            'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.'
          ),
          this.extractPoints(t)
        );
      },
      extrude: function (t) {
        return (
          console.warn(
            'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.'
          ),
          new _c(this, t)
        );
      },
      makeGeometry: function (t) {
        return (
          console.warn(
            'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.'
          ),
          new Ic(this, t)
        );
      }
    }),
    Object.assign(He.prototype, {
      fromAttribute: function (t, e, i) {
        return (
          console.warn(
            'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().'
          ),
          this.fromBufferAttribute(t, e, i)
        );
      },
      distanceToManhattan: function (t) {
        return (
          console.warn(
            'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().'
          ),
          this.manhattanDistanceTo(t)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn(
            'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().'
          ),
          this.manhattanLength()
        );
      }
    }),
    Object.assign(je.prototype, {
      setEulerFromRotationMatrix: function () {
        console.error(
          'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.'
        );
      },
      setEulerFromQuaternion: function () {
        console.error(
          'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.'
        );
      },
      getPositionFromMatrix: function (t) {
        return (
          console.warn(
            'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().'
          ),
          this.setFromMatrixPosition(t)
        );
      },
      getScaleFromMatrix: function (t) {
        return (
          console.warn(
            'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().'
          ),
          this.setFromMatrixScale(t)
        );
      },
      getColumnFromMatrix: function (t, e) {
        return (
          console.warn(
            'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().'
          ),
          this.setFromMatrixColumn(e, t)
        );
      },
      applyProjection: function (t) {
        return (
          console.warn(
            'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.'
          ),
          this.applyMatrix4(t)
        );
      },
      fromAttribute: function (t, e, i) {
        return (
          console.warn(
            'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().'
          ),
          this.fromBufferAttribute(t, e, i)
        );
      },
      distanceToManhattan: function (t) {
        return (
          console.warn(
            'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().'
          ),
          this.manhattanDistanceTo(t)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn(
            'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().'
          ),
          this.manhattanLength()
        );
      }
    }),
    Object.assign(Ti.prototype, {
      fromAttribute: function (t, e, i) {
        return (
          console.warn(
            'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().'
          ),
          this.fromBufferAttribute(t, e, i)
        );
      },
      lengthManhattan: function () {
        return (
          console.warn(
            'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().'
          ),
          this.manhattanLength()
        );
      }
    }),
    Object.assign(Rn.prototype, {
      computeTangents: function () {
        console.error('THREE.Geometry: .computeTangents() has been removed.');
      },
      computeLineDistances: function () {
        console.error(
          'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.'
        );
      }
    }),
    Object.assign(bn.prototype, {
      getChildByName: function (t) {
        return (
          console.warn(
            'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().'
          ),
          this.getObjectByName(t)
        );
      },
      renderDepth: function () {
        console.warn(
          'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.'
        );
      },
      translate: function (t, e) {
        return (
          console.warn(
            'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.'
          ),
          this.translateOnAxis(e, t)
        );
      },
      getWorldRotation: function () {
        console.error(
          'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.'
        );
      }
    }),
    Object.defineProperties(bn.prototype, {
      eulerOrder: {
        get: function () {
          return (
            console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'),
            this.rotation.order
          );
        },
        set: function (t) {
          console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.'),
            (this.rotation.order = t);
        }
      },
      useQuaternion: {
        get: function () {
          console.warn(
            'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.'
          );
        },
        set: function () {
          console.warn(
            'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.'
          );
        }
      }
    }),
    Object.defineProperties(ys.prototype, {
      objects: {
        get: function () {
          return (
            console.warn('THREE.LOD: .objects has been renamed to .levels.'), this.levels
          );
        }
      }
    }),
    Object.defineProperty(xs.prototype, 'useVertexTexture', {
      get: function () {
        console.warn('THREE.Skeleton: useVertexTexture has been removed.');
      },
      set: function () {
        console.warn('THREE.Skeleton: useVertexTexture has been removed.');
      }
    }),
    Object.defineProperty(uh.prototype, '__arcLengthDivisions', {
      get: function () {
        return (
          console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.'),
          this.arcLengthDivisions
        );
      },
      set: function (t) {
        console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.'),
          (this.arcLengthDivisions = t);
      }
    }),
    (as.prototype.setLens = function (t, e) {
      console.warn(
        'THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.'
      ),
        void 0 !== e && (this.filmGauge = e),
        this.setFocalLength(t);
    }),
    Object.defineProperties(Nh.prototype, {
      onlyShadow: {
        set: function () {
          console.warn('THREE.Light: .onlyShadow has been removed.');
        }
      },
      shadowCameraFov: {
        set: function (t) {
          console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.'),
            (this.shadow.camera.fov = t);
        }
      },
      shadowCameraLeft: {
        set: function (t) {
          console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.'),
            (this.shadow.camera.left = t);
        }
      },
      shadowCameraRight: {
        set: function (t) {
          console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.'),
            (this.shadow.camera.right = t);
        }
      },
      shadowCameraTop: {
        set: function (t) {
          console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.'),
            (this.shadow.camera.top = t);
        }
      },
      shadowCameraBottom: {
        set: function (t) {
          console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.'),
            (this.shadow.camera.bottom = t);
        }
      },
      shadowCameraNear: {
        set: function (t) {
          console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.'),
            (this.shadow.camera.near = t);
        }
      },
      shadowCameraFar: {
        set: function (t) {
          console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.'),
            (this.shadow.camera.far = t);
        }
      },
      shadowCameraVisible: {
        set: function () {
          console.warn(
            'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.'
          );
        }
      },
      shadowBias: {
        set: function (t) {
          console.warn('THREE.Light: .shadowBias is now .shadow.bias.'),
            (this.shadow.bias = t);
        }
      },
      shadowDarkness: {
        set: function () {
          console.warn('THREE.Light: .shadowDarkness has been removed.');
        }
      },
      shadowMapWidth: {
        set: function (t) {
          console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.'),
            (this.shadow.mapSize.width = t);
        }
      },
      shadowMapHeight: {
        set: function (t) {
          console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.'),
            (this.shadow.mapSize.height = t);
        }
      }
    }),
    Object.defineProperties(Pn.prototype, {
      length: {
        get: function () {
          return (
            console.warn(
              'THREE.BufferAttribute: .length has been deprecated. Use .count instead.'
            ),
            this.array.length
          );
        }
      },
      copyIndicesArray: function () {
        console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');
      }
    }),
    Object.assign($n.prototype, {
      addIndex: function (t) {
        console.warn(
          'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().'
        ),
          this.setIndex(t);
      },
      addDrawCall: function (t, e, i) {
        void 0 !== i &&
          console.warn(
            'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.'
          ),
          console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().'),
          this.addGroup(t, e);
      },
      clearDrawCalls: function () {
        console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().'),
          this.clearGroups();
      },
      computeTangents: function () {
        console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');
      },
      computeOffsets: function () {
        console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');
      }
    }),
    Object.defineProperties($n.prototype, {
      drawcalls: {
        get: function () {
          return (
            console.error(
              'THREE.BufferGeometry: .drawcalls has been renamed to .groups.'
            ),
            this.groups
          );
        }
      },
      offsets: {
        get: function () {
          return (
            console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.'),
            this.groups
          );
        }
      }
    }),
    Object.assign(wc.prototype, {
      getArrays: function () {
        console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');
      },
      addShapeList: function () {
        console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');
      },
      addShape: function () {
        console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');
      }
    }),
    Object.defineProperties(ju.prototype, {
      dynamic: {
        set: function () {
          console.warn(
            'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.'
          );
        }
      },
      onUpdate: {
        value: function () {
          return (
            console.warn(
              'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.'
            ),
            this
          );
        }
      }
    }),
    Object.defineProperties(jr.prototype, {
      wrapAround: {
        get: function () {
          console.warn('THREE.Material: .wrapAround has been removed.');
        },
        set: function () {
          console.warn('THREE.Material: .wrapAround has been removed.');
        }
      },
      wrapRGB: {
        get: function () {
          return console.warn('THREE.Material: .wrapRGB has been removed.'), new Hi();
        }
      },
      shading: {
        get: function () {
          console.error(
            'THREE.' +
              this.type +
              ': .shading has been removed. Use the boolean .flatShading instead.'
          );
        },
        set: function (t) {
          console.warn(
            'THREE.' +
              this.type +
              ': .shading has been removed. Use the boolean .flatShading instead.'
          ),
            (this.flatShading = 1 === t);
        }
      }
    }),
    Object.defineProperties(Yc.prototype, {
      metal: {
        get: function () {
          return (
            console.warn(
              'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.'
            ),
            !1
          );
        },
        set: function () {
          console.warn(
            'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead'
          );
        }
      }
    }),
    Object.defineProperties(Wr.prototype, {
      derivatives: {
        get: function () {
          return (
            console.warn(
              'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.'
            ),
            this.extensions.derivatives
          );
        },
        set: function (t) {
          console.warn(
            'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.'
          ),
            (this.extensions.derivatives = t);
        }
      }
    }),
    Object.assign(hs.prototype, {
      clearTarget: function (t, e, i, n) {
        console.warn(
          'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.'
        ),
          this.setRenderTarget(t),
          this.clear(e, i, n);
      },
      animate: function (t) {
        console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().'),
          this.setAnimationLoop(t);
      },
      getCurrentRenderTarget: function () {
        return (
          console.warn(
            'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().'
          ),
          this.getRenderTarget()
        );
      },
      getMaxAnisotropy: function () {
        return (
          console.warn(
            'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().'
          ),
          this.capabilities.getMaxAnisotropy()
        );
      },
      getPrecision: function () {
        return (
          console.warn(
            'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.'
          ),
          this.capabilities.precision
        );
      },
      resetGLState: function () {
        return (
          console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().'),
          this.state.reset()
        );
      },
      supportsFloatTextures: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."
          ),
          this.extensions.get('OES_texture_float')
        );
      },
      supportsHalfFloatTextures: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."
          ),
          this.extensions.get('OES_texture_half_float')
        );
      },
      supportsStandardDerivatives: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."
          ),
          this.extensions.get('OES_standard_derivatives')
        );
      },
      supportsCompressedTextureS3TC: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."
          ),
          this.extensions.get('WEBGL_compressed_texture_s3tc')
        );
      },
      supportsCompressedTexturePVRTC: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."
          ),
          this.extensions.get('WEBGL_compressed_texture_pvrtc')
        );
      },
      supportsBlendMinMax: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."
          ),
          this.extensions.get('EXT_blend_minmax')
        );
      },
      supportsVertexTextures: function () {
        return (
          console.warn(
            'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.'
          ),
          this.capabilities.vertexTextures
        );
      },
      supportsInstancedArrays: function () {
        return (
          console.warn(
            "THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."
          ),
          this.extensions.get('ANGLE_instanced_arrays')
        );
      },
      enableScissorTest: function (t) {
        console.warn(
          'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().'
        ),
          this.setScissorTest(t);
      },
      initMaterial: function () {
        console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');
      },
      addPrePlugin: function () {
        console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');
      },
      addPostPlugin: function () {
        console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');
      },
      updateShadowMap: function () {
        console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');
      },
      setFaceCulling: function () {
        console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');
      }
    }),
    Object.defineProperties(hs.prototype, {
      shadowMapEnabled: {
        get: function () {
          return this.shadowMap.enabled;
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.'
          ),
            (this.shadowMap.enabled = t);
        }
      },
      shadowMapType: {
        get: function () {
          return this.shadowMap.type;
        },
        set: function (t) {
          console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.'),
            (this.shadowMap.type = t);
        }
      },
      shadowMapCullFace: {
        get: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.'
          );
        },
        set: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.'
          );
        }
      }
    }),
    Object.defineProperties($o.prototype, {
      cullFace: {
        get: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.'
          );
        },
        set: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.'
          );
        }
      },
      renderReverseSided: {
        get: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.'
          );
        },
        set: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.'
          );
        }
      },
      renderSingleSided: {
        get: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.'
          );
        },
        set: function () {
          console.warn(
            'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.'
          );
        }
      }
    }),
    Object.defineProperties(Si.prototype, {
      wrapS: {
        get: function () {
          return (
            console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'),
            this.texture.wrapS
          );
        },
        set: function (t) {
          console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.'),
            (this.texture.wrapS = t);
        }
      },
      wrapT: {
        get: function () {
          return (
            console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'),
            this.texture.wrapT
          );
        },
        set: function (t) {
          console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.'),
            (this.texture.wrapT = t);
        }
      },
      magFilter: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'
            ),
            this.texture.magFilter
          );
        },
        set: function (t) {
          console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.'),
            (this.texture.magFilter = t);
        }
      },
      minFilter: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'
            ),
            this.texture.minFilter
          );
        },
        set: function (t) {
          console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.'),
            (this.texture.minFilter = t);
        }
      },
      anisotropy: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'
            ),
            this.texture.anisotropy
          );
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.'
          ),
            (this.texture.anisotropy = t);
        }
      },
      offset: {
        get: function () {
          return (
            console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.'),
            this.texture.offset
          );
        },
        set: function (t) {
          console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.'),
            (this.texture.offset = t);
        }
      },
      repeat: {
        get: function () {
          return (
            console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'),
            this.texture.repeat
          );
        },
        set: function (t) {
          console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.'),
            (this.texture.repeat = t);
        }
      },
      format: {
        get: function () {
          return (
            console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.'),
            this.texture.format
          );
        },
        set: function (t) {
          console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.'),
            (this.texture.format = t);
        }
      },
      type: {
        get: function () {
          return (
            console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.'),
            this.texture.type
          );
        },
        set: function (t) {
          console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.'),
            (this.texture.type = t);
        }
      },
      generateMipmaps: {
        get: function () {
          return (
            console.warn(
              'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.'
            ),
            this.texture.generateMipmaps
          );
        },
        set: function (t) {
          console.warn(
            'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.'
          ),
            (this.texture.generateMipmaps = t);
        }
      }
    }),
    Object.defineProperties(ss.prototype, {
      standing: {
        set: function () {
          console.warn('THREE.WebVRManager: .standing has been removed.');
        }
      },
      userHeight: {
        set: function () {
          console.warn('THREE.WebVRManager: .userHeight has been removed.');
        }
      }
    }),
    (Jl.prototype.load = function (t) {
      console.warn(
        'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.'
      );
      var e = this;
      return (
        new Wl().load(t, function (t) {
          e.setBuffer(t);
        }),
        this
      );
    }),
    (Ql.prototype.getData = function () {
      return (
        console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().'),
        this.getFrequencyData()
      );
    }),
    (ql.prototype.updateCubeMap = function (t, e) {
      return (
        console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().'),
        this.update(t, e)
      );
    });
  var Ep = {
    merge: function (t, e, i) {
      var n;
      console.warn(
        'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.'
      ),
        e.isMesh &&
          (e.matrixAutoUpdate && e.updateMatrix(), (n = e.matrix), (e = e.geometry)),
        t.merge(e, n, i);
    },
    center: function (t) {
      return (
        console.warn(
          'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.'
        ),
        t.center()
      );
    }
  };
  (wi.crossOrigin = void 0),
    (wi.loadTexture = function (t, e, i, n) {
      console.warn(
        'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.'
      );
      var r = new lh();
      r.setCrossOrigin(this.crossOrigin);
      var a = r.load(t, i, void 0, n);
      return e && (a.mapping = e), a;
    }),
    (wi.loadTextureCube = function (t, e, i, n) {
      console.warn(
        'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.'
      );
      var r = new hh();
      r.setCrossOrigin(this.crossOrigin);
      var a = r.load(t, i, void 0, n);
      return e && (a.mapping = e), a;
    }),
    (wi.loadCompressedTexture = function () {
      console.error(
        'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.'
      );
    }),
    (wi.loadCompressedTextureCube = function () {
      console.error(
        'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.'
      );
    });
  var Tp = {
    createMultiMaterialObject: function () {
      console.error(
        'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js'
      );
    },
    detach: function () {
      console.error(
        'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js'
      );
    },
    attach: function () {
      console.error(
        'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js'
      );
    }
  };
  (t.WebGLRenderTargetCube = Ai),
    (t.WebGLRenderTarget = Si),
    (t.WebGLRenderer = hs),
    (t.ShaderLib = Yi),
    (t.UniformsLib = qi),
    (t.UniformsUtils = zi),
    (t.ShaderChunk = Fi),
    (t.FogExp2 = ls),
    (t.Fog = us),
    (t.Scene = ps),
    (t.Sprite = gs),
    (t.LOD = ys),
    (t.SkinnedMesh = _s),
    (t.Skeleton = xs),
    (t.Bone = bs),
    (t.Mesh = Jr),
    (t.LineSegments = Es),
    (t.LineLoop = Ts),
    (t.Line = Ms),
    (t.Points = As),
    (t.Group = ns),
    (t.VideoTexture = Ls),
    (t.DataTexture = Li),
    (t.DataTexture3D = la),
    (t.CompressedTexture = Rs),
    (t.CubeTexture = ha),
    (t.CanvasTexture = Ps),
    (t.DepthTexture = Cs),
    (t.Texture = Ei),
    (t.CompressedTextureLoader = oh),
    (t.DataTextureLoader = sh),
    (t.CubeTextureLoader = hh),
    (t.TextureLoader = lh),
    (t.ObjectLoader = gl),
    (t.MaterialLoader = ol),
    (t.BufferGeometryLoader = sl),
    (t.DefaultLoadingManager = nh),
    (t.LoadingManager = ih),
    (t.JSONLoader = ml),
    (t.ImageLoader = ch),
    (t.ImageBitmapLoader = _l),
    (t.FontLoader = Tl),
    (t.FileLoader = ah),
    (t.Loader = dl),
    (t.LoaderUtils = fl),
    (t.Cache = eh),
    (t.AudioLoader = Wl),
    (t.SpotLightShadow = Bh),
    (t.SpotLight = Fh),
    (t.PointLight = zh),
    (t.RectAreaLight = jh),
    (t.HemisphereLight = Dh),
    (t.DirectionalLightShadow = Hh),
    (t.DirectionalLight = Vh),
    (t.AmbientLight = kh),
    (t.LightShadow = Uh),
    (t.Light = Nh),
    (t.StereoCamera = Xl),
    (t.PerspectiveCamera = as),
    (t.OrthographicCamera = Gh),
    (t.CubeCamera = ql),
    (t.ArrayCamera = os),
    (t.Camera = rs),
    (t.AudioListener = Yl),
    (t.PositionalAudio = Zl),
    (t.AudioContext = jl),
    (t.AudioAnalyser = Ql),
    (t.Audio = Jl),
    (t.VectorKeyframeTrack = nl),
    (t.StringKeyframeTrack = il),
    (t.QuaternionKeyframeTrack = el),
    (t.NumberKeyframeTrack = $h),
    (t.ColorKeyframeTrack = Kh),
    (t.BooleanKeyframeTrack = Qh),
    (t.PropertyMixer = Kl),
    (t.PropertyBinding = Gu),
    (t.KeyframeTrack = Zh),
    (t.AnimationUtils = Wh),
    (t.AnimationObjectGroup = Hu),
    (t.AnimationMixer = ku),
    (t.AnimationClip = rl),
    (t.Uniform = ju),
    (t.InstancedBufferGeometry = Wu),
    (t.BufferGeometry = $n),
    (t.Geometry = Rn),
    (t.InterleavedBufferAttribute = fs),
    (t.InstancedInterleavedBuffer = Xu),
    (t.InterleavedBuffer = ds),
    (t.InstancedBufferAttribute = qu),
    (t.Face3 = Qi),
    (t.Object3D = bn),
    (t.Raycaster = Yu),
    (t.Layers = $i),
    (t.EventDispatcher = e),
    (t.Clock = Qu),
    (t.QuaternionLinearInterpolant = tl),
    (t.LinearInterpolant = Yh),
    (t.DiscreteInterpolant = Jh),
    (t.CubicInterpolant = qh),
    (t.Interpolant = Xh),
    (t.Triangle = qr),
    (t.Math = Ge),
    (t.Spherical = Ku),
    (t.Cylindrical = $u),
    (t.Plane = Ii),
    (t.Frustum = Ni),
    (t.Sphere = Oi),
    (t.Ray = Xr),
    (t.Matrix4 = Ve),
    (t.Matrix3 = We),
    (t.Box3 = Ri),
    (t.Box2 = tp),
    (t.Line3 = ep),
    (t.Euler = Ki),
    (t.Vector4 = Ti),
    (t.Vector3 = je),
    (t.Vector2 = He),
    (t.Quaternion = ke),
    (t.Color = Hi),
    (t.ImmediateRenderObject = ip),
    (t.VertexNormalsHelper = np),
    (t.SpotLightHelper = rp),
    (t.SkeletonHelper = ap),
    (t.PointLightHelper = op),
    (t.RectAreaLightHelper = sp),
    (t.HemisphereLightHelper = cp),
    (t.GridHelper = hp),
    (t.PolarGridHelper = lp),
    (t.FaceNormalsHelper = up),
    (t.DirectionalLightHelper = pp),
    (t.CameraHelper = dp),
    (t.BoxHelper = mp),
    (t.Box3Helper = gp),
    (t.PlaneHelper = vp),
    (t.ArrowHelper = yp),
    (t.AxesHelper = xp),
    (t.Shape = Ih),
    (t.Path = Oh),
    (t.ShapePath = wl),
    (t.Font = Ml),
    (t.CurvePath = Ch),
    (t.Curve = uh),
    (t.ImageUtils = wi),
    (t.ShapeUtils = yc),
    (t.WebGLUtils = is),
    (t.WireframeGeometry = Os),
    (t.ParametricGeometry = Is),
    (t.ParametricBufferGeometry = Ns),
    (t.TetrahedronGeometry = Bs),
    (t.TetrahedronBufferGeometry = Fs),
    (t.OctahedronGeometry = zs),
    (t.OctahedronBufferGeometry = Gs),
    (t.IcosahedronGeometry = Hs),
    (t.IcosahedronBufferGeometry = Vs),
    (t.DodecahedronGeometry = ks),
    (t.DodecahedronBufferGeometry = js),
    (t.PolyhedronGeometry = Ds),
    (t.PolyhedronBufferGeometry = Us),
    (t.TubeGeometry = Ws),
    (t.TubeBufferGeometry = Xs),
    (t.TorusKnotGeometry = qs),
    (t.TorusKnotBufferGeometry = Ys),
    (t.TorusGeometry = Js),
    (t.TorusBufferGeometry = Zs),
    (t.TextGeometry = Tc),
    (t.TextBufferGeometry = Sc),
    (t.SphereGeometry = Ac),
    (t.SphereBufferGeometry = Lc),
    (t.RingGeometry = Rc),
    (t.RingBufferGeometry = Pc),
    (t.PlaneGeometry = ir),
    (t.PlaneBufferGeometry = nr),
    (t.LatheGeometry = Cc),
    (t.LatheBufferGeometry = Oc),
    (t.ShapeGeometry = Ic),
    (t.ShapeBufferGeometry = Nc),
    (t.ExtrudeGeometry = _c),
    (t.ExtrudeBufferGeometry = wc),
    (t.EdgesGeometry = Uc),
    (t.ConeGeometry = zc),
    (t.ConeBufferGeometry = Gc),
    (t.CylinderGeometry = Bc),
    (t.CylinderBufferGeometry = Fc),
    (t.CircleGeometry = Hc),
    (t.CircleBufferGeometry = Vc),
    (t.BoxGeometry = tr),
    (t.BoxBufferGeometry = er),
    (t.ShadowMaterial = jc),
    (t.SpriteMaterial = ms),
    (t.RawShaderMaterial = Wc),
    (t.ShaderMaterial = Wr),
    (t.PointsMaterial = Ss),
    (t.MeshPhysicalMaterial = qc),
    (t.MeshStandardMaterial = Xc),
    (t.MeshPhongMaterial = Yc),
    (t.MeshToonMaterial = Jc),
    (t.MeshNormalMaterial = Zc),
    (t.MeshLambertMaterial = Qc),
    (t.MeshDepthMaterial = Qo),
    (t.MeshDistanceMaterial = Ko),
    (t.MeshBasicMaterial = Yr),
    (t.MeshMatcapMaterial = Kc),
    (t.LineDashedMaterial = $c),
    (t.LineBasicMaterial = ws),
    (t.Material = jr),
    (t.Float64BufferAttribute = zn),
    (t.Float32BufferAttribute = Fn),
    (t.Uint32BufferAttribute = Bn),
    (t.Int32BufferAttribute = Un),
    (t.Uint16BufferAttribute = Dn),
    (t.Int16BufferAttribute = Nn),
    (t.Uint8ClampedBufferAttribute = In),
    (t.Uint8BufferAttribute = On),
    (t.Int8BufferAttribute = Cn),
    (t.BufferAttribute = Pn),
    (t.ArcCurve = dh),
    (t.CatmullRomCurve3 = xh),
    (t.CubicBezierCurve = Mh),
    (t.CubicBezierCurve3 = Eh),
    (t.EllipseCurve = ph),
    (t.LineCurve = Th),
    (t.LineCurve3 = Sh),
    (t.QuadraticBezierCurve = Ah),
    (t.QuadraticBezierCurve3 = Lh),
    (t.SplineCurve = Rh),
    (t.REVISION = '97'),
    (t.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }),
    (t.CullFaceNone = X),
    (t.CullFaceBack = q),
    (t.CullFaceFront = Y),
    (t.CullFaceFrontBack = 3),
    (t.FrontFaceDirectionCW = 0),
    (t.FrontFaceDirectionCCW = 1),
    (t.BasicShadowMap = 0),
    (t.PCFShadowMap = G),
    (t.PCFSoftShadowMap = H),
    (t.FrontSide = D),
    (t.BackSide = wt),
    (t.DoubleSide = J),
    (t.FlatShading = 1),
    (t.SmoothShading = 2),
    (t.NoColors = M),
    (t.FaceColors = 1),
    (t.VertexColors = E),
    (t.NoBlending = Z),
    (t.NormalBlending = Q),
    (t.AdditiveBlending = K),
    (t.SubtractiveBlending = $),
    (t.MultiplyBlending = tt),
    (t.CustomBlending = et),
    (t.AddEquation = it),
    (t.SubtractEquation = T),
    (t.ReverseSubtractEquation = S),
    (t.MinEquation = A),
    (t.MaxEquation = L),
    (t.ZeroFactor = R),
    (t.OneFactor = P),
    (t.SrcColorFactor = C),
    (t.OneMinusSrcColorFactor = O),
    (t.SrcAlphaFactor = I),
    (t.OneMinusSrcAlphaFactor = N),
    (t.DstAlphaFactor = U),
    (t.OneMinusDstAlphaFactor = B),
    (t.DstColorFactor = F),
    (t.OneMinusDstColorFactor = z),
    (t.SrcAlphaSaturateFactor = V),
    (t.NeverDepth = nt),
    (t.AlwaysDepth = rt),
    (t.LessDepth = at),
    (t.LessEqualDepth = ot),
    (t.EqualDepth = st),
    (t.GreaterEqualDepth = ct),
    (t.GreaterDepth = ht),
    (t.NotEqualDepth = lt),
    (t.MultiplyOperation = k),
    (t.MixOperation = j),
    (t.AddOperation = W),
    (t.NoToneMapping = ut),
    (t.LinearToneMapping = Mt),
    (t.ReinhardToneMapping = pt),
    (t.Uncharted2ToneMapping = dt),
    (t.CineonToneMapping = ft),
    (t.UVMapping = 300),
    (t.CubeReflectionMapping = mt),
    (t.CubeRefractionMapping = gt),
    (t.EquirectangularReflectionMapping = vt),
    (t.EquirectangularRefractionMapping = yt),
    (t.SphericalReflectionMapping = xt),
    (t.CubeUVReflectionMapping = bt),
    (t.CubeUVRefractionMapping = _t),
    (t.RepeatWrapping = Et),
    (t.ClampToEdgeWrapping = Tt),
    (t.MirroredRepeatWrapping = St),
    (t.NearestFilter = At),
    (t.NearestMipMapNearestFilter = Lt),
    (t.NearestMipMapLinearFilter = Rt),
    (t.LinearFilter = Pt),
    (t.LinearMipMapNearestFilter = Ct),
    (t.LinearMipMapLinearFilter = Ot),
    (t.UnsignedByteType = It),
    (t.ByteType = Nt),
    (t.ShortType = Dt),
    (t.UnsignedShortType = Ut),
    (t.IntType = Bt),
    (t.UnsignedIntType = Ft),
    (t.FloatType = zt),
    (t.HalfFloatType = Gt),
    (t.UnsignedShort4444Type = Ht),
    (t.UnsignedShort5551Type = Vt),
    (t.UnsignedShort565Type = kt),
    (t.UnsignedInt248Type = jt),
    (t.AlphaFormat = Wt),
    (t.RGBFormat = Xt),
    (t.RGBAFormat = qt),
    (t.LuminanceFormat = Yt),
    (t.LuminanceAlphaFormat = Jt),
    (t.RGBEFormat = Zt),
    (t.DepthFormat = Qt),
    (t.DepthStencilFormat = Kt),
    (t.RedFormat = $t),
    (t.RGB_S3TC_DXT1_Format = te),
    (t.RGBA_S3TC_DXT1_Format = ee),
    (t.RGBA_S3TC_DXT3_Format = ie),
    (t.RGBA_S3TC_DXT5_Format = ne),
    (t.RGB_PVRTC_4BPPV1_Format = re),
    (t.RGB_PVRTC_2BPPV1_Format = ae),
    (t.RGBA_PVRTC_4BPPV1_Format = oe),
    (t.RGBA_PVRTC_2BPPV1_Format = se),
    (t.RGB_ETC1_Format = ce),
    (t.RGBA_ASTC_4x4_Format = he),
    (t.RGBA_ASTC_5x4_Format = le),
    (t.RGBA_ASTC_5x5_Format = ue),
    (t.RGBA_ASTC_6x5_Format = pe),
    (t.RGBA_ASTC_6x6_Format = de),
    (t.RGBA_ASTC_8x5_Format = fe),
    (t.RGBA_ASTC_8x6_Format = me),
    (t.RGBA_ASTC_8x8_Format = ge),
    (t.RGBA_ASTC_10x5_Format = ve),
    (t.RGBA_ASTC_10x6_Format = ye),
    (t.RGBA_ASTC_10x8_Format = xe),
    (t.RGBA_ASTC_10x10_Format = be),
    (t.RGBA_ASTC_12x10_Format = _e),
    (t.RGBA_ASTC_12x12_Format = we),
    (t.LoopOnce = 2200),
    (t.LoopRepeat = 2201),
    (t.LoopPingPong = 2202),
    (t.InterpolateDiscrete = Me),
    (t.InterpolateLinear = Ee),
    (t.InterpolateSmooth = 2302),
    (t.ZeroCurvatureEnding = Te),
    (t.ZeroSlopeEnding = Se),
    (t.WrapAroundEnding = Ae),
    (t.TrianglesDrawMode = Le),
    (t.TriangleStripDrawMode = 1),
    (t.TriangleFanDrawMode = 2),
    (t.LinearEncoding = Re),
    (t.sRGBEncoding = Pe),
    (t.GammaEncoding = Ce),
    (t.RGBEEncoding = Oe),
    (t.LogLuvEncoding = 3003),
    (t.RGBM7Encoding = Ie),
    (t.RGBM16Encoding = Ne),
    (t.RGBDEncoding = De),
    (t.BasicDepthPacking = Ue),
    (t.RGBADepthPacking = Be),
    (t.TangentSpaceNormalMap = Fe),
    (t.ObjectSpaceNormalMap = ze),
    (t.CubeGeometry = tr),
    (t.Face4 = function (t, e, i, n, r, a, o) {
      return (
        console.warn(
          'THREE.Face4 has been removed. A THREE.Face3 will be created instead.'
        ),
        new Qi(t, e, i, r, a, o)
      );
    }),
    (t.LineStrip = 0),
    (t.LinePieces = 1),
    (t.MeshFaceMaterial = function (t) {
      return (
        console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.'), t
      );
    }),
    (t.MultiMaterial = function (t) {
      return (
        void 0 === t && (t = []),
        console.warn('THREE.MultiMaterial has been removed. Use an Array instead.'),
        (t.isMultiMaterial = !0),
        ((t.materials = t).clone = function () {
          return t.slice();
        }),
        t
      );
    }),
    (t.PointCloud = function (t, e) {
      return (
        console.warn('THREE.PointCloud has been renamed to THREE.Points.'), new As(t, e)
      );
    }),
    (t.Particle = function (t) {
      return console.warn('THREE.Particle has been renamed to THREE.Sprite.'), new gs(t);
    }),
    (t.ParticleSystem = function (t, e) {
      return (
        console.warn('THREE.ParticleSystem has been renamed to THREE.Points.'),
        new As(t, e)
      );
    }),
    (t.PointCloudMaterial = function (t) {
      return (
        console.warn(
          'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.'
        ),
        new Ss(t)
      );
    }),
    (t.ParticleBasicMaterial = function (t) {
      return (
        console.warn(
          'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.'
        ),
        new Ss(t)
      );
    }),
    (t.ParticleSystemMaterial = function (t) {
      return (
        console.warn(
          'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.'
        ),
        new Ss(t)
      );
    }),
    (t.Vertex = function (t, e, i) {
      return (
        console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.'),
        new je(t, e, i)
      );
    }),
    (t.DynamicBufferAttribute = function (t, e) {
      return (
        console.warn(
          'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.'
        ),
        new Pn(t, e).setDynamic(!0)
      );
    }),
    (t.Int8Attribute = function (t, e) {
      return (
        console.warn(
          'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.'
        ),
        new Cn(t, e)
      );
    }),
    (t.Uint8Attribute = function (t, e) {
      return (
        console.warn(
          'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.'
        ),
        new On(t, e)
      );
    }),
    (t.Uint8ClampedAttribute = function (t, e) {
      return (
        console.warn(
          'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.'
        ),
        new In(t, e)
      );
    }),
    (t.Int16Attribute = function (t, e) {
      return (
        console.warn(
          'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.'
        ),
        new Nn(t, e)
      );
    }),
    (t.Uint16Attribute = function (t, e) {
      return (
        console.warn(
          'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.'
        ),
        new Dn(t, e)
      );
    }),
    (t.Int32Attribute = function (t, e) {
      return (
        console.warn(
          'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.'
        ),
        new Un(t, e)
      );
    }),
    (t.Uint32Attribute = function (t, e) {
      return (
        console.warn(
          'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.'
        ),
        new Bn(t, e)
      );
    }),
    (t.Float32Attribute = function (t, e) {
      return (
        console.warn(
          'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.'
        ),
        new Fn(t, e)
      );
    }),
    (t.Float64Attribute = function (t, e) {
      return (
        console.warn(
          'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.'
        ),
        new zn(t, e)
      );
    }),
    (t.ClosedSplineCurve3 = _p),
    (t.SplineCurve3 = wp),
    (t.Spline = Mp),
    (t.AxisHelper = function (t) {
      return (
        console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.'), new xp(t)
      );
    }),
    (t.BoundingBoxHelper = function (t, e) {
      return (
        console.warn(
          'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.'
        ),
        new mp(t, e)
      );
    }),
    (t.EdgesHelper = function (t, e) {
      return (
        console.warn(
          'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.'
        ),
        new Es(new Uc(t.geometry), new ws({ color: void 0 !== e ? e : 16777215 }))
      );
    }),
    (t.WireframeHelper = function (t, e) {
      return (
        console.warn(
          'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.'
        ),
        new Es(new Os(t.geometry), new ws({ color: void 0 !== e ? e : 16777215 }))
      );
    }),
    (t.XHRLoader = function (t) {
      return (
        console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.'), new ah(t)
      );
    }),
    (t.BinaryTextureLoader = function (t) {
      return (
        console.warn(
          'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.'
        ),
        new sh(t)
      );
    }),
    (t.GeometryUtils = Ep),
    (t.Projector = function () {
      console.error(
        'THREE.Projector has been moved to /examples/js/renderers/Projector.js.'
      ),
        (this.projectVector = function (t, e) {
          console.warn('THREE.Projector: .projectVector() is now vector.project().'),
            t.project(e);
        }),
        (this.unprojectVector = function (t, e) {
          console.warn('THREE.Projector: .unprojectVector() is now vector.unproject().'),
            t.unproject(e);
        }),
        (this.pickingRay = function () {
          console.error(
            'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().'
          );
        });
    }),
    (t.CanvasRenderer = function () {
      console.error(
        'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js'
      ),
        (this.domElement = document.createElementNS(
          'http://www.w3.org/1999/xhtml',
          'canvas'
        )),
        (this.clear = function () {}),
        (this.render = function () {}),
        (this.setClearColor = function () {}),
        (this.setSize = function () {});
    }),
    (t.SceneUtils = Tp),
    (t.LensFlare = function () {
      console.error(
        'THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js'
      );
    }),
    Object.defineProperty(t, '__esModule', { value: !0 });
});

/*
This helper can help for:
* adjusting the canvas resolution to the good size -> this is crucial to
optimize the code because if the canvas is too large,
there are too much pixels to compute => it will be slow

* to mirror horizontally or not the canvas -> if the front camera is used we
need it flipped (mirror effect), while if the rear camera is used we need it not flipped

* to get the best camera resolution (either above the canvas resolution or closer)
to balance between performance and quality
*/
('use strict');
var JeelizResizer = (function () {
  let t = null,
    e = null,
    n = 0,
    i = 1,
    r = !1,
    o = !1,
    s = !1,
    a = !1;
  const c = [
    [640, 480],
    [768, 480],
    [800, 600],
    [960, 640],
    [960, 720],
    [1024, 768],
    [1280, 720],
    [1920, 1080]
  ];
  function d(t, e) {
    var n, i;
    t[0] / t[1] > e[0] / e[1] ? ((n = t), (i = e)) : ((n = e), (i = t));
    const r = Math.min(n[0], i[0]) * Math.min(n[1], i[1]);
    var o;
    return (
      n[0] >= i[0] && n[1] >= i[1]
        ? (o = n[0] * n[1])
        : i[0] > n[0] && i[1] > n[1]
        ? (o = i[0] * i[1])
        : ((o = n[0] * n[1]), (o += (i[1] - n[1]) * i[0])),
      r / o
    );
  }
  function u() {
    const n = t.getBoundingClientRect();
    (e = [Math.round(i * n.width), Math.round(i * n.height)]),
      t.setAttribute('width', e[0]),
      t.setAttribute('height', e[1]);
  }
  function l() {
    o && clearTimeout(o), (o = setTimeout(v, 50));
  }
  function h() {
    (e = [window.innerWidth, window.innerHeight]),
      a && e.reverse(),
      t.setAttribute('width', e[0]),
      t.setAttribute('height', e[1]);
  }
  function v() {
    h(), JEEFACEFILTERAPI.resize(), (o = !1), s && s();
  }
  const g = {
    is_portrait: function () {
      try {
        return !!window.matchMedia('(orientation: portrait)').matches;
      } catch (t) {
        return window.innerHeight > window.innerWidth;
      }
    },
    check_isIOS: function () {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    },
    get_IOSVersion: function () {
      const t = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
      return t.length > 2
        ? [parseInt(t[1], 10), parseInt(t[2], 10), parseInt(t[3] || 0, 10)]
        : [0, 0, 0];
    },
    check_isAndroid: function () {
      return -1 !== navigator.userAgent.toLowerCase().indexOf('android');
    },
    get_androidVersion: function () {
      const t = navigator.userAgent.toLowerCase().match(/android\s([0-9\.]*)/i);
      if (!t || t.length < 2) return [0, 0, 0];
      const e = t[1].split('.');
      return [parseInt(e[0], 10), parseInt(e[1], 10), parseInt(e[2] || 0, 10)];
    },
    require_flipVideoWHIfPortrait: function () {
      return !0;
    },
    size_canvas: function (o) {
      if (
        ((t = o.canvas ? o.canvas : document.getElementById(o.canvasId)),
        (r = void 0 !== o.isFullScreen && o.isFullScreen),
        (a = void 0 !== o.isInvWH && o.isInvWH),
        r)
      )
        void 0 !== o.onResize && (s = o.onResize),
          h(),
          window.addEventListener('resize', l, !1),
          window.addEventListener('orientationchange', l, !1);
      else {
        const e = t.getBoundingClientRect();
        if (0 === e.width || 0 === e.height)
          return (
            console.log(
              'WARNING in JeelizResize.size_canvas() : the canvas has its width or its height null, Retry a bit later...'
            ),
            ++n > 20
              ? void o.callback('CANNOT_RESIZECANVAS')
              : void setTimeout(g.size_canvas.bind(null, o), 50)
          );
        (n = 0), (i = void 0 === o.overSamplingFactor ? 1 : o.overSamplingFactor), u();
      }
      void 0 !== o.CSSFlipX &&
        o.CSSFlipX &&
        (function (t, e) {
          const n = t.style.transform;
          -1 === n.indexOf(e) && (t.style.transform = e + ' ' + n);
        })(t, 'rotateY(180deg)');
      const v = c.slice(0);
      g.is_portrait() &&
        g.require_flipVideoWHIfPortrait() &&
        v.forEach(function (t) {
          t.reverse();
        });
      const f = window.devicePixelRatio ? window.devicePixelRatio : 1,
        w = [e[0] * f, e[1] * f];
      v.sort(function (t, e) {
        return d(e, w) - d(t, w);
      });
      const I = { idealWidth: v[0][0], idealHeight: v[0][1] };
      console.log('INFO in JeelizResizer: bestCameraResolution =', I),
        setTimeout(o.callback.bind(null, !1, I), 1);
    },
    resize_canvas: function () {
      r || u();
    }
  };
  return g;
})();

/* jeelizFaceFilter/helpers/JeelizThreejsHelper.js */
('use strict');
THREE.JeelizHelper = (function () {
  const e = {
    rotationOffsetX: 0,
    pivotOffsetYZ: [0.4, 0.2],
    detectionThreshold: 0.8,
    detectionHysteresis: 0.05,
    tweakMoveYRotateY: 0.5,
    cameraMinVideoDimFov: 46,
    isDebugPivotPoint: !1
  };
  let t = null,
    n = null,
    r = null,
    i = null,
    o = -1,
    a = !1,
    s = null,
    d = !1,
    c = !1,
    l = null,
    u = null,
    f = !1,
    E = 1;
  const h = [],
    p = [];
  let v = null,
    m = null,
    T = null;
  function R(t) {
    h.forEach(function (n, r) {
      f = n.visible;
      const i = t[r];
      f && i.detected < e.detectionThreshold - e.detectionHysteresis
        ? (s && s(r, !1), (n.visible = !1))
        : !f &&
          i.detected > e.detectionThreshold + e.detectionHysteresis &&
          (s && s(r, !0), (n.visible = !0));
    });
  }
  const w = {
    init: function (d, f) {
      (o = d.maxFacesDetected),
        (m = d.videoTexture),
        (v = d.GL),
        (l = d.canvasElement),
        (a = o > 1),
        (u = d.videoElement);
      let E = null;
      d.threejsCanvasId
        ? ((c = !0),
          (E = document.getElementById(d.threejsCanvasId)).setAttribute('width', l.width),
          E.setAttribute('height', l.height))
        : (E = l),
        void 0 !== f && (s = f),
        (t = new THREE.WebGLRenderer({
          context: c ? null : v,
          canvas: E,
          alpha: !(!c && !d.alpha)
        })),
        (n = new THREE.Scene()),
        (function () {
          for (let t = 0; t < o; ++t) {
            const t = new THREE.Object3D();
            (t.frustumCulled = !1), (t.visible = !1);
            const r = new THREE.Object3D();
            if (
              ((r.frustumCulled = !1),
              t.add(r),
              h.push(t),
              p.push(r),
              n.add(t),
              e.isDebugPivotPoint)
            ) {
              const e = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.1, 0.1),
                new THREE.MeshNormalMaterial({ side: THREE.DoubleSide, depthTest: !1 })
              );
              e.position.copy(r.position),
                t.add(e),
                (window.pivot = e),
                console.log(
                  'DEBUG in JeelizHelper: set the position of <pivot> in the console and report the value into JeelizThreejsHelper.js for _settings.pivotOffsetYZ'
                );
            }
          }
        })(),
        (function () {
          const e =
              'attribute vec2 position;\n        varying vec2 vUV;\n        void main(void){\n          gl_Position = vec4(position, 0., 1.);\n          vUV = 0.5+0.5*position;\n        }',
            t =
              'precision lowp float;\n        uniform sampler2D samplerVideo;\n        varying vec2 vUV;\n        void main(void){\n          gl_FragColor = texture2D(samplerVideo, vUV);\n        }';
          if (c) {
            const n = function (e, t, n) {
                const r = v.createShader(t);
                return (
                  v.shaderSource(r, e),
                  v.compileShader(r),
                  v.getShaderParameter(r, v.COMPILE_STATUS)
                    ? r
                    : (alert('ERROR IN ' + n + ' SHADER : ' + v.getShaderInfoLog(r)), !1)
                );
              },
              r = n(e, v.VERTEX_SHADER, 'VERTEX'),
              i = n(t, v.FRAGMENT_SHADER, 'FRAGMENT');
            return (
              (T = v.createProgram()),
              v.attachShader(T, r),
              v.attachShader(T, i),
              v.linkProgram(T),
              void v.getUniformLocation(T, 'samplerVideo')
            );
          }
          (i = new THREE.DataTexture(
            new Uint8Array([255, 0, 0]),
            1,
            1,
            THREE.RGBFormat
          )).needsUpdate = !0;
          const o = new THREE.RawShaderMaterial({
              depthWrite: !1,
              depthTest: !1,
              vertexShader: e,
              fragmentShader: t,
              uniforms: { samplerVideo: { value: i } }
            }),
            a = new THREE.BufferGeometry(),
            s = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]);
          a.addAttribute('position', new THREE.BufferAttribute(s, 2)),
            a.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 0, 2, 3]), 1)),
            (r = new THREE.Mesh(a, o)),
            w.apply_videoTexture(r),
            (r.renderOrder = -1e3),
            (r.frustumCulled = !1),
            n.add(r);
        })(),
        window.addEventListener(
          'orientationchange',
          function () {
            setTimeout(JEEFACEFILTERAPI.resize, 1e3);
          },
          !1
        );
      const R = { videoMesh: r, renderer: t, scene: n };
      return a ? (R.faceObjects = p) : (R.faceObject = p[0]), R;
    },
    detect: function (e) {
      R(a ? e : [e]);
    },
    get_isDetected: function () {
      return f;
    },
    render: function (r, i) {
      const o = a ? r : [r];
      R(o),
        (function (t, n) {
          const r = Math.tan((n.aspect * n.fov * Math.PI) / 360);
          h.forEach(function (i, o) {
            if (!i.visible) return;
            const a = t[o],
              s = e.tweakMoveYRotateY * Math.tan(a.rx),
              d = Math.cos(a.rz),
              c = Math.sin(a.rz),
              l = a.s * E,
              u = c * s * l,
              f = d * s * (l * n.aspect),
              h = 1 / (2 * l * r),
              v = a.x * E + u,
              m = a.y + f,
              T = -h - 0.5,
              R = v * h * r,
              w = (m * h * r) / n.aspect;
            p[o].position.set(
              -c * e.pivotOffsetYZ[0],
              -d * e.pivotOffsetYZ[0],
              -e.pivotOffsetYZ[1]
            ),
              i.position.set(R, w + e.pivotOffsetYZ[0], T + e.pivotOffsetYZ[1]),
              i.rotation.set(a.rx + e.rotationOffsetX, a.ry, a.rz, 'ZXY');
          });
        })(o, i),
        c
          ? (v.viewport(0, 0, l.width, l.height),
            v.useProgram(T),
            v.activeTexture(v.TEXTURE0),
            v.bindTexture(v.TEXTURE_2D, m),
            v.drawElements(v.TRIANGLES, 3, v.UNSIGNED_SHORT, 0))
          : t.state.reset(),
        t.render(n, i);
    },
    sortFaces: function (e, t, n) {
      const r = { X: 0, Y: 1, Z: 2 }[t.toUpperCase()],
        i = n ? -1 : 1,
        o = e.index.count / 3,
        a = new Array(o);
      for (let t = 0; t < o; ++t)
        a[t] = [e.index.array[3 * t], e.index.array[3 * t + 1], e.index.array[3 * t + 2]];
      const s = e.attributes.position.array,
        d = a.map(function (e, t) {
          return [
            (s[3 * e[0]] + s[3 * e[1]] + s[3 * e[2]]) / 3,
            (s[3 * e[0] + 1] + s[3 * e[1] + 1] + s[3 * e[2] + 1]) / 3,
            (s[3 * e[0] + 2] + s[3 * e[1] + 2] + s[3 * e[2] + 2]) / 3,
            e
          ];
        });
      d.sort(function (e, t) {
        return (e[r] - t[r]) * i;
      }),
        d.forEach(function (t, n) {
          const r = t[3];
          (e.index.array[3 * n] = r[0]),
            (e.index.array[3 * n + 1] = r[1]),
            (e.index.array[3 * n + 2] = r[2]);
        });
    },
    get_threeVideoTexture: function () {
      return i;
    },
    apply_videoTexture: function (e) {
      d ||
        (e.onAfterRender = function () {
          try {
            t.properties.update(i, '__webglTexture', m),
              (i.magFilter = THREE.LinearFilter),
              (i.minFilter = THREE.LinearFilter),
              (d = !0);
          } catch (e) {
            console.log(
              'WARNING in THREE.JeelizHelper : the glVideoTexture is not fully initialized'
            );
          }
          delete e.onAfterRender;
        });
    },
    create_threejsOccluder: function (e, t) {
      const n = new THREE.Mesh();
      return (
        new THREE.BufferGeometryLoader().load(e, function (e) {
          const r = new THREE.ShaderMaterial({
            vertexShader: THREE.ShaderLib.basic.vertexShader,
            fragmentShader:
              'precision lowp float;\n void main(void){\n gl_FragColor=vec4(1.,0.,0.,1.);\n }',
            uniforms: THREE.ShaderLib.basic.uniforms,
            colorWrite: !1
          });
          (n.renderOrder = -1),
            (n.material = r),
            (n.geometry = e),
            void 0 !== t && t && t(n);
        }),
        n
      );
    },
    set_pivotOffsetYZ: function (t) {
      e.pivotOffsetYZ = t;
    },
    create_camera: function (e, t) {
      const n = new THREE.PerspectiveCamera(1, 1, e || 0.1, t || 100);
      return w.update_camera(n), n;
    },
    update_camera: function (n) {
      const r = t.domElement,
        i = r.width,
        o = r.height,
        a = i / o,
        s = u.videoWidth,
        d = u.videoHeight,
        c = s / d,
        l = d > s ? 1 / c : 1,
        f = e.cameraMinVideoDimFov * l;
      let h = 1;
      const p = s * (h = a > c ? i / s : o / d),
        v = d * h,
        m = (p - i) / 2,
        T = (v - o) / 2;
      (E = i / p),
        (n.aspect = a),
        (n.fov = f),
        console.log(
          'INFO in JeelizThreejsHelper.update_camera() : camera vertical estimated FoV is',
          f,
          'deg'
        ),
        n.setViewOffset(p, v, m, T, i, o),
        n.updateProjectionMatrix(),
        t.setSize(i, o, !1),
        t.setViewport(0, 0, i, o);
    },
    resize: function (e, n, r) {
      (t.domElement.width = e),
        (t.domElement.height = n),
        JEEFACEFILTERAPI.resize(),
        r && w.update_camera(r);
    }
  };
  return w;
})();
